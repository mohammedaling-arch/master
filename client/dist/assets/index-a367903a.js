(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const i of document.querySelectorAll('link[rel="modulepreload"]')) r(i); new MutationObserver(i => { for (const o of i) if (o.type === "childList") for (const s of o.addedNodes) s.tagName === "LINK" && s.rel === "modulepreload" && r(s) }).observe(document, { childList: !0, subtree: !0 }); function n(i) { const o = {}; return i.integrity && (o.integrity = i.integrity), i.referrerPolicy && (o.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? o.credentials = "include" : i.crossOrigin === "anonymous" ? o.credentials = "omit" : o.credentials = "same-origin", o } function r(i) { if (i.ep) return; i.ep = !0; const o = n(i); fetch(i.href, o) } })(); var NR = typeof globalThis < "u" ? globalThis : typeof window < "u" ? window : typeof global < "u" ? global : typeof self < "u" ? self : {}; function D0(e) { return e && e.__esModule && Object.prototype.hasOwnProperty.call(e, "default") ? e.default : e } var Gh = { exports: {} }, ys = {}, Xh = { exports: {} }, F = {};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Ai = Symbol.for("react.element"), _0 = Symbol.for("react.portal"), M0 = Symbol.for("react.fragment"), O0 = Symbol.for("react.strict_mode"), N0 = Symbol.for("react.profiler"), V0 = Symbol.for("react.provider"), I0 = Symbol.for("react.context"), F0 = Symbol.for("react.forward_ref"), j0 = Symbol.for("react.suspense"), B0 = Symbol.for("react.memo"), z0 = Symbol.for("react.lazy"), Yc = Symbol.iterator; function U0(e) { return e === null || typeof e != "object" ? null : (e = Yc && e[Yc] || e["@@iterator"], typeof e == "function" ? e : null) } var Yh = { isMounted: function () { return !1 }, enqueueForceUpdate: function () { }, enqueueReplaceState: function () { }, enqueueSetState: function () { } }, Qh = Object.assign, qh = {}; function gr(e, t, n) { this.props = e, this.context = t, this.refs = qh, this.updater = n || Yh } gr.prototype.isReactComponent = {}; gr.prototype.setState = function (e, t) { if (typeof e != "object" && typeof e != "function" && e != null) throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables."); this.updater.enqueueSetState(this, e, t, "setState") }; gr.prototype.forceUpdate = function (e) { this.updater.enqueueForceUpdate(this, e, "forceUpdate") }; function Jh() { } Jh.prototype = gr.prototype; function lu(e, t, n) { this.props = e, this.context = t, this.refs = qh, this.updater = n || Yh } var uu = lu.prototype = new Jh; uu.constructor = lu; Qh(uu, gr.prototype); uu.isPureReactComponent = !0; var Qc = Array.isArray, Zh = Object.prototype.hasOwnProperty, cu = { current: null }, ep = { key: !0, ref: !0, __self: !0, __source: !0 }; function tp(e, t, n) { var r, i = {}, o = null, s = null; if (t != null) for (r in t.ref !== void 0 && (s = t.ref), t.key !== void 0 && (o = "" + t.key), t) Zh.call(t, r) && !ep.hasOwnProperty(r) && (i[r] = t[r]); var a = arguments.length - 2; if (a === 1) i.children = n; else if (1 < a) { for (var l = Array(a), u = 0; u < a; u++)l[u] = arguments[u + 2]; i.children = l } if (e && e.defaultProps) for (r in a = e.defaultProps, a) i[r] === void 0 && (i[r] = a[r]); return { $$typeof: Ai, type: e, key: o, ref: s, props: i, _owner: cu.current } } function $0(e, t) { return { $$typeof: Ai, type: e.type, key: t, ref: e.ref, props: e.props, _owner: e._owner } } function fu(e) { return typeof e == "object" && e !== null && e.$$typeof === Ai } function b0(e) { var t = { "=": "=0", ":": "=2" }; return "$" + e.replace(/[=:]/g, function (n) { return t[n] }) } var qc = /\/+/g; function Ws(e, t) { return typeof e == "object" && e !== null && e.key != null ? b0("" + e.key) : t.toString(36) } function po(e, t, n, r, i) { var o = typeof e; (o === "undefined" || o === "boolean") && (e = null); var s = !1; if (e === null) s = !0; else switch (o) { case "string": case "number": s = !0; break; case "object": switch (e.$$typeof) { case Ai: case _0: s = !0 } }if (s) return s = e, i = i(s), e = r === "" ? "." + Ws(s, 0) : r, Qc(i) ? (n = "", e != null && (n = e.replace(qc, "$&/") + "/"), po(i, t, n, "", function (u) { return u })) : i != null && (fu(i) && (i = $0(i, n + (!i.key || s && s.key === i.key ? "" : ("" + i.key).replace(qc, "$&/") + "/") + e)), t.push(i)), 1; if (s = 0, r = r === "" ? "." : r + ":", Qc(e)) for (var a = 0; a < e.length; a++) { o = e[a]; var l = r + Ws(o, a); s += po(o, t, n, l, i) } else if (l = U0(e), typeof l == "function") for (e = l.call(e), a = 0; !(o = e.next()).done;)o = o.value, l = r + Ws(o, a++), s += po(o, t, n, l, i); else if (o === "object") throw t = String(e), Error("Objects are not valid as a React child (found: " + (t === "[object Object]" ? "object with keys {" + Object.keys(e).join(", ") + "}" : t) + "). If you meant to render a collection of children, use an array instead."); return s } function Wi(e, t, n) { if (e == null) return e; var r = [], i = 0; return po(e, r, "", "", function (o) { return t.call(n, o, i++) }), r } function W0(e) { if (e._status === -1) { var t = e._result; t = t(), t.then(function (n) { (e._status === 0 || e._status === -1) && (e._status = 1, e._result = n) }, function (n) { (e._status === 0 || e._status === -1) && (e._status = 2, e._result = n) }), e._status === -1 && (e._status = 0, e._result = t) } if (e._status === 1) return e._result.default; throw e._result } var Le = { current: null }, mo = { transition: null }, H0 = { ReactCurrentDispatcher: Le, ReactCurrentBatchConfig: mo, ReactCurrentOwner: cu }; function np() { throw Error("act(...) is not supported in production builds of React.") } F.Children = { map: Wi, forEach: function (e, t, n) { Wi(e, function () { t.apply(this, arguments) }, n) }, count: function (e) { var t = 0; return Wi(e, function () { t++ }), t }, toArray: function (e) { return Wi(e, function (t) { return t }) || [] }, only: function (e) { if (!fu(e)) throw Error("React.Children.only expected to receive a single React element child."); return e } }; F.Component = gr; F.Fragment = M0; F.Profiler = N0; F.PureComponent = lu; F.StrictMode = O0; F.Suspense = j0; F.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = H0; F.act = np; F.cloneElement = function (e, t, n) { if (e == null) throw Error("React.cloneElement(...): The argument must be a React element, but you passed " + e + "."); var r = Qh({}, e.props), i = e.key, o = e.ref, s = e._owner; if (t != null) { if (t.ref !== void 0 && (o = t.ref, s = cu.current), t.key !== void 0 && (i = "" + t.key), e.type && e.type.defaultProps) var a = e.type.defaultProps; for (l in t) Zh.call(t, l) && !ep.hasOwnProperty(l) && (r[l] = t[l] === void 0 && a !== void 0 ? a[l] : t[l]) } var l = arguments.length - 2; if (l === 1) r.children = n; else if (1 < l) { a = Array(l); for (var u = 0; u < l; u++)a[u] = arguments[u + 2]; r.children = a } return { $$typeof: Ai, type: e.type, key: i, ref: o, props: r, _owner: s } }; F.createContext = function (e) { return e = { $$typeof: I0, _currentValue: e, _currentValue2: e, _threadCount: 0, Provider: null, Consumer: null, _defaultValue: null, _globalName: null }, e.Provider = { $$typeof: V0, _context: e }, e.Consumer = e }; F.createElement = tp; F.createFactory = function (e) { var t = tp.bind(null, e); return t.type = e, t }; F.createRef = function () { return { current: null } }; F.forwardRef = function (e) { return { $$typeof: F0, render: e } }; F.isValidElement = fu; F.lazy = function (e) { return { $$typeof: z0, _payload: { _status: -1, _result: e }, _init: W0 } }; F.memo = function (e, t) { return { $$typeof: B0, type: e, compare: t === void 0 ? null : t } }; F.startTransition = function (e) { var t = mo.transition; mo.transition = {}; try { e() } finally { mo.transition = t } }; F.unstable_act = np; F.useCallback = function (e, t) { return Le.current.useCallback(e, t) }; F.useContext = function (e) { return Le.current.useContext(e) }; F.useDebugValue = function () { }; F.useDeferredValue = function (e) { return Le.current.useDeferredValue(e) }; F.useEffect = function (e, t) { return Le.current.useEffect(e, t) }; F.useId = function () { return Le.current.useId() }; F.useImperativeHandle = function (e, t, n) { return Le.current.useImperativeHandle(e, t, n) }; F.useInsertionEffect = function (e, t) { return Le.current.useInsertionEffect(e, t) }; F.useLayoutEffect = function (e, t) { return Le.current.useLayoutEffect(e, t) }; F.useMemo = function (e, t) { return Le.current.useMemo(e, t) }; F.useReducer = function (e, t, n) { return Le.current.useReducer(e, t, n) }; F.useRef = function (e) { return Le.current.useRef(e) }; F.useState = function (e) { return Le.current.useState(e) }; F.useSyncExternalStore = function (e, t, n) { return Le.current.useSyncExternalStore(e, t, n) }; F.useTransition = function () { return Le.current.useTransition() }; F.version = "18.3.1"; Xh.exports = F; var w = Xh.exports; const ja = D0(w);/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var K0 = w, G0 = Symbol.for("react.element"), X0 = Symbol.for("react.fragment"), Y0 = Object.prototype.hasOwnProperty, Q0 = K0.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner, q0 = { key: !0, ref: !0, __self: !0, __source: !0 }; function rp(e, t, n) { var r, i = {}, o = null, s = null; n !== void 0 && (o = "" + n), t.key !== void 0 && (o = "" + t.key), t.ref !== void 0 && (s = t.ref); for (r in t) Y0.call(t, r) && !q0.hasOwnProperty(r) && (i[r] = t[r]); if (e && e.defaultProps) for (r in t = e.defaultProps, t) i[r] === void 0 && (i[r] = t[r]); return { $$typeof: G0, type: e, key: o, ref: s, props: i, _owner: Q0.current } } ys.Fragment = X0; ys.jsx = rp; ys.jsxs = rp; Gh.exports = ys; var R = Gh.exports, Ba = {}, ip = { exports: {} }, We = {}, op = { exports: {} }, sp = {};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */(function (e) { function t(L, N) { var V = L.length; L.push(N); e: for (; 0 < V;) { var B = V - 1 >>> 1, $ = L[B]; if (0 < i($, N)) L[B] = N, L[V] = $, V = B; else break e } } function n(L) { return L.length === 0 ? null : L[0] } function r(L) { if (L.length === 0) return null; var N = L[0], V = L.pop(); if (V !== N) { L[0] = V; e: for (var B = 0, $ = L.length, Bt = $ >>> 1; B < Bt;) { var Ge = 2 * (B + 1) - 1, In = L[Ge], hn = Ge + 1, bi = L[hn]; if (0 > i(In, V)) hn < $ && 0 > i(bi, In) ? (L[B] = bi, L[hn] = V, B = hn) : (L[B] = In, L[Ge] = V, B = Ge); else if (hn < $ && 0 > i(bi, V)) L[B] = bi, L[hn] = V, B = hn; else break e } } return N } function i(L, N) { var V = L.sortIndex - N.sortIndex; return V !== 0 ? V : L.id - N.id } if (typeof performance == "object" && typeof performance.now == "function") { var o = performance; e.unstable_now = function () { return o.now() } } else { var s = Date, a = s.now(); e.unstable_now = function () { return s.now() - a } } var l = [], u = [], c = 1, f = null, d = 3, g = !1, y = !1, v = !1, S = typeof setTimeout == "function" ? setTimeout : null, p = typeof clearTimeout == "function" ? clearTimeout : null, h = typeof setImmediate < "u" ? setImmediate : null; typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling); function m(L) { for (var N = n(u); N !== null;) { if (N.callback === null) r(u); else if (N.startTime <= L) r(u), N.sortIndex = N.expirationTime, t(l, N); else break; N = n(u) } } function x(L) { if (v = !1, m(L), !y) if (n(l) !== null) y = !0, Ce(E); else { var N = n(u); N !== null && G(x, N.startTime - L) } } function E(L, N) { y = !1, v && (v = !1, p(C), C = -1), g = !0; var V = d; try { for (m(N), f = n(l); f !== null && (!(f.expirationTime > N) || L && !K());) { var B = f.callback; if (typeof B == "function") { f.callback = null, d = f.priorityLevel; var $ = B(f.expirationTime <= N); N = e.unstable_now(), typeof $ == "function" ? f.callback = $ : f === n(l) && r(l), m(N) } else r(l); f = n(l) } if (f !== null) var Bt = !0; else { var Ge = n(u); Ge !== null && G(x, Ge.startTime - N), Bt = !1 } return Bt } finally { f = null, d = V, g = !1 } } var k = !1, P = null, C = -1, O = 5, M = -1; function K() { return !(e.unstable_now() - M < O) } function Te() { if (P !== null) { var L = e.unstable_now(); M = L; var N = !0; try { N = P(!0, L) } finally { N ? Fe() : (k = !1, P = null) } } else k = !1 } var Fe; if (typeof h == "function") Fe = function () { h(Te) }; else if (typeof MessageChannel < "u") { var je = new MessageChannel, dn = je.port2; je.port1.onmessage = Te, Fe = function () { dn.postMessage(null) } } else Fe = function () { S(Te, 0) }; function Ce(L) { P = L, k || (k = !0, Fe()) } function G(L, N) { C = S(function () { L(e.unstable_now()) }, N) } e.unstable_IdlePriority = 5, e.unstable_ImmediatePriority = 1, e.unstable_LowPriority = 4, e.unstable_NormalPriority = 3, e.unstable_Profiling = null, e.unstable_UserBlockingPriority = 2, e.unstable_cancelCallback = function (L) { L.callback = null }, e.unstable_continueExecution = function () { y || g || (y = !0, Ce(E)) }, e.unstable_forceFrameRate = function (L) { 0 > L || 125 < L ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : O = 0 < L ? Math.floor(1e3 / L) : 5 }, e.unstable_getCurrentPriorityLevel = function () { return d }, e.unstable_getFirstCallbackNode = function () { return n(l) }, e.unstable_next = function (L) { switch (d) { case 1: case 2: case 3: var N = 3; break; default: N = d }var V = d; d = N; try { return L() } finally { d = V } }, e.unstable_pauseExecution = function () { }, e.unstable_requestPaint = function () { }, e.unstable_runWithPriority = function (L, N) { switch (L) { case 1: case 2: case 3: case 4: case 5: break; default: L = 3 }var V = d; d = L; try { return N() } finally { d = V } }, e.unstable_scheduleCallback = function (L, N, V) { var B = e.unstable_now(); switch (typeof V == "object" && V !== null ? (V = V.delay, V = typeof V == "number" && 0 < V ? B + V : B) : V = B, L) { case 1: var $ = -1; break; case 2: $ = 250; break; case 5: $ = 1073741823; break; case 4: $ = 1e4; break; default: $ = 5e3 }return $ = V + $, L = { id: c++, callback: N, priorityLevel: L, startTime: V, expirationTime: $, sortIndex: -1 }, V > B ? (L.sortIndex = V, t(u, L), n(l) === null && L === n(u) && (v ? (p(C), C = -1) : v = !0, G(x, V - B))) : (L.sortIndex = $, t(l, L), y || g || (y = !0, Ce(E))), L }, e.unstable_shouldYield = K, e.unstable_wrapCallback = function (L) { var N = d; return function () { var V = d; d = N; try { return L.apply(this, arguments) } finally { d = V } } } })(sp); op.exports = sp; var J0 = op.exports;/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Z0 = w, $e = J0; function A(e) { for (var t = "https://reactjs.org/docs/error-decoder.html?invariant=" + e, n = 1; n < arguments.length; n++)t += "&args[]=" + encodeURIComponent(arguments[n]); return "Minified React error #" + e + "; visit " + t + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings." } var ap = new Set, oi = {}; function Nn(e, t) { ar(e, t), ar(e + "Capture", t) } function ar(e, t) { for (oi[e] = t, e = 0; e < t.length; e++)ap.add(t[e]) } var Mt = !(typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u"), za = Object.prototype.hasOwnProperty, ev = /^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/, Jc = {}, Zc = {}; function tv(e) { return za.call(Zc, e) ? !0 : za.call(Jc, e) ? !1 : ev.test(e) ? Zc[e] = !0 : (Jc[e] = !0, !1) } function nv(e, t, n, r) { if (n !== null && n.type === 0) return !1; switch (typeof t) { case "function": case "symbol": return !0; case "boolean": return r ? !1 : n !== null ? !n.acceptsBooleans : (e = e.toLowerCase().slice(0, 5), e !== "data-" && e !== "aria-"); default: return !1 } } function rv(e, t, n, r) { if (t === null || typeof t > "u" || nv(e, t, n, r)) return !0; if (r) return !1; if (n !== null) switch (n.type) { case 3: return !t; case 4: return t === !1; case 5: return isNaN(t); case 6: return isNaN(t) || 1 > t }return !1 } function De(e, t, n, r, i, o, s) { this.acceptsBooleans = t === 2 || t === 3 || t === 4, this.attributeName = r, this.attributeNamespace = i, this.mustUseProperty = n, this.propertyName = e, this.type = t, this.sanitizeURL = o, this.removeEmptyString = s } var ye = {}; "children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function (e) { ye[e] = new De(e, 0, !1, e, null, !1, !1) });[["acceptCharset", "accept-charset"], ["className", "class"], ["htmlFor", "for"], ["httpEquiv", "http-equiv"]].forEach(function (e) { var t = e[0]; ye[t] = new De(t, 1, !1, e[1], null, !1, !1) });["contentEditable", "draggable", "spellCheck", "value"].forEach(function (e) { ye[e] = new De(e, 2, !1, e.toLowerCase(), null, !1, !1) });["autoReverse", "externalResourcesRequired", "focusable", "preserveAlpha"].forEach(function (e) { ye[e] = new De(e, 2, !1, e, null, !1, !1) }); "allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function (e) { ye[e] = new De(e, 3, !1, e.toLowerCase(), null, !1, !1) });["checked", "multiple", "muted", "selected"].forEach(function (e) { ye[e] = new De(e, 3, !0, e, null, !1, !1) });["capture", "download"].forEach(function (e) { ye[e] = new De(e, 4, !1, e, null, !1, !1) });["cols", "rows", "size", "span"].forEach(function (e) { ye[e] = new De(e, 6, !1, e, null, !1, !1) });["rowSpan", "start"].forEach(function (e) { ye[e] = new De(e, 5, !1, e.toLowerCase(), null, !1, !1) }); var du = /[\-:]([a-z])/g; function hu(e) { return e[1].toUpperCase() } "accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function (e) { var t = e.replace(du, hu); ye[t] = new De(t, 1, !1, e, null, !1, !1) }); "xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function (e) { var t = e.replace(du, hu); ye[t] = new De(t, 1, !1, e, "http://www.w3.org/1999/xlink", !1, !1) });["xml:base", "xml:lang", "xml:space"].forEach(function (e) { var t = e.replace(du, hu); ye[t] = new De(t, 1, !1, e, "http://www.w3.org/XML/1998/namespace", !1, !1) });["tabIndex", "crossOrigin"].forEach(function (e) { ye[e] = new De(e, 1, !1, e.toLowerCase(), null, !1, !1) }); ye.xlinkHref = new De("xlinkHref", 1, !1, "xlink:href", "http://www.w3.org/1999/xlink", !0, !1);["src", "href", "action", "formAction"].forEach(function (e) { ye[e] = new De(e, 1, !1, e.toLowerCase(), null, !0, !0) }); function pu(e, t, n, r) { var i = ye.hasOwnProperty(t) ? ye[t] : null; (i !== null ? i.type !== 0 : r || !(2 < t.length) || t[0] !== "o" && t[0] !== "O" || t[1] !== "n" && t[1] !== "N") && (rv(t, n, i, r) && (n = null), r || i === null ? tv(t) && (n === null ? e.removeAttribute(t) : e.setAttribute(t, "" + n)) : i.mustUseProperty ? e[i.propertyName] = n === null ? i.type === 3 ? !1 : "" : n : (t = i.attributeName, r = i.attributeNamespace, n === null ? e.removeAttribute(t) : (i = i.type, n = i === 3 || i === 4 && n === !0 ? "" : "" + n, r ? e.setAttributeNS(r, t, n) : e.setAttribute(t, n)))) } var jt = Z0.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED, Hi = Symbol.for("react.element"), jn = Symbol.for("react.portal"), Bn = Symbol.for("react.fragment"), mu = Symbol.for("react.strict_mode"), Ua = Symbol.for("react.profiler"), lp = Symbol.for("react.provider"), up = Symbol.for("react.context"), yu = Symbol.for("react.forward_ref"), $a = Symbol.for("react.suspense"), ba = Symbol.for("react.suspense_list"), gu = Symbol.for("react.memo"), $t = Symbol.for("react.lazy"), cp = Symbol.for("react.offscreen"), ef = Symbol.iterator; function Lr(e) { return e === null || typeof e != "object" ? null : (e = ef && e[ef] || e["@@iterator"], typeof e == "function" ? e : null) } var ee = Object.assign, Hs; function zr(e) {
  if (Hs === void 0) try { throw Error() } catch (n) { var t = n.stack.trim().match(/\n( *(at )?)/); Hs = t && t[1] || "" } return `
`+ Hs + e
} var Ks = !1; function Gs(e, t) {
  if (!e || Ks) return ""; Ks = !0; var n = Error.prepareStackTrace; Error.prepareStackTrace = void 0; try { if (t) if (t = function () { throw Error() }, Object.defineProperty(t.prototype, "props", { set: function () { throw Error() } }), typeof Reflect == "object" && Reflect.construct) { try { Reflect.construct(t, []) } catch (u) { var r = u } Reflect.construct(e, [], t) } else { try { t.call() } catch (u) { r = u } e.call(t.prototype) } else { try { throw Error() } catch (u) { r = u } e() } } catch (u) {
    if (u && r && typeof u.stack == "string") {
      for (var i = u.stack.split(`
`), o = r.stack.split(`
`), s = i.length - 1, a = o.length - 1; 1 <= s && 0 <= a && i[s] !== o[a];)a--; for (; 1 <= s && 0 <= a; s--, a--)if (i[s] !== o[a]) {
        if (s !== 1 || a !== 1) do if (s--, a--, 0 > a || i[s] !== o[a]) {
          var l = `
`+ i[s].replace(" at new ", " at "); return e.displayName && l.includes("<anonymous>") && (l = l.replace("<anonymous>", e.displayName)), l
        } while (1 <= s && 0 <= a); break
      }
    }
  } finally { Ks = !1, Error.prepareStackTrace = n } return (e = e ? e.displayName || e.name : "") ? zr(e) : ""
} function iv(e) { switch (e.tag) { case 5: return zr(e.type); case 16: return zr("Lazy"); case 13: return zr("Suspense"); case 19: return zr("SuspenseList"); case 0: case 2: case 15: return e = Gs(e.type, !1), e; case 11: return e = Gs(e.type.render, !1), e; case 1: return e = Gs(e.type, !0), e; default: return "" } } function Wa(e) { if (e == null) return null; if (typeof e == "function") return e.displayName || e.name || null; if (typeof e == "string") return e; switch (e) { case Bn: return "Fragment"; case jn: return "Portal"; case Ua: return "Profiler"; case mu: return "StrictMode"; case $a: return "Suspense"; case ba: return "SuspenseList" }if (typeof e == "object") switch (e.$$typeof) { case up: return (e.displayName || "Context") + ".Consumer"; case lp: return (e._context.displayName || "Context") + ".Provider"; case yu: var t = e.render; return e = e.displayName, e || (e = t.displayName || t.name || "", e = e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"), e; case gu: return t = e.displayName || null, t !== null ? t : Wa(e.type) || "Memo"; case $t: t = e._payload, e = e._init; try { return Wa(e(t)) } catch { } }return null } function ov(e) { var t = e.type; switch (e.tag) { case 24: return "Cache"; case 9: return (t.displayName || "Context") + ".Consumer"; case 10: return (t._context.displayName || "Context") + ".Provider"; case 18: return "DehydratedFragment"; case 11: return e = t.render, e = e.displayName || e.name || "", t.displayName || (e !== "" ? "ForwardRef(" + e + ")" : "ForwardRef"); case 7: return "Fragment"; case 5: return t; case 4: return "Portal"; case 3: return "Root"; case 6: return "Text"; case 16: return Wa(t); case 8: return t === mu ? "StrictMode" : "Mode"; case 22: return "Offscreen"; case 12: return "Profiler"; case 21: return "Scope"; case 13: return "Suspense"; case 19: return "SuspenseList"; case 25: return "TracingMarker"; case 1: case 0: case 17: case 2: case 14: case 15: if (typeof t == "function") return t.displayName || t.name || null; if (typeof t == "string") return t }return null } function rn(e) { switch (typeof e) { case "boolean": case "number": case "string": case "undefined": return e; case "object": return e; default: return "" } } function fp(e) { var t = e.type; return (e = e.nodeName) && e.toLowerCase() === "input" && (t === "checkbox" || t === "radio") } function sv(e) { var t = fp(e) ? "checked" : "value", n = Object.getOwnPropertyDescriptor(e.constructor.prototype, t), r = "" + e[t]; if (!e.hasOwnProperty(t) && typeof n < "u" && typeof n.get == "function" && typeof n.set == "function") { var i = n.get, o = n.set; return Object.defineProperty(e, t, { configurable: !0, get: function () { return i.call(this) }, set: function (s) { r = "" + s, o.call(this, s) } }), Object.defineProperty(e, t, { enumerable: n.enumerable }), { getValue: function () { return r }, setValue: function (s) { r = "" + s }, stopTracking: function () { e._valueTracker = null, delete e[t] } } } } function Ki(e) { e._valueTracker || (e._valueTracker = sv(e)) } function dp(e) { if (!e) return !1; var t = e._valueTracker; if (!t) return !0; var n = t.getValue(), r = ""; return e && (r = fp(e) ? e.checked ? "true" : "false" : e.value), e = r, e !== n ? (t.setValue(e), !0) : !1 } function Fo(e) { if (e = e || (typeof document < "u" ? document : void 0), typeof e > "u") return null; try { return e.activeElement || e.body } catch { return e.body } } function Ha(e, t) { var n = t.checked; return ee({}, t, { defaultChecked: void 0, defaultValue: void 0, value: void 0, checked: n ?? e._wrapperState.initialChecked }) } function tf(e, t) { var n = t.defaultValue == null ? "" : t.defaultValue, r = t.checked != null ? t.checked : t.defaultChecked; n = rn(t.value != null ? t.value : n), e._wrapperState = { initialChecked: r, initialValue: n, controlled: t.type === "checkbox" || t.type === "radio" ? t.checked != null : t.value != null } } function hp(e, t) { t = t.checked, t != null && pu(e, "checked", t, !1) } function Ka(e, t) { hp(e, t); var n = rn(t.value), r = t.type; if (n != null) r === "number" ? (n === 0 && e.value === "" || e.value != n) && (e.value = "" + n) : e.value !== "" + n && (e.value = "" + n); else if (r === "submit" || r === "reset") { e.removeAttribute("value"); return } t.hasOwnProperty("value") ? Ga(e, t.type, n) : t.hasOwnProperty("defaultValue") && Ga(e, t.type, rn(t.defaultValue)), t.checked == null && t.defaultChecked != null && (e.defaultChecked = !!t.defaultChecked) } function nf(e, t, n) { if (t.hasOwnProperty("value") || t.hasOwnProperty("defaultValue")) { var r = t.type; if (!(r !== "submit" && r !== "reset" || t.value !== void 0 && t.value !== null)) return; t = "" + e._wrapperState.initialValue, n || t === e.value || (e.value = t), e.defaultValue = t } n = e.name, n !== "" && (e.name = ""), e.defaultChecked = !!e._wrapperState.initialChecked, n !== "" && (e.name = n) } function Ga(e, t, n) { (t !== "number" || Fo(e.ownerDocument) !== e) && (n == null ? e.defaultValue = "" + e._wrapperState.initialValue : e.defaultValue !== "" + n && (e.defaultValue = "" + n)) } var Ur = Array.isArray; function er(e, t, n, r) { if (e = e.options, t) { t = {}; for (var i = 0; i < n.length; i++)t["$" + n[i]] = !0; for (n = 0; n < e.length; n++)i = t.hasOwnProperty("$" + e[n].value), e[n].selected !== i && (e[n].selected = i), i && r && (e[n].defaultSelected = !0) } else { for (n = "" + rn(n), t = null, i = 0; i < e.length; i++) { if (e[i].value === n) { e[i].selected = !0, r && (e[i].defaultSelected = !0); return } t !== null || e[i].disabled || (t = e[i]) } t !== null && (t.selected = !0) } } function Xa(e, t) { if (t.dangerouslySetInnerHTML != null) throw Error(A(91)); return ee({}, t, { value: void 0, defaultValue: void 0, children: "" + e._wrapperState.initialValue }) } function rf(e, t) { var n = t.value; if (n == null) { if (n = t.children, t = t.defaultValue, n != null) { if (t != null) throw Error(A(92)); if (Ur(n)) { if (1 < n.length) throw Error(A(93)); n = n[0] } t = n } t == null && (t = ""), n = t } e._wrapperState = { initialValue: rn(n) } } function pp(e, t) { var n = rn(t.value), r = rn(t.defaultValue); n != null && (n = "" + n, n !== e.value && (e.value = n), t.defaultValue == null && e.defaultValue !== n && (e.defaultValue = n)), r != null && (e.defaultValue = "" + r) } function of(e) { var t = e.textContent; t === e._wrapperState.initialValue && t !== "" && t !== null && (e.value = t) } function mp(e) { switch (e) { case "svg": return "http://www.w3.org/2000/svg"; case "math": return "http://www.w3.org/1998/Math/MathML"; default: return "http://www.w3.org/1999/xhtml" } } function Ya(e, t) { return e == null || e === "http://www.w3.org/1999/xhtml" ? mp(t) : e === "http://www.w3.org/2000/svg" && t === "foreignObject" ? "http://www.w3.org/1999/xhtml" : e } var Gi, yp = function (e) { return typeof MSApp < "u" && MSApp.execUnsafeLocalFunction ? function (t, n, r, i) { MSApp.execUnsafeLocalFunction(function () { return e(t, n, r, i) }) } : e }(function (e, t) { if (e.namespaceURI !== "http://www.w3.org/2000/svg" || "innerHTML" in e) e.innerHTML = t; else { for (Gi = Gi || document.createElement("div"), Gi.innerHTML = "<svg>" + t.valueOf().toString() + "</svg>", t = Gi.firstChild; e.firstChild;)e.removeChild(e.firstChild); for (; t.firstChild;)e.appendChild(t.firstChild) } }); function si(e, t) { if (t) { var n = e.firstChild; if (n && n === e.lastChild && n.nodeType === 3) { n.nodeValue = t; return } } e.textContent = t } var Kr = { animationIterationCount: !0, aspectRatio: !0, borderImageOutset: !0, borderImageSlice: !0, borderImageWidth: !0, boxFlex: !0, boxFlexGroup: !0, boxOrdinalGroup: !0, columnCount: !0, columns: !0, flex: !0, flexGrow: !0, flexPositive: !0, flexShrink: !0, flexNegative: !0, flexOrder: !0, gridArea: !0, gridRow: !0, gridRowEnd: !0, gridRowSpan: !0, gridRowStart: !0, gridColumn: !0, gridColumnEnd: !0, gridColumnSpan: !0, gridColumnStart: !0, fontWeight: !0, lineClamp: !0, lineHeight: !0, opacity: !0, order: !0, orphans: !0, tabSize: !0, widows: !0, zIndex: !0, zoom: !0, fillOpacity: !0, floodOpacity: !0, stopOpacity: !0, strokeDasharray: !0, strokeDashoffset: !0, strokeMiterlimit: !0, strokeOpacity: !0, strokeWidth: !0 }, av = ["Webkit", "ms", "Moz", "O"]; Object.keys(Kr).forEach(function (e) { av.forEach(function (t) { t = t + e.charAt(0).toUpperCase() + e.substring(1), Kr[t] = Kr[e] }) }); function gp(e, t, n) { return t == null || typeof t == "boolean" || t === "" ? "" : n || typeof t != "number" || t === 0 || Kr.hasOwnProperty(e) && Kr[e] ? ("" + t).trim() : t + "px" } function vp(e, t) { e = e.style; for (var n in t) if (t.hasOwnProperty(n)) { var r = n.indexOf("--") === 0, i = gp(n, t[n], r); n === "float" && (n = "cssFloat"), r ? e.setProperty(n, i) : e[n] = i } } var lv = ee({ menuitem: !0 }, { area: !0, base: !0, br: !0, col: !0, embed: !0, hr: !0, img: !0, input: !0, keygen: !0, link: !0, meta: !0, param: !0, source: !0, track: !0, wbr: !0 }); function Qa(e, t) { if (t) { if (lv[e] && (t.children != null || t.dangerouslySetInnerHTML != null)) throw Error(A(137, e)); if (t.dangerouslySetInnerHTML != null) { if (t.children != null) throw Error(A(60)); if (typeof t.dangerouslySetInnerHTML != "object" || !("__html" in t.dangerouslySetInnerHTML)) throw Error(A(61)) } if (t.style != null && typeof t.style != "object") throw Error(A(62)) } } function qa(e, t) { if (e.indexOf("-") === -1) return typeof t.is == "string"; switch (e) { case "annotation-xml": case "color-profile": case "font-face": case "font-face-src": case "font-face-uri": case "font-face-format": case "font-face-name": case "missing-glyph": return !1; default: return !0 } } var Ja = null; function vu(e) { return e = e.target || e.srcElement || window, e.correspondingUseElement && (e = e.correspondingUseElement), e.nodeType === 3 ? e.parentNode : e } var Za = null, tr = null, nr = null; function sf(e) { if (e = _i(e)) { if (typeof Za != "function") throw Error(A(280)); var t = e.stateNode; t && (t = xs(t), Za(e.stateNode, e.type, t)) } } function wp(e) { tr ? nr ? nr.push(e) : nr = [e] : tr = e } function Sp() { if (tr) { var e = tr, t = nr; if (nr = tr = null, sf(e), t) for (e = 0; e < t.length; e++)sf(t[e]) } } function xp(e, t) { return e(t) } function Ep() { } var Xs = !1; function Tp(e, t, n) { if (Xs) return e(t, n); Xs = !0; try { return xp(e, t, n) } finally { Xs = !1, (tr !== null || nr !== null) && (Ep(), Sp()) } } function ai(e, t) { var n = e.stateNode; if (n === null) return null; var r = xs(n); if (r === null) return null; n = r[t]; e: switch (t) { case "onClick": case "onClickCapture": case "onDoubleClick": case "onDoubleClickCapture": case "onMouseDown": case "onMouseDownCapture": case "onMouseMove": case "onMouseMoveCapture": case "onMouseUp": case "onMouseUpCapture": case "onMouseEnter": (r = !r.disabled) || (e = e.type, r = !(e === "button" || e === "input" || e === "select" || e === "textarea")), e = !r; break e; default: e = !1 }if (e) return null; if (n && typeof n != "function") throw Error(A(231, t, typeof n)); return n } var el = !1; if (Mt) try { var Dr = {}; Object.defineProperty(Dr, "passive", { get: function () { el = !0 } }), window.addEventListener("test", Dr, Dr), window.removeEventListener("test", Dr, Dr) } catch { el = !1 } function uv(e, t, n, r, i, o, s, a, l) { var u = Array.prototype.slice.call(arguments, 3); try { t.apply(n, u) } catch (c) { this.onError(c) } } var Gr = !1, jo = null, Bo = !1, tl = null, cv = { onError: function (e) { Gr = !0, jo = e } }; function fv(e, t, n, r, i, o, s, a, l) { Gr = !1, jo = null, uv.apply(cv, arguments) } function dv(e, t, n, r, i, o, s, a, l) { if (fv.apply(this, arguments), Gr) { if (Gr) { var u = jo; Gr = !1, jo = null } else throw Error(A(198)); Bo || (Bo = !0, tl = u) } } function Vn(e) { var t = e, n = e; if (e.alternate) for (; t.return;)t = t.return; else { e = t; do t = e, t.flags & 4098 && (n = t.return), e = t.return; while (e) } return t.tag === 3 ? n : null } function Cp(e) { if (e.tag === 13) { var t = e.memoizedState; if (t === null && (e = e.alternate, e !== null && (t = e.memoizedState)), t !== null) return t.dehydrated } return null } function af(e) { if (Vn(e) !== e) throw Error(A(188)) } function hv(e) { var t = e.alternate; if (!t) { if (t = Vn(e), t === null) throw Error(A(188)); return t !== e ? null : e } for (var n = e, r = t; ;) { var i = n.return; if (i === null) break; var o = i.alternate; if (o === null) { if (r = i.return, r !== null) { n = r; continue } break } if (i.child === o.child) { for (o = i.child; o;) { if (o === n) return af(i), e; if (o === r) return af(i), t; o = o.sibling } throw Error(A(188)) } if (n.return !== r.return) n = i, r = o; else { for (var s = !1, a = i.child; a;) { if (a === n) { s = !0, n = i, r = o; break } if (a === r) { s = !0, r = i, n = o; break } a = a.sibling } if (!s) { for (a = o.child; a;) { if (a === n) { s = !0, n = o, r = i; break } if (a === r) { s = !0, r = o, n = i; break } a = a.sibling } if (!s) throw Error(A(189)) } } if (n.alternate !== r) throw Error(A(190)) } if (n.tag !== 3) throw Error(A(188)); return n.stateNode.current === n ? e : t } function Pp(e) { return e = hv(e), e !== null ? kp(e) : null } function kp(e) { if (e.tag === 5 || e.tag === 6) return e; for (e = e.child; e !== null;) { var t = kp(e); if (t !== null) return t; e = e.sibling } return null } var Rp = $e.unstable_scheduleCallback, lf = $e.unstable_cancelCallback, pv = $e.unstable_shouldYield, mv = $e.unstable_requestPaint, ne = $e.unstable_now, yv = $e.unstable_getCurrentPriorityLevel, wu = $e.unstable_ImmediatePriority, Ap = $e.unstable_UserBlockingPriority, zo = $e.unstable_NormalPriority, gv = $e.unstable_LowPriority, Lp = $e.unstable_IdlePriority, gs = null, St = null; function vv(e) { if (St && typeof St.onCommitFiberRoot == "function") try { St.onCommitFiberRoot(gs, e, void 0, (e.current.flags & 128) === 128) } catch { } } var ct = Math.clz32 ? Math.clz32 : xv, wv = Math.log, Sv = Math.LN2; function xv(e) { return e >>>= 0, e === 0 ? 32 : 31 - (wv(e) / Sv | 0) | 0 } var Xi = 64, Yi = 4194304; function $r(e) { switch (e & -e) { case 1: return 1; case 2: return 2; case 4: return 4; case 8: return 8; case 16: return 16; case 32: return 32; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return e & 4194240; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return e & 130023424; case 134217728: return 134217728; case 268435456: return 268435456; case 536870912: return 536870912; case 1073741824: return 1073741824; default: return e } } function Uo(e, t) { var n = e.pendingLanes; if (n === 0) return 0; var r = 0, i = e.suspendedLanes, o = e.pingedLanes, s = n & 268435455; if (s !== 0) { var a = s & ~i; a !== 0 ? r = $r(a) : (o &= s, o !== 0 && (r = $r(o))) } else s = n & ~i, s !== 0 ? r = $r(s) : o !== 0 && (r = $r(o)); if (r === 0) return 0; if (t !== 0 && t !== r && !(t & i) && (i = r & -r, o = t & -t, i >= o || i === 16 && (o & 4194240) !== 0)) return t; if (r & 4 && (r |= n & 16), t = e.entangledLanes, t !== 0) for (e = e.entanglements, t &= r; 0 < t;)n = 31 - ct(t), i = 1 << n, r |= e[n], t &= ~i; return r } function Ev(e, t) { switch (e) { case 1: case 2: case 4: return t + 250; case 8: case 16: case 32: case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: return t + 5e3; case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: return -1; case 134217728: case 268435456: case 536870912: case 1073741824: return -1; default: return -1 } } function Tv(e, t) { for (var n = e.suspendedLanes, r = e.pingedLanes, i = e.expirationTimes, o = e.pendingLanes; 0 < o;) { var s = 31 - ct(o), a = 1 << s, l = i[s]; l === -1 ? (!(a & n) || a & r) && (i[s] = Ev(a, t)) : l <= t && (e.expiredLanes |= a), o &= ~a } } function nl(e) { return e = e.pendingLanes & -1073741825, e !== 0 ? e : e & 1073741824 ? 1073741824 : 0 } function Dp() { var e = Xi; return Xi <<= 1, !(Xi & 4194240) && (Xi = 64), e } function Ys(e) { for (var t = [], n = 0; 31 > n; n++)t.push(e); return t } function Li(e, t, n) { e.pendingLanes |= t, t !== 536870912 && (e.suspendedLanes = 0, e.pingedLanes = 0), e = e.eventTimes, t = 31 - ct(t), e[t] = n } function Cv(e, t) { var n = e.pendingLanes & ~t; e.pendingLanes = t, e.suspendedLanes = 0, e.pingedLanes = 0, e.expiredLanes &= t, e.mutableReadLanes &= t, e.entangledLanes &= t, t = e.entanglements; var r = e.eventTimes; for (e = e.expirationTimes; 0 < n;) { var i = 31 - ct(n), o = 1 << i; t[i] = 0, r[i] = -1, e[i] = -1, n &= ~o } } function Su(e, t) { var n = e.entangledLanes |= t; for (e = e.entanglements; n;) { var r = 31 - ct(n), i = 1 << r; i & t | e[r] & t && (e[r] |= t), n &= ~i } } var z = 0; function _p(e) { return e &= -e, 1 < e ? 4 < e ? e & 268435455 ? 16 : 536870912 : 4 : 1 } var Mp, xu, Op, Np, Vp, rl = !1, Qi = [], Yt = null, Qt = null, qt = null, li = new Map, ui = new Map, Wt = [], Pv = "mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" "); function uf(e, t) { switch (e) { case "focusin": case "focusout": Yt = null; break; case "dragenter": case "dragleave": Qt = null; break; case "mouseover": case "mouseout": qt = null; break; case "pointerover": case "pointerout": li.delete(t.pointerId); break; case "gotpointercapture": case "lostpointercapture": ui.delete(t.pointerId) } } function _r(e, t, n, r, i, o) { return e === null || e.nativeEvent !== o ? (e = { blockedOn: t, domEventName: n, eventSystemFlags: r, nativeEvent: o, targetContainers: [i] }, t !== null && (t = _i(t), t !== null && xu(t)), e) : (e.eventSystemFlags |= r, t = e.targetContainers, i !== null && t.indexOf(i) === -1 && t.push(i), e) } function kv(e, t, n, r, i) { switch (t) { case "focusin": return Yt = _r(Yt, e, t, n, r, i), !0; case "dragenter": return Qt = _r(Qt, e, t, n, r, i), !0; case "mouseover": return qt = _r(qt, e, t, n, r, i), !0; case "pointerover": var o = i.pointerId; return li.set(o, _r(li.get(o) || null, e, t, n, r, i)), !0; case "gotpointercapture": return o = i.pointerId, ui.set(o, _r(ui.get(o) || null, e, t, n, r, i)), !0 }return !1 } function Ip(e) { var t = vn(e.target); if (t !== null) { var n = Vn(t); if (n !== null) { if (t = n.tag, t === 13) { if (t = Cp(n), t !== null) { e.blockedOn = t, Vp(e.priority, function () { Op(n) }); return } } else if (t === 3 && n.stateNode.current.memoizedState.isDehydrated) { e.blockedOn = n.tag === 3 ? n.stateNode.containerInfo : null; return } } } e.blockedOn = null } function yo(e) { if (e.blockedOn !== null) return !1; for (var t = e.targetContainers; 0 < t.length;) { var n = il(e.domEventName, e.eventSystemFlags, t[0], e.nativeEvent); if (n === null) { n = e.nativeEvent; var r = new n.constructor(n.type, n); Ja = r, n.target.dispatchEvent(r), Ja = null } else return t = _i(n), t !== null && xu(t), e.blockedOn = n, !1; t.shift() } return !0 } function cf(e, t, n) { yo(e) && n.delete(t) } function Rv() { rl = !1, Yt !== null && yo(Yt) && (Yt = null), Qt !== null && yo(Qt) && (Qt = null), qt !== null && yo(qt) && (qt = null), li.forEach(cf), ui.forEach(cf) } function Mr(e, t) { e.blockedOn === t && (e.blockedOn = null, rl || (rl = !0, $e.unstable_scheduleCallback($e.unstable_NormalPriority, Rv))) } function ci(e) { function t(i) { return Mr(i, e) } if (0 < Qi.length) { Mr(Qi[0], e); for (var n = 1; n < Qi.length; n++) { var r = Qi[n]; r.blockedOn === e && (r.blockedOn = null) } } for (Yt !== null && Mr(Yt, e), Qt !== null && Mr(Qt, e), qt !== null && Mr(qt, e), li.forEach(t), ui.forEach(t), n = 0; n < Wt.length; n++)r = Wt[n], r.blockedOn === e && (r.blockedOn = null); for (; 0 < Wt.length && (n = Wt[0], n.blockedOn === null);)Ip(n), n.blockedOn === null && Wt.shift() } var rr = jt.ReactCurrentBatchConfig, $o = !0; function Av(e, t, n, r) { var i = z, o = rr.transition; rr.transition = null; try { z = 1, Eu(e, t, n, r) } finally { z = i, rr.transition = o } } function Lv(e, t, n, r) { var i = z, o = rr.transition; rr.transition = null; try { z = 4, Eu(e, t, n, r) } finally { z = i, rr.transition = o } } function Eu(e, t, n, r) { if ($o) { var i = il(e, t, n, r); if (i === null) oa(e, t, r, bo, n), uf(e, r); else if (kv(i, e, t, n, r)) r.stopPropagation(); else if (uf(e, r), t & 4 && -1 < Pv.indexOf(e)) { for (; i !== null;) { var o = _i(i); if (o !== null && Mp(o), o = il(e, t, n, r), o === null && oa(e, t, r, bo, n), o === i) break; i = o } i !== null && r.stopPropagation() } else oa(e, t, r, null, n) } } var bo = null; function il(e, t, n, r) { if (bo = null, e = vu(r), e = vn(e), e !== null) if (t = Vn(e), t === null) e = null; else if (n = t.tag, n === 13) { if (e = Cp(t), e !== null) return e; e = null } else if (n === 3) { if (t.stateNode.current.memoizedState.isDehydrated) return t.tag === 3 ? t.stateNode.containerInfo : null; e = null } else t !== e && (e = null); return bo = e, null } function Fp(e) { switch (e) { case "cancel": case "click": case "close": case "contextmenu": case "copy": case "cut": case "auxclick": case "dblclick": case "dragend": case "dragstart": case "drop": case "focusin": case "focusout": case "input": case "invalid": case "keydown": case "keypress": case "keyup": case "mousedown": case "mouseup": case "paste": case "pause": case "play": case "pointercancel": case "pointerdown": case "pointerup": case "ratechange": case "reset": case "resize": case "seeked": case "submit": case "touchcancel": case "touchend": case "touchstart": case "volumechange": case "change": case "selectionchange": case "textInput": case "compositionstart": case "compositionend": case "compositionupdate": case "beforeblur": case "afterblur": case "beforeinput": case "blur": case "fullscreenchange": case "focus": case "hashchange": case "popstate": case "select": case "selectstart": return 1; case "drag": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "mousemove": case "mouseout": case "mouseover": case "pointermove": case "pointerout": case "pointerover": case "scroll": case "toggle": case "touchmove": case "wheel": case "mouseenter": case "mouseleave": case "pointerenter": case "pointerleave": return 4; case "message": switch (yv()) { case wu: return 1; case Ap: return 4; case zo: case gv: return 16; case Lp: return 536870912; default: return 16 }default: return 16 } } var Kt = null, Tu = null, go = null; function jp() { if (go) return go; var e, t = Tu, n = t.length, r, i = "value" in Kt ? Kt.value : Kt.textContent, o = i.length; for (e = 0; e < n && t[e] === i[e]; e++); var s = n - e; for (r = 1; r <= s && t[n - r] === i[o - r]; r++); return go = i.slice(e, 1 < r ? 1 - r : void 0) } function vo(e) { var t = e.keyCode; return "charCode" in e ? (e = e.charCode, e === 0 && t === 13 && (e = 13)) : e = t, e === 10 && (e = 13), 32 <= e || e === 13 ? e : 0 } function qi() { return !0 } function ff() { return !1 } function He(e) { function t(n, r, i, o, s) { this._reactName = n, this._targetInst = i, this.type = r, this.nativeEvent = o, this.target = s, this.currentTarget = null; for (var a in e) e.hasOwnProperty(a) && (n = e[a], this[a] = n ? n(o) : o[a]); return this.isDefaultPrevented = (o.defaultPrevented != null ? o.defaultPrevented : o.returnValue === !1) ? qi : ff, this.isPropagationStopped = ff, this } return ee(t.prototype, { preventDefault: function () { this.defaultPrevented = !0; var n = this.nativeEvent; n && (n.preventDefault ? n.preventDefault() : typeof n.returnValue != "unknown" && (n.returnValue = !1), this.isDefaultPrevented = qi) }, stopPropagation: function () { var n = this.nativeEvent; n && (n.stopPropagation ? n.stopPropagation() : typeof n.cancelBubble != "unknown" && (n.cancelBubble = !0), this.isPropagationStopped = qi) }, persist: function () { }, isPersistent: qi }), t } var vr = { eventPhase: 0, bubbles: 0, cancelable: 0, timeStamp: function (e) { return e.timeStamp || Date.now() }, defaultPrevented: 0, isTrusted: 0 }, Cu = He(vr), Di = ee({}, vr, { view: 0, detail: 0 }), Dv = He(Di), Qs, qs, Or, vs = ee({}, Di, { screenX: 0, screenY: 0, clientX: 0, clientY: 0, pageX: 0, pageY: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, getModifierState: Pu, button: 0, buttons: 0, relatedTarget: function (e) { return e.relatedTarget === void 0 ? e.fromElement === e.srcElement ? e.toElement : e.fromElement : e.relatedTarget }, movementX: function (e) { return "movementX" in e ? e.movementX : (e !== Or && (Or && e.type === "mousemove" ? (Qs = e.screenX - Or.screenX, qs = e.screenY - Or.screenY) : qs = Qs = 0, Or = e), Qs) }, movementY: function (e) { return "movementY" in e ? e.movementY : qs } }), df = He(vs), _v = ee({}, vs, { dataTransfer: 0 }), Mv = He(_v), Ov = ee({}, Di, { relatedTarget: 0 }), Js = He(Ov), Nv = ee({}, vr, { animationName: 0, elapsedTime: 0, pseudoElement: 0 }), Vv = He(Nv), Iv = ee({}, vr, { clipboardData: function (e) { return "clipboardData" in e ? e.clipboardData : window.clipboardData } }), Fv = He(Iv), jv = ee({}, vr, { data: 0 }), hf = He(jv), Bv = { Esc: "Escape", Spacebar: " ", Left: "ArrowLeft", Up: "ArrowUp", Right: "ArrowRight", Down: "ArrowDown", Del: "Delete", Win: "OS", Menu: "ContextMenu", Apps: "ContextMenu", Scroll: "ScrollLock", MozPrintableKey: "Unidentified" }, zv = { 8: "Backspace", 9: "Tab", 12: "Clear", 13: "Enter", 16: "Shift", 17: "Control", 18: "Alt", 19: "Pause", 20: "CapsLock", 27: "Escape", 32: " ", 33: "PageUp", 34: "PageDown", 35: "End", 36: "Home", 37: "ArrowLeft", 38: "ArrowUp", 39: "ArrowRight", 40: "ArrowDown", 45: "Insert", 46: "Delete", 112: "F1", 113: "F2", 114: "F3", 115: "F4", 116: "F5", 117: "F6", 118: "F7", 119: "F8", 120: "F9", 121: "F10", 122: "F11", 123: "F12", 144: "NumLock", 145: "ScrollLock", 224: "Meta" }, Uv = { Alt: "altKey", Control: "ctrlKey", Meta: "metaKey", Shift: "shiftKey" }; function $v(e) { var t = this.nativeEvent; return t.getModifierState ? t.getModifierState(e) : (e = Uv[e]) ? !!t[e] : !1 } function Pu() { return $v } var bv = ee({}, Di, { key: function (e) { if (e.key) { var t = Bv[e.key] || e.key; if (t !== "Unidentified") return t } return e.type === "keypress" ? (e = vo(e), e === 13 ? "Enter" : String.fromCharCode(e)) : e.type === "keydown" || e.type === "keyup" ? zv[e.keyCode] || "Unidentified" : "" }, code: 0, location: 0, ctrlKey: 0, shiftKey: 0, altKey: 0, metaKey: 0, repeat: 0, locale: 0, getModifierState: Pu, charCode: function (e) { return e.type === "keypress" ? vo(e) : 0 }, keyCode: function (e) { return e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 }, which: function (e) { return e.type === "keypress" ? vo(e) : e.type === "keydown" || e.type === "keyup" ? e.keyCode : 0 } }), Wv = He(bv), Hv = ee({}, vs, { pointerId: 0, width: 0, height: 0, pressure: 0, tangentialPressure: 0, tiltX: 0, tiltY: 0, twist: 0, pointerType: 0, isPrimary: 0 }), pf = He(Hv), Kv = ee({}, Di, { touches: 0, targetTouches: 0, changedTouches: 0, altKey: 0, metaKey: 0, ctrlKey: 0, shiftKey: 0, getModifierState: Pu }), Gv = He(Kv), Xv = ee({}, vr, { propertyName: 0, elapsedTime: 0, pseudoElement: 0 }), Yv = He(Xv), Qv = ee({}, vs, { deltaX: function (e) { return "deltaX" in e ? e.deltaX : "wheelDeltaX" in e ? -e.wheelDeltaX : 0 }, deltaY: function (e) { return "deltaY" in e ? e.deltaY : "wheelDeltaY" in e ? -e.wheelDeltaY : "wheelDelta" in e ? -e.wheelDelta : 0 }, deltaZ: 0, deltaMode: 0 }), qv = He(Qv), Jv = [9, 13, 27, 32], ku = Mt && "CompositionEvent" in window, Xr = null; Mt && "documentMode" in document && (Xr = document.documentMode); var Zv = Mt && "TextEvent" in window && !Xr, Bp = Mt && (!ku || Xr && 8 < Xr && 11 >= Xr), mf = String.fromCharCode(32), yf = !1; function zp(e, t) { switch (e) { case "keyup": return Jv.indexOf(t.keyCode) !== -1; case "keydown": return t.keyCode !== 229; case "keypress": case "mousedown": case "focusout": return !0; default: return !1 } } function Up(e) { return e = e.detail, typeof e == "object" && "data" in e ? e.data : null } var zn = !1; function e1(e, t) { switch (e) { case "compositionend": return Up(t); case "keypress": return t.which !== 32 ? null : (yf = !0, mf); case "textInput": return e = t.data, e === mf && yf ? null : e; default: return null } } function t1(e, t) { if (zn) return e === "compositionend" || !ku && zp(e, t) ? (e = jp(), go = Tu = Kt = null, zn = !1, e) : null; switch (e) { case "paste": return null; case "keypress": if (!(t.ctrlKey || t.altKey || t.metaKey) || t.ctrlKey && t.altKey) { if (t.char && 1 < t.char.length) return t.char; if (t.which) return String.fromCharCode(t.which) } return null; case "compositionend": return Bp && t.locale !== "ko" ? null : t.data; default: return null } } var n1 = { color: !0, date: !0, datetime: !0, "datetime-local": !0, email: !0, month: !0, number: !0, password: !0, range: !0, search: !0, tel: !0, text: !0, time: !0, url: !0, week: !0 }; function gf(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t === "input" ? !!n1[e.type] : t === "textarea" } function $p(e, t, n, r) { wp(r), t = Wo(t, "onChange"), 0 < t.length && (n = new Cu("onChange", "change", null, n, r), e.push({ event: n, listeners: t })) } var Yr = null, fi = null; function r1(e) { Zp(e, 0) } function ws(e) { var t = bn(e); if (dp(t)) return e } function i1(e, t) { if (e === "change") return t } var bp = !1; if (Mt) { var Zs; if (Mt) { var ea = "oninput" in document; if (!ea) { var vf = document.createElement("div"); vf.setAttribute("oninput", "return;"), ea = typeof vf.oninput == "function" } Zs = ea } else Zs = !1; bp = Zs && (!document.documentMode || 9 < document.documentMode) } function wf() { Yr && (Yr.detachEvent("onpropertychange", Wp), fi = Yr = null) } function Wp(e) { if (e.propertyName === "value" && ws(fi)) { var t = []; $p(t, fi, e, vu(e)), Tp(r1, t) } } function o1(e, t, n) { e === "focusin" ? (wf(), Yr = t, fi = n, Yr.attachEvent("onpropertychange", Wp)) : e === "focusout" && wf() } function s1(e) { if (e === "selectionchange" || e === "keyup" || e === "keydown") return ws(fi) } function a1(e, t) { if (e === "click") return ws(t) } function l1(e, t) { if (e === "input" || e === "change") return ws(t) } function u1(e, t) { return e === t && (e !== 0 || 1 / e === 1 / t) || e !== e && t !== t } var ht = typeof Object.is == "function" ? Object.is : u1; function di(e, t) { if (ht(e, t)) return !0; if (typeof e != "object" || e === null || typeof t != "object" || t === null) return !1; var n = Object.keys(e), r = Object.keys(t); if (n.length !== r.length) return !1; for (r = 0; r < n.length; r++) { var i = n[r]; if (!za.call(t, i) || !ht(e[i], t[i])) return !1 } return !0 } function Sf(e) { for (; e && e.firstChild;)e = e.firstChild; return e } function xf(e, t) { var n = Sf(e); e = 0; for (var r; n;) { if (n.nodeType === 3) { if (r = e + n.textContent.length, e <= t && r >= t) return { node: n, offset: t - e }; e = r } e: { for (; n;) { if (n.nextSibling) { n = n.nextSibling; break e } n = n.parentNode } n = void 0 } n = Sf(n) } } function Hp(e, t) { return e && t ? e === t ? !0 : e && e.nodeType === 3 ? !1 : t && t.nodeType === 3 ? Hp(e, t.parentNode) : "contains" in e ? e.contains(t) : e.compareDocumentPosition ? !!(e.compareDocumentPosition(t) & 16) : !1 : !1 } function Kp() { for (var e = window, t = Fo(); t instanceof e.HTMLIFrameElement;) { try { var n = typeof t.contentWindow.location.href == "string" } catch { n = !1 } if (n) e = t.contentWindow; else break; t = Fo(e.document) } return t } function Ru(e) { var t = e && e.nodeName && e.nodeName.toLowerCase(); return t && (t === "input" && (e.type === "text" || e.type === "search" || e.type === "tel" || e.type === "url" || e.type === "password") || t === "textarea" || e.contentEditable === "true") } function c1(e) { var t = Kp(), n = e.focusedElem, r = e.selectionRange; if (t !== n && n && n.ownerDocument && Hp(n.ownerDocument.documentElement, n)) { if (r !== null && Ru(n)) { if (t = r.start, e = r.end, e === void 0 && (e = t), "selectionStart" in n) n.selectionStart = t, n.selectionEnd = Math.min(e, n.value.length); else if (e = (t = n.ownerDocument || document) && t.defaultView || window, e.getSelection) { e = e.getSelection(); var i = n.textContent.length, o = Math.min(r.start, i); r = r.end === void 0 ? o : Math.min(r.end, i), !e.extend && o > r && (i = r, r = o, o = i), i = xf(n, o); var s = xf(n, r); i && s && (e.rangeCount !== 1 || e.anchorNode !== i.node || e.anchorOffset !== i.offset || e.focusNode !== s.node || e.focusOffset !== s.offset) && (t = t.createRange(), t.setStart(i.node, i.offset), e.removeAllRanges(), o > r ? (e.addRange(t), e.extend(s.node, s.offset)) : (t.setEnd(s.node, s.offset), e.addRange(t))) } } for (t = [], e = n; e = e.parentNode;)e.nodeType === 1 && t.push({ element: e, left: e.scrollLeft, top: e.scrollTop }); for (typeof n.focus == "function" && n.focus(), n = 0; n < t.length; n++)e = t[n], e.element.scrollLeft = e.left, e.element.scrollTop = e.top } } var f1 = Mt && "documentMode" in document && 11 >= document.documentMode, Un = null, ol = null, Qr = null, sl = !1; function Ef(e, t, n) { var r = n.window === n ? n.document : n.nodeType === 9 ? n : n.ownerDocument; sl || Un == null || Un !== Fo(r) || (r = Un, "selectionStart" in r && Ru(r) ? r = { start: r.selectionStart, end: r.selectionEnd } : (r = (r.ownerDocument && r.ownerDocument.defaultView || window).getSelection(), r = { anchorNode: r.anchorNode, anchorOffset: r.anchorOffset, focusNode: r.focusNode, focusOffset: r.focusOffset }), Qr && di(Qr, r) || (Qr = r, r = Wo(ol, "onSelect"), 0 < r.length && (t = new Cu("onSelect", "select", null, t, n), e.push({ event: t, listeners: r }), t.target = Un))) } function Ji(e, t) { var n = {}; return n[e.toLowerCase()] = t.toLowerCase(), n["Webkit" + e] = "webkit" + t, n["Moz" + e] = "moz" + t, n } var $n = { animationend: Ji("Animation", "AnimationEnd"), animationiteration: Ji("Animation", "AnimationIteration"), animationstart: Ji("Animation", "AnimationStart"), transitionend: Ji("Transition", "TransitionEnd") }, ta = {}, Gp = {}; Mt && (Gp = document.createElement("div").style, "AnimationEvent" in window || (delete $n.animationend.animation, delete $n.animationiteration.animation, delete $n.animationstart.animation), "TransitionEvent" in window || delete $n.transitionend.transition); function Ss(e) { if (ta[e]) return ta[e]; if (!$n[e]) return e; var t = $n[e], n; for (n in t) if (t.hasOwnProperty(n) && n in Gp) return ta[e] = t[n]; return e } var Xp = Ss("animationend"), Yp = Ss("animationiteration"), Qp = Ss("animationstart"), qp = Ss("transitionend"), Jp = new Map, Tf = "abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" "); function ln(e, t) { Jp.set(e, t), Nn(t, [e]) } for (var na = 0; na < Tf.length; na++) { var ra = Tf[na], d1 = ra.toLowerCase(), h1 = ra[0].toUpperCase() + ra.slice(1); ln(d1, "on" + h1) } ln(Xp, "onAnimationEnd"); ln(Yp, "onAnimationIteration"); ln(Qp, "onAnimationStart"); ln("dblclick", "onDoubleClick"); ln("focusin", "onFocus"); ln("focusout", "onBlur"); ln(qp, "onTransitionEnd"); ar("onMouseEnter", ["mouseout", "mouseover"]); ar("onMouseLeave", ["mouseout", "mouseover"]); ar("onPointerEnter", ["pointerout", "pointerover"]); ar("onPointerLeave", ["pointerout", "pointerover"]); Nn("onChange", "change click focusin focusout input keydown keyup selectionchange".split(" ")); Nn("onSelect", "focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")); Nn("onBeforeInput", ["compositionend", "keypress", "textInput", "paste"]); Nn("onCompositionEnd", "compositionend focusout keydown keypress keyup mousedown".split(" ")); Nn("onCompositionStart", "compositionstart focusout keydown keypress keyup mousedown".split(" ")); Nn("onCompositionUpdate", "compositionupdate focusout keydown keypress keyup mousedown".split(" ")); var br = "abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "), p1 = new Set("cancel close invalid load scroll toggle".split(" ").concat(br)); function Cf(e, t, n) { var r = e.type || "unknown-event"; e.currentTarget = n, dv(r, t, void 0, e), e.currentTarget = null } function Zp(e, t) { t = (t & 4) !== 0; for (var n = 0; n < e.length; n++) { var r = e[n], i = r.event; r = r.listeners; e: { var o = void 0; if (t) for (var s = r.length - 1; 0 <= s; s--) { var a = r[s], l = a.instance, u = a.currentTarget; if (a = a.listener, l !== o && i.isPropagationStopped()) break e; Cf(i, a, u), o = l } else for (s = 0; s < r.length; s++) { if (a = r[s], l = a.instance, u = a.currentTarget, a = a.listener, l !== o && i.isPropagationStopped()) break e; Cf(i, a, u), o = l } } } if (Bo) throw e = tl, Bo = !1, tl = null, e } function b(e, t) { var n = t[fl]; n === void 0 && (n = t[fl] = new Set); var r = e + "__bubble"; n.has(r) || (em(t, e, 2, !1), n.add(r)) } function ia(e, t, n) { var r = 0; t && (r |= 4), em(n, e, r, t) } var Zi = "_reactListening" + Math.random().toString(36).slice(2); function hi(e) { if (!e[Zi]) { e[Zi] = !0, ap.forEach(function (n) { n !== "selectionchange" && (p1.has(n) || ia(n, !1, e), ia(n, !0, e)) }); var t = e.nodeType === 9 ? e : e.ownerDocument; t === null || t[Zi] || (t[Zi] = !0, ia("selectionchange", !1, t)) } } function em(e, t, n, r) { switch (Fp(t)) { case 1: var i = Av; break; case 4: i = Lv; break; default: i = Eu }n = i.bind(null, t, n, e), i = void 0, !el || t !== "touchstart" && t !== "touchmove" && t !== "wheel" || (i = !0), r ? i !== void 0 ? e.addEventListener(t, n, { capture: !0, passive: i }) : e.addEventListener(t, n, !0) : i !== void 0 ? e.addEventListener(t, n, { passive: i }) : e.addEventListener(t, n, !1) } function oa(e, t, n, r, i) { var o = r; if (!(t & 1) && !(t & 2) && r !== null) e: for (; ;) { if (r === null) return; var s = r.tag; if (s === 3 || s === 4) { var a = r.stateNode.containerInfo; if (a === i || a.nodeType === 8 && a.parentNode === i) break; if (s === 4) for (s = r.return; s !== null;) { var l = s.tag; if ((l === 3 || l === 4) && (l = s.stateNode.containerInfo, l === i || l.nodeType === 8 && l.parentNode === i)) return; s = s.return } for (; a !== null;) { if (s = vn(a), s === null) return; if (l = s.tag, l === 5 || l === 6) { r = o = s; continue e } a = a.parentNode } } r = r.return } Tp(function () { var u = o, c = vu(n), f = []; e: { var d = Jp.get(e); if (d !== void 0) { var g = Cu, y = e; switch (e) { case "keypress": if (vo(n) === 0) break e; case "keydown": case "keyup": g = Wv; break; case "focusin": y = "focus", g = Js; break; case "focusout": y = "blur", g = Js; break; case "beforeblur": case "afterblur": g = Js; break; case "click": if (n.button === 2) break e; case "auxclick": case "dblclick": case "mousedown": case "mousemove": case "mouseup": case "mouseout": case "mouseover": case "contextmenu": g = df; break; case "drag": case "dragend": case "dragenter": case "dragexit": case "dragleave": case "dragover": case "dragstart": case "drop": g = Mv; break; case "touchcancel": case "touchend": case "touchmove": case "touchstart": g = Gv; break; case Xp: case Yp: case Qp: g = Vv; break; case qp: g = Yv; break; case "scroll": g = Dv; break; case "wheel": g = qv; break; case "copy": case "cut": case "paste": g = Fv; break; case "gotpointercapture": case "lostpointercapture": case "pointercancel": case "pointerdown": case "pointermove": case "pointerout": case "pointerover": case "pointerup": g = pf }var v = (t & 4) !== 0, S = !v && e === "scroll", p = v ? d !== null ? d + "Capture" : null : d; v = []; for (var h = u, m; h !== null;) { m = h; var x = m.stateNode; if (m.tag === 5 && x !== null && (m = x, p !== null && (x = ai(h, p), x != null && v.push(pi(h, x, m)))), S) break; h = h.return } 0 < v.length && (d = new g(d, y, null, n, c), f.push({ event: d, listeners: v })) } } if (!(t & 7)) { e: { if (d = e === "mouseover" || e === "pointerover", g = e === "mouseout" || e === "pointerout", d && n !== Ja && (y = n.relatedTarget || n.fromElement) && (vn(y) || y[Ot])) break e; if ((g || d) && (d = c.window === c ? c : (d = c.ownerDocument) ? d.defaultView || d.parentWindow : window, g ? (y = n.relatedTarget || n.toElement, g = u, y = y ? vn(y) : null, y !== null && (S = Vn(y), y !== S || y.tag !== 5 && y.tag !== 6) && (y = null)) : (g = null, y = u), g !== y)) { if (v = df, x = "onMouseLeave", p = "onMouseEnter", h = "mouse", (e === "pointerout" || e === "pointerover") && (v = pf, x = "onPointerLeave", p = "onPointerEnter", h = "pointer"), S = g == null ? d : bn(g), m = y == null ? d : bn(y), d = new v(x, h + "leave", g, n, c), d.target = S, d.relatedTarget = m, x = null, vn(c) === u && (v = new v(p, h + "enter", y, n, c), v.target = m, v.relatedTarget = S, x = v), S = x, g && y) t: { for (v = g, p = y, h = 0, m = v; m; m = Fn(m))h++; for (m = 0, x = p; x; x = Fn(x))m++; for (; 0 < h - m;)v = Fn(v), h--; for (; 0 < m - h;)p = Fn(p), m--; for (; h--;) { if (v === p || p !== null && v === p.alternate) break t; v = Fn(v), p = Fn(p) } v = null } else v = null; g !== null && Pf(f, d, g, v, !1), y !== null && S !== null && Pf(f, S, y, v, !0) } } e: { if (d = u ? bn(u) : window, g = d.nodeName && d.nodeName.toLowerCase(), g === "select" || g === "input" && d.type === "file") var E = i1; else if (gf(d)) if (bp) E = l1; else { E = s1; var k = o1 } else (g = d.nodeName) && g.toLowerCase() === "input" && (d.type === "checkbox" || d.type === "radio") && (E = a1); if (E && (E = E(e, u))) { $p(f, E, n, c); break e } k && k(e, d, u), e === "focusout" && (k = d._wrapperState) && k.controlled && d.type === "number" && Ga(d, "number", d.value) } switch (k = u ? bn(u) : window, e) { case "focusin": (gf(k) || k.contentEditable === "true") && (Un = k, ol = u, Qr = null); break; case "focusout": Qr = ol = Un = null; break; case "mousedown": sl = !0; break; case "contextmenu": case "mouseup": case "dragend": sl = !1, Ef(f, n, c); break; case "selectionchange": if (f1) break; case "keydown": case "keyup": Ef(f, n, c) }var P; if (ku) e: { switch (e) { case "compositionstart": var C = "onCompositionStart"; break e; case "compositionend": C = "onCompositionEnd"; break e; case "compositionupdate": C = "onCompositionUpdate"; break e }C = void 0 } else zn ? zp(e, n) && (C = "onCompositionEnd") : e === "keydown" && n.keyCode === 229 && (C = "onCompositionStart"); C && (Bp && n.locale !== "ko" && (zn || C !== "onCompositionStart" ? C === "onCompositionEnd" && zn && (P = jp()) : (Kt = c, Tu = "value" in Kt ? Kt.value : Kt.textContent, zn = !0)), k = Wo(u, C), 0 < k.length && (C = new hf(C, e, null, n, c), f.push({ event: C, listeners: k }), P ? C.data = P : (P = Up(n), P !== null && (C.data = P)))), (P = Zv ? e1(e, n) : t1(e, n)) && (u = Wo(u, "onBeforeInput"), 0 < u.length && (c = new hf("onBeforeInput", "beforeinput", null, n, c), f.push({ event: c, listeners: u }), c.data = P)) } Zp(f, t) }) } function pi(e, t, n) { return { instance: e, listener: t, currentTarget: n } } function Wo(e, t) { for (var n = t + "Capture", r = []; e !== null;) { var i = e, o = i.stateNode; i.tag === 5 && o !== null && (i = o, o = ai(e, n), o != null && r.unshift(pi(e, o, i)), o = ai(e, t), o != null && r.push(pi(e, o, i))), e = e.return } return r } function Fn(e) { if (e === null) return null; do e = e.return; while (e && e.tag !== 5); return e || null } function Pf(e, t, n, r, i) { for (var o = t._reactName, s = []; n !== null && n !== r;) { var a = n, l = a.alternate, u = a.stateNode; if (l !== null && l === r) break; a.tag === 5 && u !== null && (a = u, i ? (l = ai(n, o), l != null && s.unshift(pi(n, l, a))) : i || (l = ai(n, o), l != null && s.push(pi(n, l, a)))), n = n.return } s.length !== 0 && e.push({ event: t, listeners: s }) } var m1 = /\r\n?/g, y1 = /\u0000|\uFFFD/g; function kf(e) {
  return (typeof e == "string" ? e : "" + e).replace(m1, `
`).replace(y1, "")
} function eo(e, t, n) { if (t = kf(t), kf(e) !== t && n) throw Error(A(425)) } function Ho() { } var al = null, ll = null; function ul(e, t) { return e === "textarea" || e === "noscript" || typeof t.children == "string" || typeof t.children == "number" || typeof t.dangerouslySetInnerHTML == "object" && t.dangerouslySetInnerHTML !== null && t.dangerouslySetInnerHTML.__html != null } var cl = typeof setTimeout == "function" ? setTimeout : void 0, g1 = typeof clearTimeout == "function" ? clearTimeout : void 0, Rf = typeof Promise == "function" ? Promise : void 0, v1 = typeof queueMicrotask == "function" ? queueMicrotask : typeof Rf < "u" ? function (e) { return Rf.resolve(null).then(e).catch(w1) } : cl; function w1(e) { setTimeout(function () { throw e }) } function sa(e, t) { var n = t, r = 0; do { var i = n.nextSibling; if (e.removeChild(n), i && i.nodeType === 8) if (n = i.data, n === "/$") { if (r === 0) { e.removeChild(i), ci(t); return } r-- } else n !== "$" && n !== "$?" && n !== "$!" || r++; n = i } while (n); ci(t) } function Jt(e) { for (; e != null; e = e.nextSibling) { var t = e.nodeType; if (t === 1 || t === 3) break; if (t === 8) { if (t = e.data, t === "$" || t === "$!" || t === "$?") break; if (t === "/$") return null } } return e } function Af(e) { e = e.previousSibling; for (var t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "$" || n === "$!" || n === "$?") { if (t === 0) return e; t-- } else n === "/$" && t++ } e = e.previousSibling } return null } var wr = Math.random().toString(36).slice(2), wt = "__reactFiber$" + wr, mi = "__reactProps$" + wr, Ot = "__reactContainer$" + wr, fl = "__reactEvents$" + wr, S1 = "__reactListeners$" + wr, x1 = "__reactHandles$" + wr; function vn(e) { var t = e[wt]; if (t) return t; for (var n = e.parentNode; n;) { if (t = n[Ot] || n[wt]) { if (n = t.alternate, t.child !== null || n !== null && n.child !== null) for (e = Af(e); e !== null;) { if (n = e[wt]) return n; e = Af(e) } return t } e = n, n = e.parentNode } return null } function _i(e) { return e = e[wt] || e[Ot], !e || e.tag !== 5 && e.tag !== 6 && e.tag !== 13 && e.tag !== 3 ? null : e } function bn(e) { if (e.tag === 5 || e.tag === 6) return e.stateNode; throw Error(A(33)) } function xs(e) { return e[mi] || null } var dl = [], Wn = -1; function un(e) { return { current: e } } function W(e) { 0 > Wn || (e.current = dl[Wn], dl[Wn] = null, Wn--) } function U(e, t) { Wn++, dl[Wn] = e.current, e.current = t } var on = {}, Ee = un(on), Oe = un(!1), Rn = on; function lr(e, t) { var n = e.type.contextTypes; if (!n) return on; var r = e.stateNode; if (r && r.__reactInternalMemoizedUnmaskedChildContext === t) return r.__reactInternalMemoizedMaskedChildContext; var i = {}, o; for (o in n) i[o] = t[o]; return r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = t, e.__reactInternalMemoizedMaskedChildContext = i), i } function Ne(e) { return e = e.childContextTypes, e != null } function Ko() { W(Oe), W(Ee) } function Lf(e, t, n) { if (Ee.current !== on) throw Error(A(168)); U(Ee, t), U(Oe, n) } function tm(e, t, n) { var r = e.stateNode; if (t = t.childContextTypes, typeof r.getChildContext != "function") return n; r = r.getChildContext(); for (var i in r) if (!(i in t)) throw Error(A(108, ov(e) || "Unknown", i)); return ee({}, n, r) } function Go(e) { return e = (e = e.stateNode) && e.__reactInternalMemoizedMergedChildContext || on, Rn = Ee.current, U(Ee, e), U(Oe, Oe.current), !0 } function Df(e, t, n) { var r = e.stateNode; if (!r) throw Error(A(169)); n ? (e = tm(e, t, Rn), r.__reactInternalMemoizedMergedChildContext = e, W(Oe), W(Ee), U(Ee, e)) : W(Oe), U(Oe, n) } var Rt = null, Es = !1, aa = !1; function nm(e) { Rt === null ? Rt = [e] : Rt.push(e) } function E1(e) { Es = !0, nm(e) } function cn() { if (!aa && Rt !== null) { aa = !0; var e = 0, t = z; try { var n = Rt; for (z = 1; e < n.length; e++) { var r = n[e]; do r = r(!0); while (r !== null) } Rt = null, Es = !1 } catch (i) { throw Rt !== null && (Rt = Rt.slice(e + 1)), Rp(wu, cn), i } finally { z = t, aa = !1 } } return null } var Hn = [], Kn = 0, Xo = null, Yo = 0, Ye = [], Qe = 0, An = null, At = 1, Lt = ""; function mn(e, t) { Hn[Kn++] = Yo, Hn[Kn++] = Xo, Xo = e, Yo = t } function rm(e, t, n) { Ye[Qe++] = At, Ye[Qe++] = Lt, Ye[Qe++] = An, An = e; var r = At; e = Lt; var i = 32 - ct(r) - 1; r &= ~(1 << i), n += 1; var o = 32 - ct(t) + i; if (30 < o) { var s = i - i % 5; o = (r & (1 << s) - 1).toString(32), r >>= s, i -= s, At = 1 << 32 - ct(t) + i | n << i | r, Lt = o + e } else At = 1 << o | n << i | r, Lt = e } function Au(e) { e.return !== null && (mn(e, 1), rm(e, 1, 0)) } function Lu(e) { for (; e === Xo;)Xo = Hn[--Kn], Hn[Kn] = null, Yo = Hn[--Kn], Hn[Kn] = null; for (; e === An;)An = Ye[--Qe], Ye[Qe] = null, Lt = Ye[--Qe], Ye[Qe] = null, At = Ye[--Qe], Ye[Qe] = null } var Ue = null, ze = null, X = !1, ut = null; function im(e, t) { var n = qe(5, null, null, 0); n.elementType = "DELETED", n.stateNode = t, n.return = e, t = e.deletions, t === null ? (e.deletions = [n], e.flags |= 16) : t.push(n) } function _f(e, t) { switch (e.tag) { case 5: var n = e.type; return t = t.nodeType !== 1 || n.toLowerCase() !== t.nodeName.toLowerCase() ? null : t, t !== null ? (e.stateNode = t, Ue = e, ze = Jt(t.firstChild), !0) : !1; case 6: return t = e.pendingProps === "" || t.nodeType !== 3 ? null : t, t !== null ? (e.stateNode = t, Ue = e, ze = null, !0) : !1; case 13: return t = t.nodeType !== 8 ? null : t, t !== null ? (n = An !== null ? { id: At, overflow: Lt } : null, e.memoizedState = { dehydrated: t, treeContext: n, retryLane: 1073741824 }, n = qe(18, null, null, 0), n.stateNode = t, n.return = e, e.child = n, Ue = e, ze = null, !0) : !1; default: return !1 } } function hl(e) { return (e.mode & 1) !== 0 && (e.flags & 128) === 0 } function pl(e) { if (X) { var t = ze; if (t) { var n = t; if (!_f(e, t)) { if (hl(e)) throw Error(A(418)); t = Jt(n.nextSibling); var r = Ue; t && _f(e, t) ? im(r, n) : (e.flags = e.flags & -4097 | 2, X = !1, Ue = e) } } else { if (hl(e)) throw Error(A(418)); e.flags = e.flags & -4097 | 2, X = !1, Ue = e } } } function Mf(e) { for (e = e.return; e !== null && e.tag !== 5 && e.tag !== 3 && e.tag !== 13;)e = e.return; Ue = e } function to(e) { if (e !== Ue) return !1; if (!X) return Mf(e), X = !0, !1; var t; if ((t = e.tag !== 3) && !(t = e.tag !== 5) && (t = e.type, t = t !== "head" && t !== "body" && !ul(e.type, e.memoizedProps)), t && (t = ze)) { if (hl(e)) throw om(), Error(A(418)); for (; t;)im(e, t), t = Jt(t.nextSibling) } if (Mf(e), e.tag === 13) { if (e = e.memoizedState, e = e !== null ? e.dehydrated : null, !e) throw Error(A(317)); e: { for (e = e.nextSibling, t = 0; e;) { if (e.nodeType === 8) { var n = e.data; if (n === "/$") { if (t === 0) { ze = Jt(e.nextSibling); break e } t-- } else n !== "$" && n !== "$!" && n !== "$?" || t++ } e = e.nextSibling } ze = null } } else ze = Ue ? Jt(e.stateNode.nextSibling) : null; return !0 } function om() { for (var e = ze; e;)e = Jt(e.nextSibling) } function ur() { ze = Ue = null, X = !1 } function Du(e) { ut === null ? ut = [e] : ut.push(e) } var T1 = jt.ReactCurrentBatchConfig; function Nr(e, t, n) { if (e = n.ref, e !== null && typeof e != "function" && typeof e != "object") { if (n._owner) { if (n = n._owner, n) { if (n.tag !== 1) throw Error(A(309)); var r = n.stateNode } if (!r) throw Error(A(147, e)); var i = r, o = "" + e; return t !== null && t.ref !== null && typeof t.ref == "function" && t.ref._stringRef === o ? t.ref : (t = function (s) { var a = i.refs; s === null ? delete a[o] : a[o] = s }, t._stringRef = o, t) } if (typeof e != "string") throw Error(A(284)); if (!n._owner) throw Error(A(290, e)) } return e } function no(e, t) { throw e = Object.prototype.toString.call(t), Error(A(31, e === "[object Object]" ? "object with keys {" + Object.keys(t).join(", ") + "}" : e)) } function Of(e) { var t = e._init; return t(e._payload) } function sm(e) { function t(p, h) { if (e) { var m = p.deletions; m === null ? (p.deletions = [h], p.flags |= 16) : m.push(h) } } function n(p, h) { if (!e) return null; for (; h !== null;)t(p, h), h = h.sibling; return null } function r(p, h) { for (p = new Map; h !== null;)h.key !== null ? p.set(h.key, h) : p.set(h.index, h), h = h.sibling; return p } function i(p, h) { return p = nn(p, h), p.index = 0, p.sibling = null, p } function o(p, h, m) { return p.index = m, e ? (m = p.alternate, m !== null ? (m = m.index, m < h ? (p.flags |= 2, h) : m) : (p.flags |= 2, h)) : (p.flags |= 1048576, h) } function s(p) { return e && p.alternate === null && (p.flags |= 2), p } function a(p, h, m, x) { return h === null || h.tag !== 6 ? (h = pa(m, p.mode, x), h.return = p, h) : (h = i(h, m), h.return = p, h) } function l(p, h, m, x) { var E = m.type; return E === Bn ? c(p, h, m.props.children, x, m.key) : h !== null && (h.elementType === E || typeof E == "object" && E !== null && E.$$typeof === $t && Of(E) === h.type) ? (x = i(h, m.props), x.ref = Nr(p, h, m), x.return = p, x) : (x = Po(m.type, m.key, m.props, null, p.mode, x), x.ref = Nr(p, h, m), x.return = p, x) } function u(p, h, m, x) { return h === null || h.tag !== 4 || h.stateNode.containerInfo !== m.containerInfo || h.stateNode.implementation !== m.implementation ? (h = ma(m, p.mode, x), h.return = p, h) : (h = i(h, m.children || []), h.return = p, h) } function c(p, h, m, x, E) { return h === null || h.tag !== 7 ? (h = Pn(m, p.mode, x, E), h.return = p, h) : (h = i(h, m), h.return = p, h) } function f(p, h, m) { if (typeof h == "string" && h !== "" || typeof h == "number") return h = pa("" + h, p.mode, m), h.return = p, h; if (typeof h == "object" && h !== null) { switch (h.$$typeof) { case Hi: return m = Po(h.type, h.key, h.props, null, p.mode, m), m.ref = Nr(p, null, h), m.return = p, m; case jn: return h = ma(h, p.mode, m), h.return = p, h; case $t: var x = h._init; return f(p, x(h._payload), m) }if (Ur(h) || Lr(h)) return h = Pn(h, p.mode, m, null), h.return = p, h; no(p, h) } return null } function d(p, h, m, x) { var E = h !== null ? h.key : null; if (typeof m == "string" && m !== "" || typeof m == "number") return E !== null ? null : a(p, h, "" + m, x); if (typeof m == "object" && m !== null) { switch (m.$$typeof) { case Hi: return m.key === E ? l(p, h, m, x) : null; case jn: return m.key === E ? u(p, h, m, x) : null; case $t: return E = m._init, d(p, h, E(m._payload), x) }if (Ur(m) || Lr(m)) return E !== null ? null : c(p, h, m, x, null); no(p, m) } return null } function g(p, h, m, x, E) { if (typeof x == "string" && x !== "" || typeof x == "number") return p = p.get(m) || null, a(h, p, "" + x, E); if (typeof x == "object" && x !== null) { switch (x.$$typeof) { case Hi: return p = p.get(x.key === null ? m : x.key) || null, l(h, p, x, E); case jn: return p = p.get(x.key === null ? m : x.key) || null, u(h, p, x, E); case $t: var k = x._init; return g(p, h, m, k(x._payload), E) }if (Ur(x) || Lr(x)) return p = p.get(m) || null, c(h, p, x, E, null); no(h, x) } return null } function y(p, h, m, x) { for (var E = null, k = null, P = h, C = h = 0, O = null; P !== null && C < m.length; C++) { P.index > C ? (O = P, P = null) : O = P.sibling; var M = d(p, P, m[C], x); if (M === null) { P === null && (P = O); break } e && P && M.alternate === null && t(p, P), h = o(M, h, C), k === null ? E = M : k.sibling = M, k = M, P = O } if (C === m.length) return n(p, P), X && mn(p, C), E; if (P === null) { for (; C < m.length; C++)P = f(p, m[C], x), P !== null && (h = o(P, h, C), k === null ? E = P : k.sibling = P, k = P); return X && mn(p, C), E } for (P = r(p, P); C < m.length; C++)O = g(P, p, C, m[C], x), O !== null && (e && O.alternate !== null && P.delete(O.key === null ? C : O.key), h = o(O, h, C), k === null ? E = O : k.sibling = O, k = O); return e && P.forEach(function (K) { return t(p, K) }), X && mn(p, C), E } function v(p, h, m, x) { var E = Lr(m); if (typeof E != "function") throw Error(A(150)); if (m = E.call(m), m == null) throw Error(A(151)); for (var k = E = null, P = h, C = h = 0, O = null, M = m.next(); P !== null && !M.done; C++, M = m.next()) { P.index > C ? (O = P, P = null) : O = P.sibling; var K = d(p, P, M.value, x); if (K === null) { P === null && (P = O); break } e && P && K.alternate === null && t(p, P), h = o(K, h, C), k === null ? E = K : k.sibling = K, k = K, P = O } if (M.done) return n(p, P), X && mn(p, C), E; if (P === null) { for (; !M.done; C++, M = m.next())M = f(p, M.value, x), M !== null && (h = o(M, h, C), k === null ? E = M : k.sibling = M, k = M); return X && mn(p, C), E } for (P = r(p, P); !M.done; C++, M = m.next())M = g(P, p, C, M.value, x), M !== null && (e && M.alternate !== null && P.delete(M.key === null ? C : M.key), h = o(M, h, C), k === null ? E = M : k.sibling = M, k = M); return e && P.forEach(function (Te) { return t(p, Te) }), X && mn(p, C), E } function S(p, h, m, x) { if (typeof m == "object" && m !== null && m.type === Bn && m.key === null && (m = m.props.children), typeof m == "object" && m !== null) { switch (m.$$typeof) { case Hi: e: { for (var E = m.key, k = h; k !== null;) { if (k.key === E) { if (E = m.type, E === Bn) { if (k.tag === 7) { n(p, k.sibling), h = i(k, m.props.children), h.return = p, p = h; break e } } else if (k.elementType === E || typeof E == "object" && E !== null && E.$$typeof === $t && Of(E) === k.type) { n(p, k.sibling), h = i(k, m.props), h.ref = Nr(p, k, m), h.return = p, p = h; break e } n(p, k); break } else t(p, k); k = k.sibling } m.type === Bn ? (h = Pn(m.props.children, p.mode, x, m.key), h.return = p, p = h) : (x = Po(m.type, m.key, m.props, null, p.mode, x), x.ref = Nr(p, h, m), x.return = p, p = x) } return s(p); case jn: e: { for (k = m.key; h !== null;) { if (h.key === k) if (h.tag === 4 && h.stateNode.containerInfo === m.containerInfo && h.stateNode.implementation === m.implementation) { n(p, h.sibling), h = i(h, m.children || []), h.return = p, p = h; break e } else { n(p, h); break } else t(p, h); h = h.sibling } h = ma(m, p.mode, x), h.return = p, p = h } return s(p); case $t: return k = m._init, S(p, h, k(m._payload), x) }if (Ur(m)) return y(p, h, m, x); if (Lr(m)) return v(p, h, m, x); no(p, m) } return typeof m == "string" && m !== "" || typeof m == "number" ? (m = "" + m, h !== null && h.tag === 6 ? (n(p, h.sibling), h = i(h, m), h.return = p, p = h) : (n(p, h), h = pa(m, p.mode, x), h.return = p, p = h), s(p)) : n(p, h) } return S } var cr = sm(!0), am = sm(!1), Qo = un(null), qo = null, Gn = null, _u = null; function Mu() { _u = Gn = qo = null } function Ou(e) { var t = Qo.current; W(Qo), e._currentValue = t } function ml(e, t, n) { for (; e !== null;) { var r = e.alternate; if ((e.childLanes & t) !== t ? (e.childLanes |= t, r !== null && (r.childLanes |= t)) : r !== null && (r.childLanes & t) !== t && (r.childLanes |= t), e === n) break; e = e.return } } function ir(e, t) { qo = e, _u = Gn = null, e = e.dependencies, e !== null && e.firstContext !== null && (e.lanes & t && (Me = !0), e.firstContext = null) } function tt(e) { var t = e._currentValue; if (_u !== e) if (e = { context: e, memoizedValue: t, next: null }, Gn === null) { if (qo === null) throw Error(A(308)); Gn = e, qo.dependencies = { lanes: 0, firstContext: e } } else Gn = Gn.next = e; return t } var wn = null; function Nu(e) { wn === null ? wn = [e] : wn.push(e) } function lm(e, t, n, r) { var i = t.interleaved; return i === null ? (n.next = n, Nu(t)) : (n.next = i.next, i.next = n), t.interleaved = n, Nt(e, r) } function Nt(e, t) { e.lanes |= t; var n = e.alternate; for (n !== null && (n.lanes |= t), n = e, e = e.return; e !== null;)e.childLanes |= t, n = e.alternate, n !== null && (n.childLanes |= t), n = e, e = e.return; return n.tag === 3 ? n.stateNode : null } var bt = !1; function Vu(e) { e.updateQueue = { baseState: e.memoizedState, firstBaseUpdate: null, lastBaseUpdate: null, shared: { pending: null, interleaved: null, lanes: 0 }, effects: null } } function um(e, t) { e = e.updateQueue, t.updateQueue === e && (t.updateQueue = { baseState: e.baseState, firstBaseUpdate: e.firstBaseUpdate, lastBaseUpdate: e.lastBaseUpdate, shared: e.shared, effects: e.effects }) } function Dt(e, t) { return { eventTime: e, lane: t, tag: 0, payload: null, callback: null, next: null } } function Zt(e, t, n) { var r = e.updateQueue; if (r === null) return null; if (r = r.shared, j & 2) { var i = r.pending; return i === null ? t.next = t : (t.next = i.next, i.next = t), r.pending = t, Nt(e, n) } return i = r.interleaved, i === null ? (t.next = t, Nu(r)) : (t.next = i.next, i.next = t), r.interleaved = t, Nt(e, n) } function wo(e, t, n) { if (t = t.updateQueue, t !== null && (t = t.shared, (n & 4194240) !== 0)) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Su(e, n) } } function Nf(e, t) { var n = e.updateQueue, r = e.alternate; if (r !== null && (r = r.updateQueue, n === r)) { var i = null, o = null; if (n = n.firstBaseUpdate, n !== null) { do { var s = { eventTime: n.eventTime, lane: n.lane, tag: n.tag, payload: n.payload, callback: n.callback, next: null }; o === null ? i = o = s : o = o.next = s, n = n.next } while (n !== null); o === null ? i = o = t : o = o.next = t } else i = o = t; n = { baseState: r.baseState, firstBaseUpdate: i, lastBaseUpdate: o, shared: r.shared, effects: r.effects }, e.updateQueue = n; return } e = n.lastBaseUpdate, e === null ? n.firstBaseUpdate = t : e.next = t, n.lastBaseUpdate = t } function Jo(e, t, n, r) { var i = e.updateQueue; bt = !1; var o = i.firstBaseUpdate, s = i.lastBaseUpdate, a = i.shared.pending; if (a !== null) { i.shared.pending = null; var l = a, u = l.next; l.next = null, s === null ? o = u : s.next = u, s = l; var c = e.alternate; c !== null && (c = c.updateQueue, a = c.lastBaseUpdate, a !== s && (a === null ? c.firstBaseUpdate = u : a.next = u, c.lastBaseUpdate = l)) } if (o !== null) { var f = i.baseState; s = 0, c = u = l = null, a = o; do { var d = a.lane, g = a.eventTime; if ((r & d) === d) { c !== null && (c = c.next = { eventTime: g, lane: 0, tag: a.tag, payload: a.payload, callback: a.callback, next: null }); e: { var y = e, v = a; switch (d = t, g = n, v.tag) { case 1: if (y = v.payload, typeof y == "function") { f = y.call(g, f, d); break e } f = y; break e; case 3: y.flags = y.flags & -65537 | 128; case 0: if (y = v.payload, d = typeof y == "function" ? y.call(g, f, d) : y, d == null) break e; f = ee({}, f, d); break e; case 2: bt = !0 } } a.callback !== null && a.lane !== 0 && (e.flags |= 64, d = i.effects, d === null ? i.effects = [a] : d.push(a)) } else g = { eventTime: g, lane: d, tag: a.tag, payload: a.payload, callback: a.callback, next: null }, c === null ? (u = c = g, l = f) : c = c.next = g, s |= d; if (a = a.next, a === null) { if (a = i.shared.pending, a === null) break; d = a, a = d.next, d.next = null, i.lastBaseUpdate = d, i.shared.pending = null } } while (1); if (c === null && (l = f), i.baseState = l, i.firstBaseUpdate = u, i.lastBaseUpdate = c, t = i.shared.interleaved, t !== null) { i = t; do s |= i.lane, i = i.next; while (i !== t) } else o === null && (i.shared.lanes = 0); Dn |= s, e.lanes = s, e.memoizedState = f } } function Vf(e, t, n) { if (e = t.effects, t.effects = null, e !== null) for (t = 0; t < e.length; t++) { var r = e[t], i = r.callback; if (i !== null) { if (r.callback = null, r = n, typeof i != "function") throw Error(A(191, i)); i.call(r) } } } var Mi = {}, xt = un(Mi), yi = un(Mi), gi = un(Mi); function Sn(e) { if (e === Mi) throw Error(A(174)); return e } function Iu(e, t) { switch (U(gi, t), U(yi, e), U(xt, Mi), e = t.nodeType, e) { case 9: case 11: t = (t = t.documentElement) ? t.namespaceURI : Ya(null, ""); break; default: e = e === 8 ? t.parentNode : t, t = e.namespaceURI || null, e = e.tagName, t = Ya(t, e) }W(xt), U(xt, t) } function fr() { W(xt), W(yi), W(gi) } function cm(e) { Sn(gi.current); var t = Sn(xt.current), n = Ya(t, e.type); t !== n && (U(yi, e), U(xt, n)) } function Fu(e) { yi.current === e && (W(xt), W(yi)) } var q = un(0); function Zo(e) { for (var t = e; t !== null;) { if (t.tag === 13) { var n = t.memoizedState; if (n !== null && (n = n.dehydrated, n === null || n.data === "$?" || n.data === "$!")) return t } else if (t.tag === 19 && t.memoizedProps.revealOrder !== void 0) { if (t.flags & 128) return t } else if (t.child !== null) { t.child.return = t, t = t.child; continue } if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return null; t = t.return } t.sibling.return = t.return, t = t.sibling } return null } var la = []; function ju() { for (var e = 0; e < la.length; e++)la[e]._workInProgressVersionPrimary = null; la.length = 0 } var So = jt.ReactCurrentDispatcher, ua = jt.ReactCurrentBatchConfig, Ln = 0, Z = null, le = null, ce = null, es = !1, qr = !1, vi = 0, C1 = 0; function ge() { throw Error(A(321)) } function Bu(e, t) { if (t === null) return !1; for (var n = 0; n < t.length && n < e.length; n++)if (!ht(e[n], t[n])) return !1; return !0 } function zu(e, t, n, r, i, o) { if (Ln = o, Z = t, t.memoizedState = null, t.updateQueue = null, t.lanes = 0, So.current = e === null || e.memoizedState === null ? A1 : L1, e = n(r, i), qr) { o = 0; do { if (qr = !1, vi = 0, 25 <= o) throw Error(A(301)); o += 1, ce = le = null, t.updateQueue = null, So.current = D1, e = n(r, i) } while (qr) } if (So.current = ts, t = le !== null && le.next !== null, Ln = 0, ce = le = Z = null, es = !1, t) throw Error(A(300)); return e } function Uu() { var e = vi !== 0; return vi = 0, e } function vt() { var e = { memoizedState: null, baseState: null, baseQueue: null, queue: null, next: null }; return ce === null ? Z.memoizedState = ce = e : ce = ce.next = e, ce } function nt() { if (le === null) { var e = Z.alternate; e = e !== null ? e.memoizedState : null } else e = le.next; var t = ce === null ? Z.memoizedState : ce.next; if (t !== null) ce = t, le = e; else { if (e === null) throw Error(A(310)); le = e, e = { memoizedState: le.memoizedState, baseState: le.baseState, baseQueue: le.baseQueue, queue: le.queue, next: null }, ce === null ? Z.memoizedState = ce = e : ce = ce.next = e } return ce } function wi(e, t) { return typeof t == "function" ? t(e) : t } function ca(e) { var t = nt(), n = t.queue; if (n === null) throw Error(A(311)); n.lastRenderedReducer = e; var r = le, i = r.baseQueue, o = n.pending; if (o !== null) { if (i !== null) { var s = i.next; i.next = o.next, o.next = s } r.baseQueue = i = o, n.pending = null } if (i !== null) { o = i.next, r = r.baseState; var a = s = null, l = null, u = o; do { var c = u.lane; if ((Ln & c) === c) l !== null && (l = l.next = { lane: 0, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }), r = u.hasEagerState ? u.eagerState : e(r, u.action); else { var f = { lane: c, action: u.action, hasEagerState: u.hasEagerState, eagerState: u.eagerState, next: null }; l === null ? (a = l = f, s = r) : l = l.next = f, Z.lanes |= c, Dn |= c } u = u.next } while (u !== null && u !== o); l === null ? s = r : l.next = a, ht(r, t.memoizedState) || (Me = !0), t.memoizedState = r, t.baseState = s, t.baseQueue = l, n.lastRenderedState = r } if (e = n.interleaved, e !== null) { i = e; do o = i.lane, Z.lanes |= o, Dn |= o, i = i.next; while (i !== e) } else i === null && (n.lanes = 0); return [t.memoizedState, n.dispatch] } function fa(e) { var t = nt(), n = t.queue; if (n === null) throw Error(A(311)); n.lastRenderedReducer = e; var r = n.dispatch, i = n.pending, o = t.memoizedState; if (i !== null) { n.pending = null; var s = i = i.next; do o = e(o, s.action), s = s.next; while (s !== i); ht(o, t.memoizedState) || (Me = !0), t.memoizedState = o, t.baseQueue === null && (t.baseState = o), n.lastRenderedState = o } return [o, r] } function fm() { } function dm(e, t) { var n = Z, r = nt(), i = t(), o = !ht(r.memoizedState, i); if (o && (r.memoizedState = i, Me = !0), r = r.queue, $u(mm.bind(null, n, r, e), [e]), r.getSnapshot !== t || o || ce !== null && ce.memoizedState.tag & 1) { if (n.flags |= 2048, Si(9, pm.bind(null, n, r, i, t), void 0, null), fe === null) throw Error(A(349)); Ln & 30 || hm(n, t, i) } return i } function hm(e, t, n) { e.flags |= 16384, e = { getSnapshot: t, value: n }, t = Z.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Z.updateQueue = t, t.stores = [e]) : (n = t.stores, n === null ? t.stores = [e] : n.push(e)) } function pm(e, t, n, r) { t.value = n, t.getSnapshot = r, ym(t) && gm(e) } function mm(e, t, n) { return n(function () { ym(t) && gm(e) }) } function ym(e) { var t = e.getSnapshot; e = e.value; try { var n = t(); return !ht(e, n) } catch { return !0 } } function gm(e) { var t = Nt(e, 1); t !== null && ft(t, e, 1, -1) } function If(e) { var t = vt(); return typeof e == "function" && (e = e()), t.memoizedState = t.baseState = e, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: wi, lastRenderedState: e }, t.queue = e, e = e.dispatch = R1.bind(null, Z, e), [t.memoizedState, e] } function Si(e, t, n, r) { return e = { tag: e, create: t, destroy: n, deps: r, next: null }, t = Z.updateQueue, t === null ? (t = { lastEffect: null, stores: null }, Z.updateQueue = t, t.lastEffect = e.next = e) : (n = t.lastEffect, n === null ? t.lastEffect = e.next = e : (r = n.next, n.next = e, e.next = r, t.lastEffect = e)), e } function vm() { return nt().memoizedState } function xo(e, t, n, r) { var i = vt(); Z.flags |= e, i.memoizedState = Si(1 | t, n, void 0, r === void 0 ? null : r) } function Ts(e, t, n, r) { var i = nt(); r = r === void 0 ? null : r; var o = void 0; if (le !== null) { var s = le.memoizedState; if (o = s.destroy, r !== null && Bu(r, s.deps)) { i.memoizedState = Si(t, n, o, r); return } } Z.flags |= e, i.memoizedState = Si(1 | t, n, o, r) } function Ff(e, t) { return xo(8390656, 8, e, t) } function $u(e, t) { return Ts(2048, 8, e, t) } function wm(e, t) { return Ts(4, 2, e, t) } function Sm(e, t) { return Ts(4, 4, e, t) } function xm(e, t) { if (typeof t == "function") return e = e(), t(e), function () { t(null) }; if (t != null) return e = e(), t.current = e, function () { t.current = null } } function Em(e, t, n) { return n = n != null ? n.concat([e]) : null, Ts(4, 4, xm.bind(null, t, e), n) } function bu() { } function Tm(e, t) { var n = nt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Bu(t, r[1]) ? r[0] : (n.memoizedState = [e, t], e) } function Cm(e, t) { var n = nt(); t = t === void 0 ? null : t; var r = n.memoizedState; return r !== null && t !== null && Bu(t, r[1]) ? r[0] : (e = e(), n.memoizedState = [e, t], e) } function Pm(e, t, n) { return Ln & 21 ? (ht(n, t) || (n = Dp(), Z.lanes |= n, Dn |= n, e.baseState = !0), t) : (e.baseState && (e.baseState = !1, Me = !0), e.memoizedState = n) } function P1(e, t) { var n = z; z = n !== 0 && 4 > n ? n : 4, e(!0); var r = ua.transition; ua.transition = {}; try { e(!1), t() } finally { z = n, ua.transition = r } } function km() { return nt().memoizedState } function k1(e, t, n) { var r = tn(e); if (n = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }, Rm(e)) Am(t, n); else if (n = lm(e, t, n, r), n !== null) { var i = Ae(); ft(n, e, r, i), Lm(n, t, r) } } function R1(e, t, n) { var r = tn(e), i = { lane: r, action: n, hasEagerState: !1, eagerState: null, next: null }; if (Rm(e)) Am(t, i); else { var o = e.alternate; if (e.lanes === 0 && (o === null || o.lanes === 0) && (o = t.lastRenderedReducer, o !== null)) try { var s = t.lastRenderedState, a = o(s, n); if (i.hasEagerState = !0, i.eagerState = a, ht(a, s)) { var l = t.interleaved; l === null ? (i.next = i, Nu(t)) : (i.next = l.next, l.next = i), t.interleaved = i; return } } catch { } finally { } n = lm(e, t, i, r), n !== null && (i = Ae(), ft(n, e, r, i), Lm(n, t, r)) } } function Rm(e) { var t = e.alternate; return e === Z || t !== null && t === Z } function Am(e, t) { qr = es = !0; var n = e.pending; n === null ? t.next = t : (t.next = n.next, n.next = t), e.pending = t } function Lm(e, t, n) { if (n & 4194240) { var r = t.lanes; r &= e.pendingLanes, n |= r, t.lanes = n, Su(e, n) } } var ts = { readContext: tt, useCallback: ge, useContext: ge, useEffect: ge, useImperativeHandle: ge, useInsertionEffect: ge, useLayoutEffect: ge, useMemo: ge, useReducer: ge, useRef: ge, useState: ge, useDebugValue: ge, useDeferredValue: ge, useTransition: ge, useMutableSource: ge, useSyncExternalStore: ge, useId: ge, unstable_isNewReconciler: !1 }, A1 = { readContext: tt, useCallback: function (e, t) { return vt().memoizedState = [e, t === void 0 ? null : t], e }, useContext: tt, useEffect: Ff, useImperativeHandle: function (e, t, n) { return n = n != null ? n.concat([e]) : null, xo(4194308, 4, xm.bind(null, t, e), n) }, useLayoutEffect: function (e, t) { return xo(4194308, 4, e, t) }, useInsertionEffect: function (e, t) { return xo(4, 2, e, t) }, useMemo: function (e, t) { var n = vt(); return t = t === void 0 ? null : t, e = e(), n.memoizedState = [e, t], e }, useReducer: function (e, t, n) { var r = vt(); return t = n !== void 0 ? n(t) : t, r.memoizedState = r.baseState = t, e = { pending: null, interleaved: null, lanes: 0, dispatch: null, lastRenderedReducer: e, lastRenderedState: t }, r.queue = e, e = e.dispatch = k1.bind(null, Z, e), [r.memoizedState, e] }, useRef: function (e) { var t = vt(); return e = { current: e }, t.memoizedState = e }, useState: If, useDebugValue: bu, useDeferredValue: function (e) { return vt().memoizedState = e }, useTransition: function () { var e = If(!1), t = e[0]; return e = P1.bind(null, e[1]), vt().memoizedState = e, [t, e] }, useMutableSource: function () { }, useSyncExternalStore: function (e, t, n) { var r = Z, i = vt(); if (X) { if (n === void 0) throw Error(A(407)); n = n() } else { if (n = t(), fe === null) throw Error(A(349)); Ln & 30 || hm(r, t, n) } i.memoizedState = n; var o = { value: n, getSnapshot: t }; return i.queue = o, Ff(mm.bind(null, r, o, e), [e]), r.flags |= 2048, Si(9, pm.bind(null, r, o, n, t), void 0, null), n }, useId: function () { var e = vt(), t = fe.identifierPrefix; if (X) { var n = Lt, r = At; n = (r & ~(1 << 32 - ct(r) - 1)).toString(32) + n, t = ":" + t + "R" + n, n = vi++, 0 < n && (t += "H" + n.toString(32)), t += ":" } else n = C1++, t = ":" + t + "r" + n.toString(32) + ":"; return e.memoizedState = t }, unstable_isNewReconciler: !1 }, L1 = { readContext: tt, useCallback: Tm, useContext: tt, useEffect: $u, useImperativeHandle: Em, useInsertionEffect: wm, useLayoutEffect: Sm, useMemo: Cm, useReducer: ca, useRef: vm, useState: function () { return ca(wi) }, useDebugValue: bu, useDeferredValue: function (e) { var t = nt(); return Pm(t, le.memoizedState, e) }, useTransition: function () { var e = ca(wi)[0], t = nt().memoizedState; return [e, t] }, useMutableSource: fm, useSyncExternalStore: dm, useId: km, unstable_isNewReconciler: !1 }, D1 = { readContext: tt, useCallback: Tm, useContext: tt, useEffect: $u, useImperativeHandle: Em, useInsertionEffect: wm, useLayoutEffect: Sm, useMemo: Cm, useReducer: fa, useRef: vm, useState: function () { return fa(wi) }, useDebugValue: bu, useDeferredValue: function (e) { var t = nt(); return le === null ? t.memoizedState = e : Pm(t, le.memoizedState, e) }, useTransition: function () { var e = fa(wi)[0], t = nt().memoizedState; return [e, t] }, useMutableSource: fm, useSyncExternalStore: dm, useId: km, unstable_isNewReconciler: !1 }; function at(e, t) { if (e && e.defaultProps) { t = ee({}, t), e = e.defaultProps; for (var n in e) t[n] === void 0 && (t[n] = e[n]); return t } return t } function yl(e, t, n, r) { t = e.memoizedState, n = n(r, t), n = n == null ? t : ee({}, t, n), e.memoizedState = n, e.lanes === 0 && (e.updateQueue.baseState = n) } var Cs = { isMounted: function (e) { return (e = e._reactInternals) ? Vn(e) === e : !1 }, enqueueSetState: function (e, t, n) { e = e._reactInternals; var r = Ae(), i = tn(e), o = Dt(r, i); o.payload = t, n != null && (o.callback = n), t = Zt(e, o, i), t !== null && (ft(t, e, i, r), wo(t, e, i)) }, enqueueReplaceState: function (e, t, n) { e = e._reactInternals; var r = Ae(), i = tn(e), o = Dt(r, i); o.tag = 1, o.payload = t, n != null && (o.callback = n), t = Zt(e, o, i), t !== null && (ft(t, e, i, r), wo(t, e, i)) }, enqueueForceUpdate: function (e, t) { e = e._reactInternals; var n = Ae(), r = tn(e), i = Dt(n, r); i.tag = 2, t != null && (i.callback = t), t = Zt(e, i, r), t !== null && (ft(t, e, r, n), wo(t, e, r)) } }; function jf(e, t, n, r, i, o, s) { return e = e.stateNode, typeof e.shouldComponentUpdate == "function" ? e.shouldComponentUpdate(r, o, s) : t.prototype && t.prototype.isPureReactComponent ? !di(n, r) || !di(i, o) : !0 } function Dm(e, t, n) { var r = !1, i = on, o = t.contextType; return typeof o == "object" && o !== null ? o = tt(o) : (i = Ne(t) ? Rn : Ee.current, r = t.contextTypes, o = (r = r != null) ? lr(e, i) : on), t = new t(n, o), e.memoizedState = t.state !== null && t.state !== void 0 ? t.state : null, t.updater = Cs, e.stateNode = t, t._reactInternals = e, r && (e = e.stateNode, e.__reactInternalMemoizedUnmaskedChildContext = i, e.__reactInternalMemoizedMaskedChildContext = o), t } function Bf(e, t, n, r) { e = t.state, typeof t.componentWillReceiveProps == "function" && t.componentWillReceiveProps(n, r), typeof t.UNSAFE_componentWillReceiveProps == "function" && t.UNSAFE_componentWillReceiveProps(n, r), t.state !== e && Cs.enqueueReplaceState(t, t.state, null) } function gl(e, t, n, r) { var i = e.stateNode; i.props = n, i.state = e.memoizedState, i.refs = {}, Vu(e); var o = t.contextType; typeof o == "object" && o !== null ? i.context = tt(o) : (o = Ne(t) ? Rn : Ee.current, i.context = lr(e, o)), i.state = e.memoizedState, o = t.getDerivedStateFromProps, typeof o == "function" && (yl(e, t, o, n), i.state = e.memoizedState), typeof t.getDerivedStateFromProps == "function" || typeof i.getSnapshotBeforeUpdate == "function" || typeof i.UNSAFE_componentWillMount != "function" && typeof i.componentWillMount != "function" || (t = i.state, typeof i.componentWillMount == "function" && i.componentWillMount(), typeof i.UNSAFE_componentWillMount == "function" && i.UNSAFE_componentWillMount(), t !== i.state && Cs.enqueueReplaceState(i, i.state, null), Jo(e, n, i, r), i.state = e.memoizedState), typeof i.componentDidMount == "function" && (e.flags |= 4194308) } function dr(e, t) {
  try { var n = "", r = t; do n += iv(r), r = r.return; while (r); var i = n } catch (o) {
    i = `
Error generating stack: `+ o.message + `
`+ o.stack
  } return { value: e, source: t, stack: i, digest: null }
} function da(e, t, n) { return { value: e, source: null, stack: n ?? null, digest: t ?? null } } function vl(e, t) { try { console.error(t.value) } catch (n) { setTimeout(function () { throw n }) } } var _1 = typeof WeakMap == "function" ? WeakMap : Map; function _m(e, t, n) { n = Dt(-1, n), n.tag = 3, n.payload = { element: null }; var r = t.value; return n.callback = function () { rs || (rs = !0, Al = r), vl(e, t) }, n } function Mm(e, t, n) { n = Dt(-1, n), n.tag = 3; var r = e.type.getDerivedStateFromError; if (typeof r == "function") { var i = t.value; n.payload = function () { return r(i) }, n.callback = function () { vl(e, t) } } var o = e.stateNode; return o !== null && typeof o.componentDidCatch == "function" && (n.callback = function () { vl(e, t), typeof r != "function" && (en === null ? en = new Set([this]) : en.add(this)); var s = t.stack; this.componentDidCatch(t.value, { componentStack: s !== null ? s : "" }) }), n } function zf(e, t, n) { var r = e.pingCache; if (r === null) { r = e.pingCache = new _1; var i = new Set; r.set(t, i) } else i = r.get(t), i === void 0 && (i = new Set, r.set(t, i)); i.has(n) || (i.add(n), e = H1.bind(null, e, t, n), t.then(e, e)) } function Uf(e) { do { var t; if ((t = e.tag === 13) && (t = e.memoizedState, t = t !== null ? t.dehydrated !== null : !0), t) return e; e = e.return } while (e !== null); return null } function $f(e, t, n, r, i) { return e.mode & 1 ? (e.flags |= 65536, e.lanes = i, e) : (e === t ? e.flags |= 65536 : (e.flags |= 128, n.flags |= 131072, n.flags &= -52805, n.tag === 1 && (n.alternate === null ? n.tag = 17 : (t = Dt(-1, 1), t.tag = 2, Zt(n, t, 1))), n.lanes |= 1), e) } var M1 = jt.ReactCurrentOwner, Me = !1; function Pe(e, t, n, r) { t.child = e === null ? am(t, null, n, r) : cr(t, e.child, n, r) } function bf(e, t, n, r, i) { n = n.render; var o = t.ref; return ir(t, i), r = zu(e, t, n, r, o, i), n = Uu(), e !== null && !Me ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Vt(e, t, i)) : (X && n && Au(t), t.flags |= 1, Pe(e, t, r, i), t.child) } function Wf(e, t, n, r, i) { if (e === null) { var o = n.type; return typeof o == "function" && !qu(o) && o.defaultProps === void 0 && n.compare === null && n.defaultProps === void 0 ? (t.tag = 15, t.type = o, Om(e, t, o, r, i)) : (e = Po(n.type, null, r, t, t.mode, i), e.ref = t.ref, e.return = t, t.child = e) } if (o = e.child, !(e.lanes & i)) { var s = o.memoizedProps; if (n = n.compare, n = n !== null ? n : di, n(s, r) && e.ref === t.ref) return Vt(e, t, i) } return t.flags |= 1, e = nn(o, r), e.ref = t.ref, e.return = t, t.child = e } function Om(e, t, n, r, i) { if (e !== null) { var o = e.memoizedProps; if (di(o, r) && e.ref === t.ref) if (Me = !1, t.pendingProps = r = o, (e.lanes & i) !== 0) e.flags & 131072 && (Me = !0); else return t.lanes = e.lanes, Vt(e, t, i) } return wl(e, t, n, r, i) } function Nm(e, t, n) { var r = t.pendingProps, i = r.children, o = e !== null ? e.memoizedState : null; if (r.mode === "hidden") if (!(t.mode & 1)) t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, U(Yn, Be), Be |= n; else { if (!(n & 1073741824)) return e = o !== null ? o.baseLanes | n : n, t.lanes = t.childLanes = 1073741824, t.memoizedState = { baseLanes: e, cachePool: null, transitions: null }, t.updateQueue = null, U(Yn, Be), Be |= e, null; t.memoizedState = { baseLanes: 0, cachePool: null, transitions: null }, r = o !== null ? o.baseLanes : n, U(Yn, Be), Be |= r } else o !== null ? (r = o.baseLanes | n, t.memoizedState = null) : r = n, U(Yn, Be), Be |= r; return Pe(e, t, i, n), t.child } function Vm(e, t) { var n = t.ref; (e === null && n !== null || e !== null && e.ref !== n) && (t.flags |= 512, t.flags |= 2097152) } function wl(e, t, n, r, i) { var o = Ne(n) ? Rn : Ee.current; return o = lr(t, o), ir(t, i), n = zu(e, t, n, r, o, i), r = Uu(), e !== null && !Me ? (t.updateQueue = e.updateQueue, t.flags &= -2053, e.lanes &= ~i, Vt(e, t, i)) : (X && r && Au(t), t.flags |= 1, Pe(e, t, n, i), t.child) } function Hf(e, t, n, r, i) { if (Ne(n)) { var o = !0; Go(t) } else o = !1; if (ir(t, i), t.stateNode === null) Eo(e, t), Dm(t, n, r), gl(t, n, r, i), r = !0; else if (e === null) { var s = t.stateNode, a = t.memoizedProps; s.props = a; var l = s.context, u = n.contextType; typeof u == "object" && u !== null ? u = tt(u) : (u = Ne(n) ? Rn : Ee.current, u = lr(t, u)); var c = n.getDerivedStateFromProps, f = typeof c == "function" || typeof s.getSnapshotBeforeUpdate == "function"; f || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== r || l !== u) && Bf(t, s, r, u), bt = !1; var d = t.memoizedState; s.state = d, Jo(t, r, s, i), l = t.memoizedState, a !== r || d !== l || Oe.current || bt ? (typeof c == "function" && (yl(t, n, c, r), l = t.memoizedState), (a = bt || jf(t, n, a, r, d, l, u)) ? (f || typeof s.UNSAFE_componentWillMount != "function" && typeof s.componentWillMount != "function" || (typeof s.componentWillMount == "function" && s.componentWillMount(), typeof s.UNSAFE_componentWillMount == "function" && s.UNSAFE_componentWillMount()), typeof s.componentDidMount == "function" && (t.flags |= 4194308)) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), t.memoizedProps = r, t.memoizedState = l), s.props = r, s.state = l, s.context = u, r = a) : (typeof s.componentDidMount == "function" && (t.flags |= 4194308), r = !1) } else { s = t.stateNode, um(e, t), a = t.memoizedProps, u = t.type === t.elementType ? a : at(t.type, a), s.props = u, f = t.pendingProps, d = s.context, l = n.contextType, typeof l == "object" && l !== null ? l = tt(l) : (l = Ne(n) ? Rn : Ee.current, l = lr(t, l)); var g = n.getDerivedStateFromProps; (c = typeof g == "function" || typeof s.getSnapshotBeforeUpdate == "function") || typeof s.UNSAFE_componentWillReceiveProps != "function" && typeof s.componentWillReceiveProps != "function" || (a !== f || d !== l) && Bf(t, s, r, l), bt = !1, d = t.memoizedState, s.state = d, Jo(t, r, s, i); var y = t.memoizedState; a !== f || d !== y || Oe.current || bt ? (typeof g == "function" && (yl(t, n, g, r), y = t.memoizedState), (u = bt || jf(t, n, u, r, d, y, l) || !1) ? (c || typeof s.UNSAFE_componentWillUpdate != "function" && typeof s.componentWillUpdate != "function" || (typeof s.componentWillUpdate == "function" && s.componentWillUpdate(r, y, l), typeof s.UNSAFE_componentWillUpdate == "function" && s.UNSAFE_componentWillUpdate(r, y, l)), typeof s.componentDidUpdate == "function" && (t.flags |= 4), typeof s.getSnapshotBeforeUpdate == "function" && (t.flags |= 1024)) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), t.memoizedProps = r, t.memoizedState = y), s.props = r, s.state = y, s.context = l, r = u) : (typeof s.componentDidUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 4), typeof s.getSnapshotBeforeUpdate != "function" || a === e.memoizedProps && d === e.memoizedState || (t.flags |= 1024), r = !1) } return Sl(e, t, n, r, o, i) } function Sl(e, t, n, r, i, o) { Vm(e, t); var s = (t.flags & 128) !== 0; if (!r && !s) return i && Df(t, n, !1), Vt(e, t, o); r = t.stateNode, M1.current = t; var a = s && typeof n.getDerivedStateFromError != "function" ? null : r.render(); return t.flags |= 1, e !== null && s ? (t.child = cr(t, e.child, null, o), t.child = cr(t, null, a, o)) : Pe(e, t, a, o), t.memoizedState = r.state, i && Df(t, n, !0), t.child } function Im(e) { var t = e.stateNode; t.pendingContext ? Lf(e, t.pendingContext, t.pendingContext !== t.context) : t.context && Lf(e, t.context, !1), Iu(e, t.containerInfo) } function Kf(e, t, n, r, i) { return ur(), Du(i), t.flags |= 256, Pe(e, t, n, r), t.child } var xl = { dehydrated: null, treeContext: null, retryLane: 0 }; function El(e) { return { baseLanes: e, cachePool: null, transitions: null } } function Fm(e, t, n) { var r = t.pendingProps, i = q.current, o = !1, s = (t.flags & 128) !== 0, a; if ((a = s) || (a = e !== null && e.memoizedState === null ? !1 : (i & 2) !== 0), a ? (o = !0, t.flags &= -129) : (e === null || e.memoizedState !== null) && (i |= 1), U(q, i & 1), e === null) return pl(t), e = t.memoizedState, e !== null && (e = e.dehydrated, e !== null) ? (t.mode & 1 ? e.data === "$!" ? t.lanes = 8 : t.lanes = 1073741824 : t.lanes = 1, null) : (s = r.children, e = r.fallback, o ? (r = t.mode, o = t.child, s = { mode: "hidden", children: s }, !(r & 1) && o !== null ? (o.childLanes = 0, o.pendingProps = s) : o = Rs(s, r, 0, null), e = Pn(e, r, n, null), o.return = t, e.return = t, o.sibling = e, t.child = o, t.child.memoizedState = El(n), t.memoizedState = xl, e) : Wu(t, s)); if (i = e.memoizedState, i !== null && (a = i.dehydrated, a !== null)) return O1(e, t, s, r, a, i, n); if (o) { o = r.fallback, s = t.mode, i = e.child, a = i.sibling; var l = { mode: "hidden", children: r.children }; return !(s & 1) && t.child !== i ? (r = t.child, r.childLanes = 0, r.pendingProps = l, t.deletions = null) : (r = nn(i, l), r.subtreeFlags = i.subtreeFlags & 14680064), a !== null ? o = nn(a, o) : (o = Pn(o, s, n, null), o.flags |= 2), o.return = t, r.return = t, r.sibling = o, t.child = r, r = o, o = t.child, s = e.child.memoizedState, s = s === null ? El(n) : { baseLanes: s.baseLanes | n, cachePool: null, transitions: s.transitions }, o.memoizedState = s, o.childLanes = e.childLanes & ~n, t.memoizedState = xl, r } return o = e.child, e = o.sibling, r = nn(o, { mode: "visible", children: r.children }), !(t.mode & 1) && (r.lanes = n), r.return = t, r.sibling = null, e !== null && (n = t.deletions, n === null ? (t.deletions = [e], t.flags |= 16) : n.push(e)), t.child = r, t.memoizedState = null, r } function Wu(e, t) { return t = Rs({ mode: "visible", children: t }, e.mode, 0, null), t.return = e, e.child = t } function ro(e, t, n, r) { return r !== null && Du(r), cr(t, e.child, null, n), e = Wu(t, t.pendingProps.children), e.flags |= 2, t.memoizedState = null, e } function O1(e, t, n, r, i, o, s) { if (n) return t.flags & 256 ? (t.flags &= -257, r = da(Error(A(422))), ro(e, t, s, r)) : t.memoizedState !== null ? (t.child = e.child, t.flags |= 128, null) : (o = r.fallback, i = t.mode, r = Rs({ mode: "visible", children: r.children }, i, 0, null), o = Pn(o, i, s, null), o.flags |= 2, r.return = t, o.return = t, r.sibling = o, t.child = r, t.mode & 1 && cr(t, e.child, null, s), t.child.memoizedState = El(s), t.memoizedState = xl, o); if (!(t.mode & 1)) return ro(e, t, s, null); if (i.data === "$!") { if (r = i.nextSibling && i.nextSibling.dataset, r) var a = r.dgst; return r = a, o = Error(A(419)), r = da(o, r, void 0), ro(e, t, s, r) } if (a = (s & e.childLanes) !== 0, Me || a) { if (r = fe, r !== null) { switch (s & -s) { case 4: i = 2; break; case 16: i = 8; break; case 64: case 128: case 256: case 512: case 1024: case 2048: case 4096: case 8192: case 16384: case 32768: case 65536: case 131072: case 262144: case 524288: case 1048576: case 2097152: case 4194304: case 8388608: case 16777216: case 33554432: case 67108864: i = 32; break; case 536870912: i = 268435456; break; default: i = 0 }i = i & (r.suspendedLanes | s) ? 0 : i, i !== 0 && i !== o.retryLane && (o.retryLane = i, Nt(e, i), ft(r, e, i, -1)) } return Qu(), r = da(Error(A(421))), ro(e, t, s, r) } return i.data === "$?" ? (t.flags |= 128, t.child = e.child, t = K1.bind(null, e), i._reactRetry = t, null) : (e = o.treeContext, ze = Jt(i.nextSibling), Ue = t, X = !0, ut = null, e !== null && (Ye[Qe++] = At, Ye[Qe++] = Lt, Ye[Qe++] = An, At = e.id, Lt = e.overflow, An = t), t = Wu(t, r.children), t.flags |= 4096, t) } function Gf(e, t, n) { e.lanes |= t; var r = e.alternate; r !== null && (r.lanes |= t), ml(e.return, t, n) } function ha(e, t, n, r, i) { var o = e.memoizedState; o === null ? e.memoizedState = { isBackwards: t, rendering: null, renderingStartTime: 0, last: r, tail: n, tailMode: i } : (o.isBackwards = t, o.rendering = null, o.renderingStartTime = 0, o.last = r, o.tail = n, o.tailMode = i) } function jm(e, t, n) { var r = t.pendingProps, i = r.revealOrder, o = r.tail; if (Pe(e, t, r.children, n), r = q.current, r & 2) r = r & 1 | 2, t.flags |= 128; else { if (e !== null && e.flags & 128) e: for (e = t.child; e !== null;) { if (e.tag === 13) e.memoizedState !== null && Gf(e, n, t); else if (e.tag === 19) Gf(e, n, t); else if (e.child !== null) { e.child.return = e, e = e.child; continue } if (e === t) break e; for (; e.sibling === null;) { if (e.return === null || e.return === t) break e; e = e.return } e.sibling.return = e.return, e = e.sibling } r &= 1 } if (U(q, r), !(t.mode & 1)) t.memoizedState = null; else switch (i) { case "forwards": for (n = t.child, i = null; n !== null;)e = n.alternate, e !== null && Zo(e) === null && (i = n), n = n.sibling; n = i, n === null ? (i = t.child, t.child = null) : (i = n.sibling, n.sibling = null), ha(t, !1, i, n, o); break; case "backwards": for (n = null, i = t.child, t.child = null; i !== null;) { if (e = i.alternate, e !== null && Zo(e) === null) { t.child = i; break } e = i.sibling, i.sibling = n, n = i, i = e } ha(t, !0, n, null, o); break; case "together": ha(t, !1, null, null, void 0); break; default: t.memoizedState = null }return t.child } function Eo(e, t) { !(t.mode & 1) && e !== null && (e.alternate = null, t.alternate = null, t.flags |= 2) } function Vt(e, t, n) { if (e !== null && (t.dependencies = e.dependencies), Dn |= t.lanes, !(n & t.childLanes)) return null; if (e !== null && t.child !== e.child) throw Error(A(153)); if (t.child !== null) { for (e = t.child, n = nn(e, e.pendingProps), t.child = n, n.return = t; e.sibling !== null;)e = e.sibling, n = n.sibling = nn(e, e.pendingProps), n.return = t; n.sibling = null } return t.child } function N1(e, t, n) { switch (t.tag) { case 3: Im(t), ur(); break; case 5: cm(t); break; case 1: Ne(t.type) && Go(t); break; case 4: Iu(t, t.stateNode.containerInfo); break; case 10: var r = t.type._context, i = t.memoizedProps.value; U(Qo, r._currentValue), r._currentValue = i; break; case 13: if (r = t.memoizedState, r !== null) return r.dehydrated !== null ? (U(q, q.current & 1), t.flags |= 128, null) : n & t.child.childLanes ? Fm(e, t, n) : (U(q, q.current & 1), e = Vt(e, t, n), e !== null ? e.sibling : null); U(q, q.current & 1); break; case 19: if (r = (n & t.childLanes) !== 0, e.flags & 128) { if (r) return jm(e, t, n); t.flags |= 128 } if (i = t.memoizedState, i !== null && (i.rendering = null, i.tail = null, i.lastEffect = null), U(q, q.current), r) break; return null; case 22: case 23: return t.lanes = 0, Nm(e, t, n) }return Vt(e, t, n) } var Bm, Tl, zm, Um; Bm = function (e, t) { for (var n = t.child; n !== null;) { if (n.tag === 5 || n.tag === 6) e.appendChild(n.stateNode); else if (n.tag !== 4 && n.child !== null) { n.child.return = n, n = n.child; continue } if (n === t) break; for (; n.sibling === null;) { if (n.return === null || n.return === t) return; n = n.return } n.sibling.return = n.return, n = n.sibling } }; Tl = function () { }; zm = function (e, t, n, r) { var i = e.memoizedProps; if (i !== r) { e = t.stateNode, Sn(xt.current); var o = null; switch (n) { case "input": i = Ha(e, i), r = Ha(e, r), o = []; break; case "select": i = ee({}, i, { value: void 0 }), r = ee({}, r, { value: void 0 }), o = []; break; case "textarea": i = Xa(e, i), r = Xa(e, r), o = []; break; default: typeof i.onClick != "function" && typeof r.onClick == "function" && (e.onclick = Ho) }Qa(n, r); var s; n = null; for (u in i) if (!r.hasOwnProperty(u) && i.hasOwnProperty(u) && i[u] != null) if (u === "style") { var a = i[u]; for (s in a) a.hasOwnProperty(s) && (n || (n = {}), n[s] = "") } else u !== "dangerouslySetInnerHTML" && u !== "children" && u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && u !== "autoFocus" && (oi.hasOwnProperty(u) ? o || (o = []) : (o = o || []).push(u, null)); for (u in r) { var l = r[u]; if (a = i != null ? i[u] : void 0, r.hasOwnProperty(u) && l !== a && (l != null || a != null)) if (u === "style") if (a) { for (s in a) !a.hasOwnProperty(s) || l && l.hasOwnProperty(s) || (n || (n = {}), n[s] = ""); for (s in l) l.hasOwnProperty(s) && a[s] !== l[s] && (n || (n = {}), n[s] = l[s]) } else n || (o || (o = []), o.push(u, n)), n = l; else u === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, a = a ? a.__html : void 0, l != null && a !== l && (o = o || []).push(u, l)) : u === "children" ? typeof l != "string" && typeof l != "number" || (o = o || []).push(u, "" + l) : u !== "suppressContentEditableWarning" && u !== "suppressHydrationWarning" && (oi.hasOwnProperty(u) ? (l != null && u === "onScroll" && b("scroll", e), o || a === l || (o = [])) : (o = o || []).push(u, l)) } n && (o = o || []).push("style", n); var u = o; (t.updateQueue = u) && (t.flags |= 4) } }; Um = function (e, t, n, r) { n !== r && (t.flags |= 4) }; function Vr(e, t) { if (!X) switch (e.tailMode) { case "hidden": t = e.tail; for (var n = null; t !== null;)t.alternate !== null && (n = t), t = t.sibling; n === null ? e.tail = null : n.sibling = null; break; case "collapsed": n = e.tail; for (var r = null; n !== null;)n.alternate !== null && (r = n), n = n.sibling; r === null ? t || e.tail === null ? e.tail = null : e.tail.sibling = null : r.sibling = null } } function ve(e) { var t = e.alternate !== null && e.alternate.child === e.child, n = 0, r = 0; if (t) for (var i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags & 14680064, r |= i.flags & 14680064, i.return = e, i = i.sibling; else for (i = e.child; i !== null;)n |= i.lanes | i.childLanes, r |= i.subtreeFlags, r |= i.flags, i.return = e, i = i.sibling; return e.subtreeFlags |= r, e.childLanes = n, t } function V1(e, t, n) { var r = t.pendingProps; switch (Lu(t), t.tag) { case 2: case 16: case 15: case 0: case 11: case 7: case 8: case 12: case 9: case 14: return ve(t), null; case 1: return Ne(t.type) && Ko(), ve(t), null; case 3: return r = t.stateNode, fr(), W(Oe), W(Ee), ju(), r.pendingContext && (r.context = r.pendingContext, r.pendingContext = null), (e === null || e.child === null) && (to(t) ? t.flags |= 4 : e === null || e.memoizedState.isDehydrated && !(t.flags & 256) || (t.flags |= 1024, ut !== null && (_l(ut), ut = null))), Tl(e, t), ve(t), null; case 5: Fu(t); var i = Sn(gi.current); if (n = t.type, e !== null && t.stateNode != null) zm(e, t, n, r, i), e.ref !== t.ref && (t.flags |= 512, t.flags |= 2097152); else { if (!r) { if (t.stateNode === null) throw Error(A(166)); return ve(t), null } if (e = Sn(xt.current), to(t)) { r = t.stateNode, n = t.type; var o = t.memoizedProps; switch (r[wt] = t, r[mi] = o, e = (t.mode & 1) !== 0, n) { case "dialog": b("cancel", r), b("close", r); break; case "iframe": case "object": case "embed": b("load", r); break; case "video": case "audio": for (i = 0; i < br.length; i++)b(br[i], r); break; case "source": b("error", r); break; case "img": case "image": case "link": b("error", r), b("load", r); break; case "details": b("toggle", r); break; case "input": tf(r, o), b("invalid", r); break; case "select": r._wrapperState = { wasMultiple: !!o.multiple }, b("invalid", r); break; case "textarea": rf(r, o), b("invalid", r) }Qa(n, o), i = null; for (var s in o) if (o.hasOwnProperty(s)) { var a = o[s]; s === "children" ? typeof a == "string" ? r.textContent !== a && (o.suppressHydrationWarning !== !0 && eo(r.textContent, a, e), i = ["children", a]) : typeof a == "number" && r.textContent !== "" + a && (o.suppressHydrationWarning !== !0 && eo(r.textContent, a, e), i = ["children", "" + a]) : oi.hasOwnProperty(s) && a != null && s === "onScroll" && b("scroll", r) } switch (n) { case "input": Ki(r), nf(r, o, !0); break; case "textarea": Ki(r), of(r); break; case "select": case "option": break; default: typeof o.onClick == "function" && (r.onclick = Ho) }r = i, t.updateQueue = r, r !== null && (t.flags |= 4) } else { s = i.nodeType === 9 ? i : i.ownerDocument, e === "http://www.w3.org/1999/xhtml" && (e = mp(n)), e === "http://www.w3.org/1999/xhtml" ? n === "script" ? (e = s.createElement("div"), e.innerHTML = "<script><\/script>", e = e.removeChild(e.firstChild)) : typeof r.is == "string" ? e = s.createElement(n, { is: r.is }) : (e = s.createElement(n), n === "select" && (s = e, r.multiple ? s.multiple = !0 : r.size && (s.size = r.size))) : e = s.createElementNS(e, n), e[wt] = t, e[mi] = r, Bm(e, t, !1, !1), t.stateNode = e; e: { switch (s = qa(n, r), n) { case "dialog": b("cancel", e), b("close", e), i = r; break; case "iframe": case "object": case "embed": b("load", e), i = r; break; case "video": case "audio": for (i = 0; i < br.length; i++)b(br[i], e); i = r; break; case "source": b("error", e), i = r; break; case "img": case "image": case "link": b("error", e), b("load", e), i = r; break; case "details": b("toggle", e), i = r; break; case "input": tf(e, r), i = Ha(e, r), b("invalid", e); break; case "option": i = r; break; case "select": e._wrapperState = { wasMultiple: !!r.multiple }, i = ee({}, r, { value: void 0 }), b("invalid", e); break; case "textarea": rf(e, r), i = Xa(e, r), b("invalid", e); break; default: i = r }Qa(n, i), a = i; for (o in a) if (a.hasOwnProperty(o)) { var l = a[o]; o === "style" ? vp(e, l) : o === "dangerouslySetInnerHTML" ? (l = l ? l.__html : void 0, l != null && yp(e, l)) : o === "children" ? typeof l == "string" ? (n !== "textarea" || l !== "") && si(e, l) : typeof l == "number" && si(e, "" + l) : o !== "suppressContentEditableWarning" && o !== "suppressHydrationWarning" && o !== "autoFocus" && (oi.hasOwnProperty(o) ? l != null && o === "onScroll" && b("scroll", e) : l != null && pu(e, o, l, s)) } switch (n) { case "input": Ki(e), nf(e, r, !1); break; case "textarea": Ki(e), of(e); break; case "option": r.value != null && e.setAttribute("value", "" + rn(r.value)); break; case "select": e.multiple = !!r.multiple, o = r.value, o != null ? er(e, !!r.multiple, o, !1) : r.defaultValue != null && er(e, !!r.multiple, r.defaultValue, !0); break; default: typeof i.onClick == "function" && (e.onclick = Ho) }switch (n) { case "button": case "input": case "select": case "textarea": r = !!r.autoFocus; break e; case "img": r = !0; break e; default: r = !1 } } r && (t.flags |= 4) } t.ref !== null && (t.flags |= 512, t.flags |= 2097152) } return ve(t), null; case 6: if (e && t.stateNode != null) Um(e, t, e.memoizedProps, r); else { if (typeof r != "string" && t.stateNode === null) throw Error(A(166)); if (n = Sn(gi.current), Sn(xt.current), to(t)) { if (r = t.stateNode, n = t.memoizedProps, r[wt] = t, (o = r.nodeValue !== n) && (e = Ue, e !== null)) switch (e.tag) { case 3: eo(r.nodeValue, n, (e.mode & 1) !== 0); break; case 5: e.memoizedProps.suppressHydrationWarning !== !0 && eo(r.nodeValue, n, (e.mode & 1) !== 0) }o && (t.flags |= 4) } else r = (n.nodeType === 9 ? n : n.ownerDocument).createTextNode(r), r[wt] = t, t.stateNode = r } return ve(t), null; case 13: if (W(q), r = t.memoizedState, e === null || e.memoizedState !== null && e.memoizedState.dehydrated !== null) { if (X && ze !== null && t.mode & 1 && !(t.flags & 128)) om(), ur(), t.flags |= 98560, o = !1; else if (o = to(t), r !== null && r.dehydrated !== null) { if (e === null) { if (!o) throw Error(A(318)); if (o = t.memoizedState, o = o !== null ? o.dehydrated : null, !o) throw Error(A(317)); o[wt] = t } else ur(), !(t.flags & 128) && (t.memoizedState = null), t.flags |= 4; ve(t), o = !1 } else ut !== null && (_l(ut), ut = null), o = !0; if (!o) return t.flags & 65536 ? t : null } return t.flags & 128 ? (t.lanes = n, t) : (r = r !== null, r !== (e !== null && e.memoizedState !== null) && r && (t.child.flags |= 8192, t.mode & 1 && (e === null || q.current & 1 ? ue === 0 && (ue = 3) : Qu())), t.updateQueue !== null && (t.flags |= 4), ve(t), null); case 4: return fr(), Tl(e, t), e === null && hi(t.stateNode.containerInfo), ve(t), null; case 10: return Ou(t.type._context), ve(t), null; case 17: return Ne(t.type) && Ko(), ve(t), null; case 19: if (W(q), o = t.memoizedState, o === null) return ve(t), null; if (r = (t.flags & 128) !== 0, s = o.rendering, s === null) if (r) Vr(o, !1); else { if (ue !== 0 || e !== null && e.flags & 128) for (e = t.child; e !== null;) { if (s = Zo(e), s !== null) { for (t.flags |= 128, Vr(o, !1), r = s.updateQueue, r !== null && (t.updateQueue = r, t.flags |= 4), t.subtreeFlags = 0, r = n, n = t.child; n !== null;)o = n, e = r, o.flags &= 14680066, s = o.alternate, s === null ? (o.childLanes = 0, o.lanes = e, o.child = null, o.subtreeFlags = 0, o.memoizedProps = null, o.memoizedState = null, o.updateQueue = null, o.dependencies = null, o.stateNode = null) : (o.childLanes = s.childLanes, o.lanes = s.lanes, o.child = s.child, o.subtreeFlags = 0, o.deletions = null, o.memoizedProps = s.memoizedProps, o.memoizedState = s.memoizedState, o.updateQueue = s.updateQueue, o.type = s.type, e = s.dependencies, o.dependencies = e === null ? null : { lanes: e.lanes, firstContext: e.firstContext }), n = n.sibling; return U(q, q.current & 1 | 2), t.child } e = e.sibling } o.tail !== null && ne() > hr && (t.flags |= 128, r = !0, Vr(o, !1), t.lanes = 4194304) } else { if (!r) if (e = Zo(s), e !== null) { if (t.flags |= 128, r = !0, n = e.updateQueue, n !== null && (t.updateQueue = n, t.flags |= 4), Vr(o, !0), o.tail === null && o.tailMode === "hidden" && !s.alternate && !X) return ve(t), null } else 2 * ne() - o.renderingStartTime > hr && n !== 1073741824 && (t.flags |= 128, r = !0, Vr(o, !1), t.lanes = 4194304); o.isBackwards ? (s.sibling = t.child, t.child = s) : (n = o.last, n !== null ? n.sibling = s : t.child = s, o.last = s) } return o.tail !== null ? (t = o.tail, o.rendering = t, o.tail = t.sibling, o.renderingStartTime = ne(), t.sibling = null, n = q.current, U(q, r ? n & 1 | 2 : n & 1), t) : (ve(t), null); case 22: case 23: return Yu(), r = t.memoizedState !== null, e !== null && e.memoizedState !== null !== r && (t.flags |= 8192), r && t.mode & 1 ? Be & 1073741824 && (ve(t), t.subtreeFlags & 6 && (t.flags |= 8192)) : ve(t), null; case 24: return null; case 25: return null }throw Error(A(156, t.tag)) } function I1(e, t) { switch (Lu(t), t.tag) { case 1: return Ne(t.type) && Ko(), e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 3: return fr(), W(Oe), W(Ee), ju(), e = t.flags, e & 65536 && !(e & 128) ? (t.flags = e & -65537 | 128, t) : null; case 5: return Fu(t), null; case 13: if (W(q), e = t.memoizedState, e !== null && e.dehydrated !== null) { if (t.alternate === null) throw Error(A(340)); ur() } return e = t.flags, e & 65536 ? (t.flags = e & -65537 | 128, t) : null; case 19: return W(q), null; case 4: return fr(), null; case 10: return Ou(t.type._context), null; case 22: case 23: return Yu(), null; case 24: return null; default: return null } } var io = !1, we = !1, F1 = typeof WeakSet == "function" ? WeakSet : Set, _ = null; function Xn(e, t) { var n = e.ref; if (n !== null) if (typeof n == "function") try { n(null) } catch (r) { te(e, t, r) } else n.current = null } function Cl(e, t, n) { try { n() } catch (r) { te(e, t, r) } } var Xf = !1; function j1(e, t) { if (al = $o, e = Kp(), Ru(e)) { if ("selectionStart" in e) var n = { start: e.selectionStart, end: e.selectionEnd }; else e: { n = (n = e.ownerDocument) && n.defaultView || window; var r = n.getSelection && n.getSelection(); if (r && r.rangeCount !== 0) { n = r.anchorNode; var i = r.anchorOffset, o = r.focusNode; r = r.focusOffset; try { n.nodeType, o.nodeType } catch { n = null; break e } var s = 0, a = -1, l = -1, u = 0, c = 0, f = e, d = null; t: for (; ;) { for (var g; f !== n || i !== 0 && f.nodeType !== 3 || (a = s + i), f !== o || r !== 0 && f.nodeType !== 3 || (l = s + r), f.nodeType === 3 && (s += f.nodeValue.length), (g = f.firstChild) !== null;)d = f, f = g; for (; ;) { if (f === e) break t; if (d === n && ++u === i && (a = s), d === o && ++c === r && (l = s), (g = f.nextSibling) !== null) break; f = d, d = f.parentNode } f = g } n = a === -1 || l === -1 ? null : { start: a, end: l } } else n = null } n = n || { start: 0, end: 0 } } else n = null; for (ll = { focusedElem: e, selectionRange: n }, $o = !1, _ = t; _ !== null;)if (t = _, e = t.child, (t.subtreeFlags & 1028) !== 0 && e !== null) e.return = t, _ = e; else for (; _ !== null;) { t = _; try { var y = t.alternate; if (t.flags & 1024) switch (t.tag) { case 0: case 11: case 15: break; case 1: if (y !== null) { var v = y.memoizedProps, S = y.memoizedState, p = t.stateNode, h = p.getSnapshotBeforeUpdate(t.elementType === t.type ? v : at(t.type, v), S); p.__reactInternalSnapshotBeforeUpdate = h } break; case 3: var m = t.stateNode.containerInfo; m.nodeType === 1 ? m.textContent = "" : m.nodeType === 9 && m.documentElement && m.removeChild(m.documentElement); break; case 5: case 6: case 4: case 17: break; default: throw Error(A(163)) } } catch (x) { te(t, t.return, x) } if (e = t.sibling, e !== null) { e.return = t.return, _ = e; break } _ = t.return } return y = Xf, Xf = !1, y } function Jr(e, t, n) { var r = t.updateQueue; if (r = r !== null ? r.lastEffect : null, r !== null) { var i = r = r.next; do { if ((i.tag & e) === e) { var o = i.destroy; i.destroy = void 0, o !== void 0 && Cl(t, n, o) } i = i.next } while (i !== r) } } function Ps(e, t) { if (t = t.updateQueue, t = t !== null ? t.lastEffect : null, t !== null) { var n = t = t.next; do { if ((n.tag & e) === e) { var r = n.create; n.destroy = r() } n = n.next } while (n !== t) } } function Pl(e) { var t = e.ref; if (t !== null) { var n = e.stateNode; switch (e.tag) { case 5: e = n; break; default: e = n }typeof t == "function" ? t(e) : t.current = e } } function $m(e) { var t = e.alternate; t !== null && (e.alternate = null, $m(t)), e.child = null, e.deletions = null, e.sibling = null, e.tag === 5 && (t = e.stateNode, t !== null && (delete t[wt], delete t[mi], delete t[fl], delete t[S1], delete t[x1])), e.stateNode = null, e.return = null, e.dependencies = null, e.memoizedProps = null, e.memoizedState = null, e.pendingProps = null, e.stateNode = null, e.updateQueue = null } function bm(e) { return e.tag === 5 || e.tag === 3 || e.tag === 4 } function Yf(e) { e: for (; ;) { for (; e.sibling === null;) { if (e.return === null || bm(e.return)) return null; e = e.return } for (e.sibling.return = e.return, e = e.sibling; e.tag !== 5 && e.tag !== 6 && e.tag !== 18;) { if (e.flags & 2 || e.child === null || e.tag === 4) continue e; e.child.return = e, e = e.child } if (!(e.flags & 2)) return e.stateNode } } function kl(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.nodeType === 8 ? n.parentNode.insertBefore(e, t) : n.insertBefore(e, t) : (n.nodeType === 8 ? (t = n.parentNode, t.insertBefore(e, n)) : (t = n, t.appendChild(e)), n = n._reactRootContainer, n != null || t.onclick !== null || (t.onclick = Ho)); else if (r !== 4 && (e = e.child, e !== null)) for (kl(e, t, n), e = e.sibling; e !== null;)kl(e, t, n), e = e.sibling } function Rl(e, t, n) { var r = e.tag; if (r === 5 || r === 6) e = e.stateNode, t ? n.insertBefore(e, t) : n.appendChild(e); else if (r !== 4 && (e = e.child, e !== null)) for (Rl(e, t, n), e = e.sibling; e !== null;)Rl(e, t, n), e = e.sibling } var he = null, lt = !1; function zt(e, t, n) { for (n = n.child; n !== null;)Wm(e, t, n), n = n.sibling } function Wm(e, t, n) { if (St && typeof St.onCommitFiberUnmount == "function") try { St.onCommitFiberUnmount(gs, n) } catch { } switch (n.tag) { case 5: we || Xn(n, t); case 6: var r = he, i = lt; he = null, zt(e, t, n), he = r, lt = i, he !== null && (lt ? (e = he, n = n.stateNode, e.nodeType === 8 ? e.parentNode.removeChild(n) : e.removeChild(n)) : he.removeChild(n.stateNode)); break; case 18: he !== null && (lt ? (e = he, n = n.stateNode, e.nodeType === 8 ? sa(e.parentNode, n) : e.nodeType === 1 && sa(e, n), ci(e)) : sa(he, n.stateNode)); break; case 4: r = he, i = lt, he = n.stateNode.containerInfo, lt = !0, zt(e, t, n), he = r, lt = i; break; case 0: case 11: case 14: case 15: if (!we && (r = n.updateQueue, r !== null && (r = r.lastEffect, r !== null))) { i = r = r.next; do { var o = i, s = o.destroy; o = o.tag, s !== void 0 && (o & 2 || o & 4) && Cl(n, t, s), i = i.next } while (i !== r) } zt(e, t, n); break; case 1: if (!we && (Xn(n, t), r = n.stateNode, typeof r.componentWillUnmount == "function")) try { r.props = n.memoizedProps, r.state = n.memoizedState, r.componentWillUnmount() } catch (a) { te(n, t, a) } zt(e, t, n); break; case 21: zt(e, t, n); break; case 22: n.mode & 1 ? (we = (r = we) || n.memoizedState !== null, zt(e, t, n), we = r) : zt(e, t, n); break; default: zt(e, t, n) } } function Qf(e) { var t = e.updateQueue; if (t !== null) { e.updateQueue = null; var n = e.stateNode; n === null && (n = e.stateNode = new F1), t.forEach(function (r) { var i = G1.bind(null, e, r); n.has(r) || (n.add(r), r.then(i, i)) }) } } function rt(e, t) { var n = t.deletions; if (n !== null) for (var r = 0; r < n.length; r++) { var i = n[r]; try { var o = e, s = t, a = s; e: for (; a !== null;) { switch (a.tag) { case 5: he = a.stateNode, lt = !1; break e; case 3: he = a.stateNode.containerInfo, lt = !0; break e; case 4: he = a.stateNode.containerInfo, lt = !0; break e }a = a.return } if (he === null) throw Error(A(160)); Wm(o, s, i), he = null, lt = !1; var l = i.alternate; l !== null && (l.return = null), i.return = null } catch (u) { te(i, t, u) } } if (t.subtreeFlags & 12854) for (t = t.child; t !== null;)Hm(t, e), t = t.sibling } function Hm(e, t) { var n = e.alternate, r = e.flags; switch (e.tag) { case 0: case 11: case 14: case 15: if (rt(t, e), yt(e), r & 4) { try { Jr(3, e, e.return), Ps(3, e) } catch (v) { te(e, e.return, v) } try { Jr(5, e, e.return) } catch (v) { te(e, e.return, v) } } break; case 1: rt(t, e), yt(e), r & 512 && n !== null && Xn(n, n.return); break; case 5: if (rt(t, e), yt(e), r & 512 && n !== null && Xn(n, n.return), e.flags & 32) { var i = e.stateNode; try { si(i, "") } catch (v) { te(e, e.return, v) } } if (r & 4 && (i = e.stateNode, i != null)) { var o = e.memoizedProps, s = n !== null ? n.memoizedProps : o, a = e.type, l = e.updateQueue; if (e.updateQueue = null, l !== null) try { a === "input" && o.type === "radio" && o.name != null && hp(i, o), qa(a, s); var u = qa(a, o); for (s = 0; s < l.length; s += 2) { var c = l[s], f = l[s + 1]; c === "style" ? vp(i, f) : c === "dangerouslySetInnerHTML" ? yp(i, f) : c === "children" ? si(i, f) : pu(i, c, f, u) } switch (a) { case "input": Ka(i, o); break; case "textarea": pp(i, o); break; case "select": var d = i._wrapperState.wasMultiple; i._wrapperState.wasMultiple = !!o.multiple; var g = o.value; g != null ? er(i, !!o.multiple, g, !1) : d !== !!o.multiple && (o.defaultValue != null ? er(i, !!o.multiple, o.defaultValue, !0) : er(i, !!o.multiple, o.multiple ? [] : "", !1)) }i[mi] = o } catch (v) { te(e, e.return, v) } } break; case 6: if (rt(t, e), yt(e), r & 4) { if (e.stateNode === null) throw Error(A(162)); i = e.stateNode, o = e.memoizedProps; try { i.nodeValue = o } catch (v) { te(e, e.return, v) } } break; case 3: if (rt(t, e), yt(e), r & 4 && n !== null && n.memoizedState.isDehydrated) try { ci(t.containerInfo) } catch (v) { te(e, e.return, v) } break; case 4: rt(t, e), yt(e); break; case 13: rt(t, e), yt(e), i = e.child, i.flags & 8192 && (o = i.memoizedState !== null, i.stateNode.isHidden = o, !o || i.alternate !== null && i.alternate.memoizedState !== null || (Gu = ne())), r & 4 && Qf(e); break; case 22: if (c = n !== null && n.memoizedState !== null, e.mode & 1 ? (we = (u = we) || c, rt(t, e), we = u) : rt(t, e), yt(e), r & 8192) { if (u = e.memoizedState !== null, (e.stateNode.isHidden = u) && !c && e.mode & 1) for (_ = e, c = e.child; c !== null;) { for (f = _ = c; _ !== null;) { switch (d = _, g = d.child, d.tag) { case 0: case 11: case 14: case 15: Jr(4, d, d.return); break; case 1: Xn(d, d.return); var y = d.stateNode; if (typeof y.componentWillUnmount == "function") { r = d, n = d.return; try { t = r, y.props = t.memoizedProps, y.state = t.memoizedState, y.componentWillUnmount() } catch (v) { te(r, n, v) } } break; case 5: Xn(d, d.return); break; case 22: if (d.memoizedState !== null) { Jf(f); continue } }g !== null ? (g.return = d, _ = g) : Jf(f) } c = c.sibling } e: for (c = null, f = e; ;) { if (f.tag === 5) { if (c === null) { c = f; try { i = f.stateNode, u ? (o = i.style, typeof o.setProperty == "function" ? o.setProperty("display", "none", "important") : o.display = "none") : (a = f.stateNode, l = f.memoizedProps.style, s = l != null && l.hasOwnProperty("display") ? l.display : null, a.style.display = gp("display", s)) } catch (v) { te(e, e.return, v) } } } else if (f.tag === 6) { if (c === null) try { f.stateNode.nodeValue = u ? "" : f.memoizedProps } catch (v) { te(e, e.return, v) } } else if ((f.tag !== 22 && f.tag !== 23 || f.memoizedState === null || f === e) && f.child !== null) { f.child.return = f, f = f.child; continue } if (f === e) break e; for (; f.sibling === null;) { if (f.return === null || f.return === e) break e; c === f && (c = null), f = f.return } c === f && (c = null), f.sibling.return = f.return, f = f.sibling } } break; case 19: rt(t, e), yt(e), r & 4 && Qf(e); break; case 21: break; default: rt(t, e), yt(e) } } function yt(e) { var t = e.flags; if (t & 2) { try { e: { for (var n = e.return; n !== null;) { if (bm(n)) { var r = n; break e } n = n.return } throw Error(A(160)) } switch (r.tag) { case 5: var i = r.stateNode; r.flags & 32 && (si(i, ""), r.flags &= -33); var o = Yf(e); Rl(e, o, i); break; case 3: case 4: var s = r.stateNode.containerInfo, a = Yf(e); kl(e, a, s); break; default: throw Error(A(161)) } } catch (l) { te(e, e.return, l) } e.flags &= -3 } t & 4096 && (e.flags &= -4097) } function B1(e, t, n) { _ = e, Km(e) } function Km(e, t, n) { for (var r = (e.mode & 1) !== 0; _ !== null;) { var i = _, o = i.child; if (i.tag === 22 && r) { var s = i.memoizedState !== null || io; if (!s) { var a = i.alternate, l = a !== null && a.memoizedState !== null || we; a = io; var u = we; if (io = s, (we = l) && !u) for (_ = i; _ !== null;)s = _, l = s.child, s.tag === 22 && s.memoizedState !== null ? Zf(i) : l !== null ? (l.return = s, _ = l) : Zf(i); for (; o !== null;)_ = o, Km(o), o = o.sibling; _ = i, io = a, we = u } qf(e) } else i.subtreeFlags & 8772 && o !== null ? (o.return = i, _ = o) : qf(e) } } function qf(e) { for (; _ !== null;) { var t = _; if (t.flags & 8772) { var n = t.alternate; try { if (t.flags & 8772) switch (t.tag) { case 0: case 11: case 15: we || Ps(5, t); break; case 1: var r = t.stateNode; if (t.flags & 4 && !we) if (n === null) r.componentDidMount(); else { var i = t.elementType === t.type ? n.memoizedProps : at(t.type, n.memoizedProps); r.componentDidUpdate(i, n.memoizedState, r.__reactInternalSnapshotBeforeUpdate) } var o = t.updateQueue; o !== null && Vf(t, o, r); break; case 3: var s = t.updateQueue; if (s !== null) { if (n = null, t.child !== null) switch (t.child.tag) { case 5: n = t.child.stateNode; break; case 1: n = t.child.stateNode }Vf(t, s, n) } break; case 5: var a = t.stateNode; if (n === null && t.flags & 4) { n = a; var l = t.memoizedProps; switch (t.type) { case "button": case "input": case "select": case "textarea": l.autoFocus && n.focus(); break; case "img": l.src && (n.src = l.src) } } break; case 6: break; case 4: break; case 12: break; case 13: if (t.memoizedState === null) { var u = t.alternate; if (u !== null) { var c = u.memoizedState; if (c !== null) { var f = c.dehydrated; f !== null && ci(f) } } } break; case 19: case 17: case 21: case 22: case 23: case 25: break; default: throw Error(A(163)) }we || t.flags & 512 && Pl(t) } catch (d) { te(t, t.return, d) } } if (t === e) { _ = null; break } if (n = t.sibling, n !== null) { n.return = t.return, _ = n; break } _ = t.return } } function Jf(e) { for (; _ !== null;) { var t = _; if (t === e) { _ = null; break } var n = t.sibling; if (n !== null) { n.return = t.return, _ = n; break } _ = t.return } } function Zf(e) { for (; _ !== null;) { var t = _; try { switch (t.tag) { case 0: case 11: case 15: var n = t.return; try { Ps(4, t) } catch (l) { te(t, n, l) } break; case 1: var r = t.stateNode; if (typeof r.componentDidMount == "function") { var i = t.return; try { r.componentDidMount() } catch (l) { te(t, i, l) } } var o = t.return; try { Pl(t) } catch (l) { te(t, o, l) } break; case 5: var s = t.return; try { Pl(t) } catch (l) { te(t, s, l) } } } catch (l) { te(t, t.return, l) } if (t === e) { _ = null; break } var a = t.sibling; if (a !== null) { a.return = t.return, _ = a; break } _ = t.return } } var z1 = Math.ceil, ns = jt.ReactCurrentDispatcher, Hu = jt.ReactCurrentOwner, Ze = jt.ReactCurrentBatchConfig, j = 0, fe = null, ie = null, me = 0, Be = 0, Yn = un(0), ue = 0, xi = null, Dn = 0, ks = 0, Ku = 0, Zr = null, _e = null, Gu = 0, hr = 1 / 0, kt = null, rs = !1, Al = null, en = null, oo = !1, Gt = null, is = 0, ei = 0, Ll = null, To = -1, Co = 0; function Ae() { return j & 6 ? ne() : To !== -1 ? To : To = ne() } function tn(e) { return e.mode & 1 ? j & 2 && me !== 0 ? me & -me : T1.transition !== null ? (Co === 0 && (Co = Dp()), Co) : (e = z, e !== 0 || (e = window.event, e = e === void 0 ? 16 : Fp(e.type)), e) : 1 } function ft(e, t, n, r) { if (50 < ei) throw ei = 0, Ll = null, Error(A(185)); Li(e, n, r), (!(j & 2) || e !== fe) && (e === fe && (!(j & 2) && (ks |= n), ue === 4 && Ht(e, me)), Ve(e, r), n === 1 && j === 0 && !(t.mode & 1) && (hr = ne() + 500, Es && cn())) } function Ve(e, t) { var n = e.callbackNode; Tv(e, t); var r = Uo(e, e === fe ? me : 0); if (r === 0) n !== null && lf(n), e.callbackNode = null, e.callbackPriority = 0; else if (t = r & -r, e.callbackPriority !== t) { if (n != null && lf(n), t === 1) e.tag === 0 ? E1(ed.bind(null, e)) : nm(ed.bind(null, e)), v1(function () { !(j & 6) && cn() }), n = null; else { switch (_p(r)) { case 1: n = wu; break; case 4: n = Ap; break; case 16: n = zo; break; case 536870912: n = Lp; break; default: n = zo }n = ey(n, Gm.bind(null, e)) } e.callbackPriority = t, e.callbackNode = n } } function Gm(e, t) { if (To = -1, Co = 0, j & 6) throw Error(A(327)); var n = e.callbackNode; if (or() && e.callbackNode !== n) return null; var r = Uo(e, e === fe ? me : 0); if (r === 0) return null; if (r & 30 || r & e.expiredLanes || t) t = os(e, r); else { t = r; var i = j; j |= 2; var o = Ym(); (fe !== e || me !== t) && (kt = null, hr = ne() + 500, Cn(e, t)); do try { b1(); break } catch (a) { Xm(e, a) } while (1); Mu(), ns.current = o, j = i, ie !== null ? t = 0 : (fe = null, me = 0, t = ue) } if (t !== 0) { if (t === 2 && (i = nl(e), i !== 0 && (r = i, t = Dl(e, i))), t === 1) throw n = xi, Cn(e, 0), Ht(e, r), Ve(e, ne()), n; if (t === 6) Ht(e, r); else { if (i = e.current.alternate, !(r & 30) && !U1(i) && (t = os(e, r), t === 2 && (o = nl(e), o !== 0 && (r = o, t = Dl(e, o))), t === 1)) throw n = xi, Cn(e, 0), Ht(e, r), Ve(e, ne()), n; switch (e.finishedWork = i, e.finishedLanes = r, t) { case 0: case 1: throw Error(A(345)); case 2: yn(e, _e, kt); break; case 3: if (Ht(e, r), (r & 130023424) === r && (t = Gu + 500 - ne(), 10 < t)) { if (Uo(e, 0) !== 0) break; if (i = e.suspendedLanes, (i & r) !== r) { Ae(), e.pingedLanes |= e.suspendedLanes & i; break } e.timeoutHandle = cl(yn.bind(null, e, _e, kt), t); break } yn(e, _e, kt); break; case 4: if (Ht(e, r), (r & 4194240) === r) break; for (t = e.eventTimes, i = -1; 0 < r;) { var s = 31 - ct(r); o = 1 << s, s = t[s], s > i && (i = s), r &= ~o } if (r = i, r = ne() - r, r = (120 > r ? 120 : 480 > r ? 480 : 1080 > r ? 1080 : 1920 > r ? 1920 : 3e3 > r ? 3e3 : 4320 > r ? 4320 : 1960 * z1(r / 1960)) - r, 10 < r) { e.timeoutHandle = cl(yn.bind(null, e, _e, kt), r); break } yn(e, _e, kt); break; case 5: yn(e, _e, kt); break; default: throw Error(A(329)) } } } return Ve(e, ne()), e.callbackNode === n ? Gm.bind(null, e) : null } function Dl(e, t) { var n = Zr; return e.current.memoizedState.isDehydrated && (Cn(e, t).flags |= 256), e = os(e, t), e !== 2 && (t = _e, _e = n, t !== null && _l(t)), e } function _l(e) { _e === null ? _e = e : _e.push.apply(_e, e) } function U1(e) { for (var t = e; ;) { if (t.flags & 16384) { var n = t.updateQueue; if (n !== null && (n = n.stores, n !== null)) for (var r = 0; r < n.length; r++) { var i = n[r], o = i.getSnapshot; i = i.value; try { if (!ht(o(), i)) return !1 } catch { return !1 } } } if (n = t.child, t.subtreeFlags & 16384 && n !== null) n.return = t, t = n; else { if (t === e) break; for (; t.sibling === null;) { if (t.return === null || t.return === e) return !0; t = t.return } t.sibling.return = t.return, t = t.sibling } } return !0 } function Ht(e, t) { for (t &= ~Ku, t &= ~ks, e.suspendedLanes |= t, e.pingedLanes &= ~t, e = e.expirationTimes; 0 < t;) { var n = 31 - ct(t), r = 1 << n; e[n] = -1, t &= ~r } } function ed(e) { if (j & 6) throw Error(A(327)); or(); var t = Uo(e, 0); if (!(t & 1)) return Ve(e, ne()), null; var n = os(e, t); if (e.tag !== 0 && n === 2) { var r = nl(e); r !== 0 && (t = r, n = Dl(e, r)) } if (n === 1) throw n = xi, Cn(e, 0), Ht(e, t), Ve(e, ne()), n; if (n === 6) throw Error(A(345)); return e.finishedWork = e.current.alternate, e.finishedLanes = t, yn(e, _e, kt), Ve(e, ne()), null } function Xu(e, t) { var n = j; j |= 1; try { return e(t) } finally { j = n, j === 0 && (hr = ne() + 500, Es && cn()) } } function _n(e) { Gt !== null && Gt.tag === 0 && !(j & 6) && or(); var t = j; j |= 1; var n = Ze.transition, r = z; try { if (Ze.transition = null, z = 1, e) return e() } finally { z = r, Ze.transition = n, j = t, !(j & 6) && cn() } } function Yu() { Be = Yn.current, W(Yn) } function Cn(e, t) { e.finishedWork = null, e.finishedLanes = 0; var n = e.timeoutHandle; if (n !== -1 && (e.timeoutHandle = -1, g1(n)), ie !== null) for (n = ie.return; n !== null;) { var r = n; switch (Lu(r), r.tag) { case 1: r = r.type.childContextTypes, r != null && Ko(); break; case 3: fr(), W(Oe), W(Ee), ju(); break; case 5: Fu(r); break; case 4: fr(); break; case 13: W(q); break; case 19: W(q); break; case 10: Ou(r.type._context); break; case 22: case 23: Yu() }n = n.return } if (fe = e, ie = e = nn(e.current, null), me = Be = t, ue = 0, xi = null, Ku = ks = Dn = 0, _e = Zr = null, wn !== null) { for (t = 0; t < wn.length; t++)if (n = wn[t], r = n.interleaved, r !== null) { n.interleaved = null; var i = r.next, o = n.pending; if (o !== null) { var s = o.next; o.next = i, r.next = s } n.pending = r } wn = null } return e } function Xm(e, t) { do { var n = ie; try { if (Mu(), So.current = ts, es) { for (var r = Z.memoizedState; r !== null;) { var i = r.queue; i !== null && (i.pending = null), r = r.next } es = !1 } if (Ln = 0, ce = le = Z = null, qr = !1, vi = 0, Hu.current = null, n === null || n.return === null) { ue = 1, xi = t, ie = null; break } e: { var o = e, s = n.return, a = n, l = t; if (t = me, a.flags |= 32768, l !== null && typeof l == "object" && typeof l.then == "function") { var u = l, c = a, f = c.tag; if (!(c.mode & 1) && (f === 0 || f === 11 || f === 15)) { var d = c.alternate; d ? (c.updateQueue = d.updateQueue, c.memoizedState = d.memoizedState, c.lanes = d.lanes) : (c.updateQueue = null, c.memoizedState = null) } var g = Uf(s); if (g !== null) { g.flags &= -257, $f(g, s, a, o, t), g.mode & 1 && zf(o, u, t), t = g, l = u; var y = t.updateQueue; if (y === null) { var v = new Set; v.add(l), t.updateQueue = v } else y.add(l); break e } else { if (!(t & 1)) { zf(o, u, t), Qu(); break e } l = Error(A(426)) } } else if (X && a.mode & 1) { var S = Uf(s); if (S !== null) { !(S.flags & 65536) && (S.flags |= 256), $f(S, s, a, o, t), Du(dr(l, a)); break e } } o = l = dr(l, a), ue !== 4 && (ue = 2), Zr === null ? Zr = [o] : Zr.push(o), o = s; do { switch (o.tag) { case 3: o.flags |= 65536, t &= -t, o.lanes |= t; var p = _m(o, l, t); Nf(o, p); break e; case 1: a = l; var h = o.type, m = o.stateNode; if (!(o.flags & 128) && (typeof h.getDerivedStateFromError == "function" || m !== null && typeof m.componentDidCatch == "function" && (en === null || !en.has(m)))) { o.flags |= 65536, t &= -t, o.lanes |= t; var x = Mm(o, a, t); Nf(o, x); break e } }o = o.return } while (o !== null) } qm(n) } catch (E) { t = E, ie === n && n !== null && (ie = n = n.return); continue } break } while (1) } function Ym() { var e = ns.current; return ns.current = ts, e === null ? ts : e } function Qu() { (ue === 0 || ue === 3 || ue === 2) && (ue = 4), fe === null || !(Dn & 268435455) && !(ks & 268435455) || Ht(fe, me) } function os(e, t) { var n = j; j |= 2; var r = Ym(); (fe !== e || me !== t) && (kt = null, Cn(e, t)); do try { $1(); break } catch (i) { Xm(e, i) } while (1); if (Mu(), j = n, ns.current = r, ie !== null) throw Error(A(261)); return fe = null, me = 0, ue } function $1() { for (; ie !== null;)Qm(ie) } function b1() { for (; ie !== null && !pv();)Qm(ie) } function Qm(e) { var t = Zm(e.alternate, e, Be); e.memoizedProps = e.pendingProps, t === null ? qm(e) : ie = t, Hu.current = null } function qm(e) { var t = e; do { var n = t.alternate; if (e = t.return, t.flags & 32768) { if (n = I1(n, t), n !== null) { n.flags &= 32767, ie = n; return } if (e !== null) e.flags |= 32768, e.subtreeFlags = 0, e.deletions = null; else { ue = 6, ie = null; return } } else if (n = V1(n, t, Be), n !== null) { ie = n; return } if (t = t.sibling, t !== null) { ie = t; return } ie = t = e } while (t !== null); ue === 0 && (ue = 5) } function yn(e, t, n) { var r = z, i = Ze.transition; try { Ze.transition = null, z = 1, W1(e, t, n, r) } finally { Ze.transition = i, z = r } return null } function W1(e, t, n, r) { do or(); while (Gt !== null); if (j & 6) throw Error(A(327)); n = e.finishedWork; var i = e.finishedLanes; if (n === null) return null; if (e.finishedWork = null, e.finishedLanes = 0, n === e.current) throw Error(A(177)); e.callbackNode = null, e.callbackPriority = 0; var o = n.lanes | n.childLanes; if (Cv(e, o), e === fe && (ie = fe = null, me = 0), !(n.subtreeFlags & 2064) && !(n.flags & 2064) || oo || (oo = !0, ey(zo, function () { return or(), null })), o = (n.flags & 15990) !== 0, n.subtreeFlags & 15990 || o) { o = Ze.transition, Ze.transition = null; var s = z; z = 1; var a = j; j |= 4, Hu.current = null, j1(e, n), Hm(n, e), c1(ll), $o = !!al, ll = al = null, e.current = n, B1(n), mv(), j = a, z = s, Ze.transition = o } else e.current = n; if (oo && (oo = !1, Gt = e, is = i), o = e.pendingLanes, o === 0 && (en = null), vv(n.stateNode), Ve(e, ne()), t !== null) for (r = e.onRecoverableError, n = 0; n < t.length; n++)i = t[n], r(i.value, { componentStack: i.stack, digest: i.digest }); if (rs) throw rs = !1, e = Al, Al = null, e; return is & 1 && e.tag !== 0 && or(), o = e.pendingLanes, o & 1 ? e === Ll ? ei++ : (ei = 0, Ll = e) : ei = 0, cn(), null } function or() { if (Gt !== null) { var e = _p(is), t = Ze.transition, n = z; try { if (Ze.transition = null, z = 16 > e ? 16 : e, Gt === null) var r = !1; else { if (e = Gt, Gt = null, is = 0, j & 6) throw Error(A(331)); var i = j; for (j |= 4, _ = e.current; _ !== null;) { var o = _, s = o.child; if (_.flags & 16) { var a = o.deletions; if (a !== null) { for (var l = 0; l < a.length; l++) { var u = a[l]; for (_ = u; _ !== null;) { var c = _; switch (c.tag) { case 0: case 11: case 15: Jr(8, c, o) }var f = c.child; if (f !== null) f.return = c, _ = f; else for (; _ !== null;) { c = _; var d = c.sibling, g = c.return; if ($m(c), c === u) { _ = null; break } if (d !== null) { d.return = g, _ = d; break } _ = g } } } var y = o.alternate; if (y !== null) { var v = y.child; if (v !== null) { y.child = null; do { var S = v.sibling; v.sibling = null, v = S } while (v !== null) } } _ = o } } if (o.subtreeFlags & 2064 && s !== null) s.return = o, _ = s; else e: for (; _ !== null;) { if (o = _, o.flags & 2048) switch (o.tag) { case 0: case 11: case 15: Jr(9, o, o.return) }var p = o.sibling; if (p !== null) { p.return = o.return, _ = p; break e } _ = o.return } } var h = e.current; for (_ = h; _ !== null;) { s = _; var m = s.child; if (s.subtreeFlags & 2064 && m !== null) m.return = s, _ = m; else e: for (s = h; _ !== null;) { if (a = _, a.flags & 2048) try { switch (a.tag) { case 0: case 11: case 15: Ps(9, a) } } catch (E) { te(a, a.return, E) } if (a === s) { _ = null; break e } var x = a.sibling; if (x !== null) { x.return = a.return, _ = x; break e } _ = a.return } } if (j = i, cn(), St && typeof St.onPostCommitFiberRoot == "function") try { St.onPostCommitFiberRoot(gs, e) } catch { } r = !0 } return r } finally { z = n, Ze.transition = t } } return !1 } function td(e, t, n) { t = dr(n, t), t = _m(e, t, 1), e = Zt(e, t, 1), t = Ae(), e !== null && (Li(e, 1, t), Ve(e, t)) } function te(e, t, n) { if (e.tag === 3) td(e, e, n); else for (; t !== null;) { if (t.tag === 3) { td(t, e, n); break } else if (t.tag === 1) { var r = t.stateNode; if (typeof t.type.getDerivedStateFromError == "function" || typeof r.componentDidCatch == "function" && (en === null || !en.has(r))) { e = dr(n, e), e = Mm(t, e, 1), t = Zt(t, e, 1), e = Ae(), t !== null && (Li(t, 1, e), Ve(t, e)); break } } t = t.return } } function H1(e, t, n) { var r = e.pingCache; r !== null && r.delete(t), t = Ae(), e.pingedLanes |= e.suspendedLanes & n, fe === e && (me & n) === n && (ue === 4 || ue === 3 && (me & 130023424) === me && 500 > ne() - Gu ? Cn(e, 0) : Ku |= n), Ve(e, t) } function Jm(e, t) { t === 0 && (e.mode & 1 ? (t = Yi, Yi <<= 1, !(Yi & 130023424) && (Yi = 4194304)) : t = 1); var n = Ae(); e = Nt(e, t), e !== null && (Li(e, t, n), Ve(e, n)) } function K1(e) { var t = e.memoizedState, n = 0; t !== null && (n = t.retryLane), Jm(e, n) } function G1(e, t) { var n = 0; switch (e.tag) { case 13: var r = e.stateNode, i = e.memoizedState; i !== null && (n = i.retryLane); break; case 19: r = e.stateNode; break; default: throw Error(A(314)) }r !== null && r.delete(t), Jm(e, n) } var Zm; Zm = function (e, t, n) { if (e !== null) if (e.memoizedProps !== t.pendingProps || Oe.current) Me = !0; else { if (!(e.lanes & n) && !(t.flags & 128)) return Me = !1, N1(e, t, n); Me = !!(e.flags & 131072) } else Me = !1, X && t.flags & 1048576 && rm(t, Yo, t.index); switch (t.lanes = 0, t.tag) { case 2: var r = t.type; Eo(e, t), e = t.pendingProps; var i = lr(t, Ee.current); ir(t, n), i = zu(null, t, r, e, i, n); var o = Uu(); return t.flags |= 1, typeof i == "object" && i !== null && typeof i.render == "function" && i.$$typeof === void 0 ? (t.tag = 1, t.memoizedState = null, t.updateQueue = null, Ne(r) ? (o = !0, Go(t)) : o = !1, t.memoizedState = i.state !== null && i.state !== void 0 ? i.state : null, Vu(t), i.updater = Cs, t.stateNode = i, i._reactInternals = t, gl(t, r, e, n), t = Sl(null, t, r, !0, o, n)) : (t.tag = 0, X && o && Au(t), Pe(null, t, i, n), t = t.child), t; case 16: r = t.elementType; e: { switch (Eo(e, t), e = t.pendingProps, i = r._init, r = i(r._payload), t.type = r, i = t.tag = Y1(r), e = at(r, e), i) { case 0: t = wl(null, t, r, e, n); break e; case 1: t = Hf(null, t, r, e, n); break e; case 11: t = bf(null, t, r, e, n); break e; case 14: t = Wf(null, t, r, at(r.type, e), n); break e }throw Error(A(306, r, "")) } return t; case 0: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : at(r, i), wl(e, t, r, i, n); case 1: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : at(r, i), Hf(e, t, r, i, n); case 3: e: { if (Im(t), e === null) throw Error(A(387)); r = t.pendingProps, o = t.memoizedState, i = o.element, um(e, t), Jo(t, r, null, n); var s = t.memoizedState; if (r = s.element, o.isDehydrated) if (o = { element: r, isDehydrated: !1, cache: s.cache, pendingSuspenseBoundaries: s.pendingSuspenseBoundaries, transitions: s.transitions }, t.updateQueue.baseState = o, t.memoizedState = o, t.flags & 256) { i = dr(Error(A(423)), t), t = Kf(e, t, r, n, i); break e } else if (r !== i) { i = dr(Error(A(424)), t), t = Kf(e, t, r, n, i); break e } else for (ze = Jt(t.stateNode.containerInfo.firstChild), Ue = t, X = !0, ut = null, n = am(t, null, r, n), t.child = n; n;)n.flags = n.flags & -3 | 4096, n = n.sibling; else { if (ur(), r === i) { t = Vt(e, t, n); break e } Pe(e, t, r, n) } t = t.child } return t; case 5: return cm(t), e === null && pl(t), r = t.type, i = t.pendingProps, o = e !== null ? e.memoizedProps : null, s = i.children, ul(r, i) ? s = null : o !== null && ul(r, o) && (t.flags |= 32), Vm(e, t), Pe(e, t, s, n), t.child; case 6: return e === null && pl(t), null; case 13: return Fm(e, t, n); case 4: return Iu(t, t.stateNode.containerInfo), r = t.pendingProps, e === null ? t.child = cr(t, null, r, n) : Pe(e, t, r, n), t.child; case 11: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : at(r, i), bf(e, t, r, i, n); case 7: return Pe(e, t, t.pendingProps, n), t.child; case 8: return Pe(e, t, t.pendingProps.children, n), t.child; case 12: return Pe(e, t, t.pendingProps.children, n), t.child; case 10: e: { if (r = t.type._context, i = t.pendingProps, o = t.memoizedProps, s = i.value, U(Qo, r._currentValue), r._currentValue = s, o !== null) if (ht(o.value, s)) { if (o.children === i.children && !Oe.current) { t = Vt(e, t, n); break e } } else for (o = t.child, o !== null && (o.return = t); o !== null;) { var a = o.dependencies; if (a !== null) { s = o.child; for (var l = a.firstContext; l !== null;) { if (l.context === r) { if (o.tag === 1) { l = Dt(-1, n & -n), l.tag = 2; var u = o.updateQueue; if (u !== null) { u = u.shared; var c = u.pending; c === null ? l.next = l : (l.next = c.next, c.next = l), u.pending = l } } o.lanes |= n, l = o.alternate, l !== null && (l.lanes |= n), ml(o.return, n, t), a.lanes |= n; break } l = l.next } } else if (o.tag === 10) s = o.type === t.type ? null : o.child; else if (o.tag === 18) { if (s = o.return, s === null) throw Error(A(341)); s.lanes |= n, a = s.alternate, a !== null && (a.lanes |= n), ml(s, n, t), s = o.sibling } else s = o.child; if (s !== null) s.return = o; else for (s = o; s !== null;) { if (s === t) { s = null; break } if (o = s.sibling, o !== null) { o.return = s.return, s = o; break } s = s.return } o = s } Pe(e, t, i.children, n), t = t.child } return t; case 9: return i = t.type, r = t.pendingProps.children, ir(t, n), i = tt(i), r = r(i), t.flags |= 1, Pe(e, t, r, n), t.child; case 14: return r = t.type, i = at(r, t.pendingProps), i = at(r.type, i), Wf(e, t, r, i, n); case 15: return Om(e, t, t.type, t.pendingProps, n); case 17: return r = t.type, i = t.pendingProps, i = t.elementType === r ? i : at(r, i), Eo(e, t), t.tag = 1, Ne(r) ? (e = !0, Go(t)) : e = !1, ir(t, n), Dm(t, r, i), gl(t, r, i, n), Sl(null, t, r, !0, e, n); case 19: return jm(e, t, n); case 22: return Nm(e, t, n) }throw Error(A(156, t.tag)) }; function ey(e, t) { return Rp(e, t) } function X1(e, t, n, r) { this.tag = e, this.key = n, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = t, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = r, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null } function qe(e, t, n, r) { return new X1(e, t, n, r) } function qu(e) { return e = e.prototype, !(!e || !e.isReactComponent) } function Y1(e) { if (typeof e == "function") return qu(e) ? 1 : 0; if (e != null) { if (e = e.$$typeof, e === yu) return 11; if (e === gu) return 14 } return 2 } function nn(e, t) { var n = e.alternate; return n === null ? (n = qe(e.tag, t, e.key, e.mode), n.elementType = e.elementType, n.type = e.type, n.stateNode = e.stateNode, n.alternate = e, e.alternate = n) : (n.pendingProps = t, n.type = e.type, n.flags = 0, n.subtreeFlags = 0, n.deletions = null), n.flags = e.flags & 14680064, n.childLanes = e.childLanes, n.lanes = e.lanes, n.child = e.child, n.memoizedProps = e.memoizedProps, n.memoizedState = e.memoizedState, n.updateQueue = e.updateQueue, t = e.dependencies, n.dependencies = t === null ? null : { lanes: t.lanes, firstContext: t.firstContext }, n.sibling = e.sibling, n.index = e.index, n.ref = e.ref, n } function Po(e, t, n, r, i, o) { var s = 2; if (r = e, typeof e == "function") qu(e) && (s = 1); else if (typeof e == "string") s = 5; else e: switch (e) { case Bn: return Pn(n.children, i, o, t); case mu: s = 8, i |= 8; break; case Ua: return e = qe(12, n, t, i | 2), e.elementType = Ua, e.lanes = o, e; case $a: return e = qe(13, n, t, i), e.elementType = $a, e.lanes = o, e; case ba: return e = qe(19, n, t, i), e.elementType = ba, e.lanes = o, e; case cp: return Rs(n, i, o, t); default: if (typeof e == "object" && e !== null) switch (e.$$typeof) { case lp: s = 10; break e; case up: s = 9; break e; case yu: s = 11; break e; case gu: s = 14; break e; case $t: s = 16, r = null; break e }throw Error(A(130, e == null ? e : typeof e, "")) }return t = qe(s, n, t, i), t.elementType = e, t.type = r, t.lanes = o, t } function Pn(e, t, n, r) { return e = qe(7, e, r, t), e.lanes = n, e } function Rs(e, t, n, r) { return e = qe(22, e, r, t), e.elementType = cp, e.lanes = n, e.stateNode = { isHidden: !1 }, e } function pa(e, t, n) { return e = qe(6, e, null, t), e.lanes = n, e } function ma(e, t, n) { return t = qe(4, e.children !== null ? e.children : [], e.key, t), t.lanes = n, t.stateNode = { containerInfo: e.containerInfo, pendingChildren: null, implementation: e.implementation }, t } function Q1(e, t, n, r, i) { this.tag = t, this.containerInfo = e, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = -1, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Ys(0), this.expirationTimes = Ys(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Ys(0), this.identifierPrefix = r, this.onRecoverableError = i, this.mutableSourceEagerHydrationData = null } function Ju(e, t, n, r, i, o, s, a, l) { return e = new Q1(e, t, n, a, l), t === 1 ? (t = 1, o === !0 && (t |= 8)) : t = 0, o = qe(3, null, null, t), e.current = o, o.stateNode = e, o.memoizedState = { element: r, isDehydrated: n, cache: null, transitions: null, pendingSuspenseBoundaries: null }, Vu(o), e } function q1(e, t, n) { var r = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null; return { $$typeof: jn, key: r == null ? null : "" + r, children: e, containerInfo: t, implementation: n } } function ty(e) { if (!e) return on; e = e._reactInternals; e: { if (Vn(e) !== e || e.tag !== 1) throw Error(A(170)); var t = e; do { switch (t.tag) { case 3: t = t.stateNode.context; break e; case 1: if (Ne(t.type)) { t = t.stateNode.__reactInternalMemoizedMergedChildContext; break e } }t = t.return } while (t !== null); throw Error(A(171)) } if (e.tag === 1) { var n = e.type; if (Ne(n)) return tm(e, n, t) } return t } function ny(e, t, n, r, i, o, s, a, l) { return e = Ju(n, r, !0, e, i, o, s, a, l), e.context = ty(null), n = e.current, r = Ae(), i = tn(n), o = Dt(r, i), o.callback = t ?? null, Zt(n, o, i), e.current.lanes = i, Li(e, i, r), Ve(e, r), e } function As(e, t, n, r) { var i = t.current, o = Ae(), s = tn(i); return n = ty(n), t.context === null ? t.context = n : t.pendingContext = n, t = Dt(o, s), t.payload = { element: e }, r = r === void 0 ? null : r, r !== null && (t.callback = r), e = Zt(i, t, s), e !== null && (ft(e, i, s, o), wo(e, i, s)), s } function ss(e) { if (e = e.current, !e.child) return null; switch (e.child.tag) { case 5: return e.child.stateNode; default: return e.child.stateNode } } function nd(e, t) { if (e = e.memoizedState, e !== null && e.dehydrated !== null) { var n = e.retryLane; e.retryLane = n !== 0 && n < t ? n : t } } function Zu(e, t) { nd(e, t), (e = e.alternate) && nd(e, t) } function J1() { return null } var ry = typeof reportError == "function" ? reportError : function (e) { console.error(e) }; function ec(e) { this._internalRoot = e } Ls.prototype.render = ec.prototype.render = function (e) { var t = this._internalRoot; if (t === null) throw Error(A(409)); As(e, t, null, null) }; Ls.prototype.unmount = ec.prototype.unmount = function () { var e = this._internalRoot; if (e !== null) { this._internalRoot = null; var t = e.containerInfo; _n(function () { As(null, e, null, null) }), t[Ot] = null } }; function Ls(e) { this._internalRoot = e } Ls.prototype.unstable_scheduleHydration = function (e) { if (e) { var t = Np(); e = { blockedOn: null, target: e, priority: t }; for (var n = 0; n < Wt.length && t !== 0 && t < Wt[n].priority; n++); Wt.splice(n, 0, e), n === 0 && Ip(e) } }; function tc(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11) } function Ds(e) { return !(!e || e.nodeType !== 1 && e.nodeType !== 9 && e.nodeType !== 11 && (e.nodeType !== 8 || e.nodeValue !== " react-mount-point-unstable ")) } function rd() { } function Z1(e, t, n, r, i) { if (i) { if (typeof r == "function") { var o = r; r = function () { var u = ss(s); o.call(u) } } var s = ny(t, r, e, 0, null, !1, !1, "", rd); return e._reactRootContainer = s, e[Ot] = s.current, hi(e.nodeType === 8 ? e.parentNode : e), _n(), s } for (; i = e.lastChild;)e.removeChild(i); if (typeof r == "function") { var a = r; r = function () { var u = ss(l); a.call(u) } } var l = Ju(e, 0, !1, null, null, !1, !1, "", rd); return e._reactRootContainer = l, e[Ot] = l.current, hi(e.nodeType === 8 ? e.parentNode : e), _n(function () { As(t, l, n, r) }), l } function _s(e, t, n, r, i) { var o = n._reactRootContainer; if (o) { var s = o; if (typeof i == "function") { var a = i; i = function () { var l = ss(s); a.call(l) } } As(t, s, e, i) } else s = Z1(n, t, e, i, r); return ss(s) } Mp = function (e) { switch (e.tag) { case 3: var t = e.stateNode; if (t.current.memoizedState.isDehydrated) { var n = $r(t.pendingLanes); n !== 0 && (Su(t, n | 1), Ve(t, ne()), !(j & 6) && (hr = ne() + 500, cn())) } break; case 13: _n(function () { var r = Nt(e, 1); if (r !== null) { var i = Ae(); ft(r, e, 1, i) } }), Zu(e, 1) } }; xu = function (e) { if (e.tag === 13) { var t = Nt(e, 134217728); if (t !== null) { var n = Ae(); ft(t, e, 134217728, n) } Zu(e, 134217728) } }; Op = function (e) { if (e.tag === 13) { var t = tn(e), n = Nt(e, t); if (n !== null) { var r = Ae(); ft(n, e, t, r) } Zu(e, t) } }; Np = function () { return z }; Vp = function (e, t) { var n = z; try { return z = e, t() } finally { z = n } }; Za = function (e, t, n) { switch (t) { case "input": if (Ka(e, n), t = n.name, n.type === "radio" && t != null) { for (n = e; n.parentNode;)n = n.parentNode; for (n = n.querySelectorAll("input[name=" + JSON.stringify("" + t) + '][type="radio"]'), t = 0; t < n.length; t++) { var r = n[t]; if (r !== e && r.form === e.form) { var i = xs(r); if (!i) throw Error(A(90)); dp(r), Ka(r, i) } } } break; case "textarea": pp(e, n); break; case "select": t = n.value, t != null && er(e, !!n.multiple, t, !1) } }; xp = Xu; Ep = _n; var ew = { usingClientEntryPoint: !1, Events: [_i, bn, xs, wp, Sp, Xu] }, Ir = { findFiberByHostInstance: vn, bundleType: 0, version: "18.3.1", rendererPackageName: "react-dom" }, tw = { bundleType: Ir.bundleType, version: Ir.version, rendererPackageName: Ir.rendererPackageName, rendererConfig: Ir.rendererConfig, overrideHookState: null, overrideHookStateDeletePath: null, overrideHookStateRenamePath: null, overrideProps: null, overridePropsDeletePath: null, overridePropsRenamePath: null, setErrorHandler: null, setSuspenseHandler: null, scheduleUpdate: null, currentDispatcherRef: jt.ReactCurrentDispatcher, findHostInstanceByFiber: function (e) { return e = Pp(e), e === null ? null : e.stateNode }, findFiberByHostInstance: Ir.findFiberByHostInstance || J1, findHostInstancesForRefresh: null, scheduleRefresh: null, scheduleRoot: null, setRefreshHandler: null, getCurrentFiber: null, reconcilerVersion: "18.3.1-next-f1338f8080-20240426" }; if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ < "u") { var so = __REACT_DEVTOOLS_GLOBAL_HOOK__; if (!so.isDisabled && so.supportsFiber) try { gs = so.inject(tw), St = so } catch { } } We.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED = ew; We.createPortal = function (e, t) { var n = 2 < arguments.length && arguments[2] !== void 0 ? arguments[2] : null; if (!tc(t)) throw Error(A(200)); return q1(e, t, null, n) }; We.createRoot = function (e, t) { if (!tc(e)) throw Error(A(299)); var n = !1, r = "", i = ry; return t != null && (t.unstable_strictMode === !0 && (n = !0), t.identifierPrefix !== void 0 && (r = t.identifierPrefix), t.onRecoverableError !== void 0 && (i = t.onRecoverableError)), t = Ju(e, 1, !1, null, null, n, !1, r, i), e[Ot] = t.current, hi(e.nodeType === 8 ? e.parentNode : e), new ec(t) }; We.findDOMNode = function (e) { if (e == null) return null; if (e.nodeType === 1) return e; var t = e._reactInternals; if (t === void 0) throw typeof e.render == "function" ? Error(A(188)) : (e = Object.keys(e).join(","), Error(A(268, e))); return e = Pp(t), e = e === null ? null : e.stateNode, e }; We.flushSync = function (e) { return _n(e) }; We.hydrate = function (e, t, n) { if (!Ds(t)) throw Error(A(200)); return _s(null, e, t, !0, n) }; We.hydrateRoot = function (e, t, n) { if (!tc(e)) throw Error(A(405)); var r = n != null && n.hydratedSources || null, i = !1, o = "", s = ry; if (n != null && (n.unstable_strictMode === !0 && (i = !0), n.identifierPrefix !== void 0 && (o = n.identifierPrefix), n.onRecoverableError !== void 0 && (s = n.onRecoverableError)), t = ny(t, null, e, 1, n ?? null, i, !1, o, s), e[Ot] = t.current, hi(e), r) for (e = 0; e < r.length; e++)n = r[e], i = n._getVersion, i = i(n._source), t.mutableSourceEagerHydrationData == null ? t.mutableSourceEagerHydrationData = [n, i] : t.mutableSourceEagerHydrationData.push(n, i); return new Ls(t) }; We.render = function (e, t, n) { if (!Ds(t)) throw Error(A(200)); return _s(null, e, t, !1, n) }; We.unmountComponentAtNode = function (e) { if (!Ds(e)) throw Error(A(40)); return e._reactRootContainer ? (_n(function () { _s(null, null, e, !1, function () { e._reactRootContainer = null, e[Ot] = null }) }), !0) : !1 }; We.unstable_batchedUpdates = Xu; We.unstable_renderSubtreeIntoContainer = function (e, t, n, r) { if (!Ds(n)) throw Error(A(200)); if (e == null || e._reactInternals === void 0) throw Error(A(38)); return _s(e, t, n, !1, r) }; We.version = "18.3.1-next-f1338f8080-20240426"; function iy() { if (!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u" || typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE != "function")) try { __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(iy) } catch (e) { console.error(e) } } iy(), ip.exports = We; var nw = ip.exports, id = nw; Ba.createRoot = id.createRoot, Ba.hydrateRoot = id.hydrateRoot; const rw = "modulepreload", iw = function (e) { return "/" + e }, od = {}, de = function (t, n, r) { if (!n || n.length === 0) return t(); const i = document.getElementsByTagName("link"); return Promise.all(n.map(o => { if (o = iw(o), o in od) return; od[o] = !0; const s = o.endsWith(".css"), a = s ? '[rel="stylesheet"]' : ""; if (!!r) for (let c = i.length - 1; c >= 0; c--) { const f = i[c]; if (f.href === o && (!s || f.rel === "stylesheet")) return } else if (document.querySelector(`link[href="${o}"]${a}`)) return; const u = document.createElement("link"); if (u.rel = s ? "stylesheet" : rw, s || (u.as = "script", u.crossOrigin = ""), u.href = o, document.head.appendChild(u), s) return new Promise((c, f) => { u.addEventListener("load", c), u.addEventListener("error", () => f(new Error(`Unable to preload CSS for ${o}`))) }) })).then(() => t()).catch(o => { const s = new Event("vite:preloadError", { cancelable: !0 }); if (s.payload = o, window.dispatchEvent(s), !s.defaultPrevented) throw o }) }; var sd = "popstate"; function ow(e = {}) { function t(r, i) { let { pathname: o, search: s, hash: a } = r.location; return Ml("", { pathname: o, search: s, hash: a }, i.state && i.state.usr || null, i.state && i.state.key || "default") } function n(r, i) { return typeof i == "string" ? i : Ei(i) } return aw(t, n, null, e) } function Y(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function be(e, t) { if (!e) { typeof console < "u" && console.warn(t); try { throw new Error(t) } catch { } } } function sw() { return Math.random().toString(36).substring(2, 10) } function ad(e, t) { return { usr: e.state, key: e.key, idx: t } } function Ml(e, t, n = null, r) { return { pathname: typeof e == "string" ? e : e.pathname, search: "", hash: "", ...typeof t == "string" ? Sr(t) : t, state: n, key: t && t.key || r || sw() } } function Ei({ pathname: e = "/", search: t = "", hash: n = "" }) { return t && t !== "?" && (e += t.charAt(0) === "?" ? t : "?" + t), n && n !== "#" && (e += n.charAt(0) === "#" ? n : "#" + n), e } function Sr(e) { let t = {}; if (e) { let n = e.indexOf("#"); n >= 0 && (t.hash = e.substring(n), e = e.substring(0, n)); let r = e.indexOf("?"); r >= 0 && (t.search = e.substring(r), e = e.substring(0, r)), e && (t.pathname = e) } return t } function aw(e, t, n, r = {}) { let { window: i = document.defaultView, v5Compat: o = !1 } = r, s = i.history, a = "POP", l = null, u = c(); u == null && (u = 0, s.replaceState({ ...s.state, idx: u }, "")); function c() { return (s.state || { idx: null }).idx } function f() { a = "POP"; let S = c(), p = S == null ? null : S - u; u = S, l && l({ action: a, location: v.location, delta: p }) } function d(S, p) { a = "PUSH"; let h = Ml(v.location, S, p); n && n(h, S), u = c() + 1; let m = ad(h, u), x = v.createHref(h); try { s.pushState(m, "", x) } catch (E) { if (E instanceof DOMException && E.name === "DataCloneError") throw E; i.location.assign(x) } o && l && l({ action: a, location: v.location, delta: 1 }) } function g(S, p) { a = "REPLACE"; let h = Ml(v.location, S, p); n && n(h, S), u = c(); let m = ad(h, u), x = v.createHref(h); s.replaceState(m, "", x), o && l && l({ action: a, location: v.location, delta: 0 }) } function y(S) { return lw(S) } let v = { get action() { return a }, get location() { return e(i, s) }, listen(S) { if (l) throw new Error("A history only accepts one active listener"); return i.addEventListener(sd, f), l = S, () => { i.removeEventListener(sd, f), l = null } }, createHref(S) { return t(i, S) }, createURL: y, encodeLocation(S) { let p = y(S); return { pathname: p.pathname, search: p.search, hash: p.hash } }, push: d, replace: g, go(S) { return s.go(S) } }; return v } function lw(e, t = !1) { let n = "http://localhost"; typeof window < "u" && (n = window.location.origin !== "null" ? window.location.origin : window.location.href), Y(n, "No window.location.(origin|href) available to create URL"); let r = typeof e == "string" ? e : Ei(e); return r = r.replace(/ $/, "%20"), !t && r.startsWith("//") && (r = n + r), new URL(r, n) } function oy(e, t, n = "/") { return uw(e, t, n, !1) } function uw(e, t, n, r) { let i = typeof t == "string" ? Sr(t) : t, o = It(i.pathname || "/", n); if (o == null) return null; let s = sy(e); cw(s); let a = null; for (let l = 0; a == null && l < s.length; ++l) { let u = xw(o); a = ww(s[l], u, r) } return a } function sy(e, t = [], n = [], r = "", i = !1) { let o = (s, a, l = i, u) => { let c = { relativePath: u === void 0 ? s.path || "" : u, caseSensitive: s.caseSensitive === !0, childrenIndex: a, route: s }; if (c.relativePath.startsWith("/")) { if (!c.relativePath.startsWith(r) && l) return; Y(c.relativePath.startsWith(r), `Absolute route path "${c.relativePath}" nested under path "${r}" is not valid. An absolute child route path must start with the combined path of all its parent routes.`), c.relativePath = c.relativePath.slice(r.length) } let f = _t([r, c.relativePath]), d = n.concat(c); s.children && s.children.length > 0 && (Y(s.index !== !0, `Index routes must not have child routes. Please remove all child routes from route path "${f}".`), sy(s.children, t, d, f, l)), !(s.path == null && !s.index) && t.push({ path: f, score: gw(f, s.index), routesMeta: d }) }; return e.forEach((s, a) => { var l; if (s.path === "" || !((l = s.path) != null && l.includes("?"))) o(s, a); else for (let u of ay(s.path)) o(s, a, !0, u) }), t } function ay(e) { let t = e.split("/"); if (t.length === 0) return []; let [n, ...r] = t, i = n.endsWith("?"), o = n.replace(/\?$/, ""); if (r.length === 0) return i ? [o, ""] : [o]; let s = ay(r.join("/")), a = []; return a.push(...s.map(l => l === "" ? o : [o, l].join("/"))), i && a.push(...s), a.map(l => e.startsWith("/") && l === "" ? "/" : l) } function cw(e) { e.sort((t, n) => t.score !== n.score ? n.score - t.score : vw(t.routesMeta.map(r => r.childrenIndex), n.routesMeta.map(r => r.childrenIndex))) } var fw = /^:[\w-]+$/, dw = 3, hw = 2, pw = 1, mw = 10, yw = -2, ld = e => e === "*"; function gw(e, t) { let n = e.split("/"), r = n.length; return n.some(ld) && (r += yw), t && (r += hw), n.filter(i => !ld(i)).reduce((i, o) => i + (fw.test(o) ? dw : o === "" ? pw : mw), r) } function vw(e, t) { return e.length === t.length && e.slice(0, -1).every((r, i) => r === t[i]) ? e[e.length - 1] - t[t.length - 1] : 0 } function ww(e, t, n = !1) { let { routesMeta: r } = e, i = {}, o = "/", s = []; for (let a = 0; a < r.length; ++a) { let l = r[a], u = a === r.length - 1, c = o === "/" ? t : t.slice(o.length) || "/", f = as({ path: l.relativePath, caseSensitive: l.caseSensitive, end: u }, c), d = l.route; if (!f && u && n && !r[r.length - 1].route.index && (f = as({ path: l.relativePath, caseSensitive: l.caseSensitive, end: !1 }, c)), !f) return null; Object.assign(i, f.params), s.push({ params: i, pathname: _t([o, f.pathname]), pathnameBase: Pw(_t([o, f.pathnameBase])), route: d }), f.pathnameBase !== "/" && (o = _t([o, f.pathnameBase])) } return s } function as(e, t) { typeof e == "string" && (e = { path: e, caseSensitive: !1, end: !0 }); let [n, r] = Sw(e.path, e.caseSensitive, e.end), i = t.match(n); if (!i) return null; let o = i[0], s = o.replace(/(.)\/+$/, "$1"), a = i.slice(1); return { params: r.reduce((u, { paramName: c, isOptional: f }, d) => { if (c === "*") { let y = a[d] || ""; s = o.slice(0, o.length - y.length).replace(/(.)\/+$/, "$1") } const g = a[d]; return f && !g ? u[c] = void 0 : u[c] = (g || "").replace(/%2F/g, "/"), u }, {}), pathname: o, pathnameBase: s, pattern: e } } function Sw(e, t = !1, n = !0) { be(e === "*" || !e.endsWith("*") || e.endsWith("/*"), `Route path "${e}" will be treated as if it were "${e.replace(/\*$/, "/*")}" because the \`*\` character must always follow a \`/\` in the pattern. To get rid of this warning, please change the route path to "${e.replace(/\*$/, "/*")}".`); let r = [], i = "^" + e.replace(/\/*\*?$/, "").replace(/^\/*/, "/").replace(/[\\.*+^${}|()[\]]/g, "\\$&").replace(/\/:([\w-]+)(\?)?/g, (s, a, l) => (r.push({ paramName: a, isOptional: l != null }), l ? "/?([^\\/]+)?" : "/([^\\/]+)")).replace(/\/([\w-]+)\?(\/|$)/g, "(/$1)?$2"); return e.endsWith("*") ? (r.push({ paramName: "*" }), i += e === "*" || e === "/*" ? "(.*)$" : "(?:\\/(.+)|\\/*)$") : n ? i += "\\/*$" : e !== "" && e !== "/" && (i += "(?:(?=\\/|$))"), [new RegExp(i, t ? void 0 : "i"), r] } function xw(e) { try { return e.split("/").map(t => decodeURIComponent(t).replace(/\//g, "%2F")).join("/") } catch (t) { return be(!1, `The URL path "${e}" could not be decoded because it is a malformed URL segment. This is probably due to a bad percent encoding (${t}).`), e } } function It(e, t) { if (t === "/") return e; if (!e.toLowerCase().startsWith(t.toLowerCase())) return null; let n = t.endsWith("/") ? t.length - 1 : t.length, r = e.charAt(n); return r && r !== "/" ? null : e.slice(n) || "/" } var ly = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Ew = e => ly.test(e); function Tw(e, t = "/") { let { pathname: n, search: r = "", hash: i = "" } = typeof e == "string" ? Sr(e) : e, o; if (n) if (Ew(n)) o = n; else { if (n.includes("//")) { let s = n; n = n.replace(/\/\/+/g, "/"), be(!1, `Pathnames cannot have embedded double slashes - normalizing ${s} -> ${n}`) } n.startsWith("/") ? o = ud(n.substring(1), "/") : o = ud(n, t) } else o = t; return { pathname: o, search: kw(r), hash: Rw(i) } } function ud(e, t) { let n = t.replace(/\/+$/, "").split("/"); return e.split("/").forEach(i => { i === ".." ? n.length > 1 && n.pop() : i !== "." && n.push(i) }), n.length > 1 ? n.join("/") : "/" } function ya(e, t, n, r) { return `Cannot include a '${e}' character in a manually specified \`to.${t}\` field [${JSON.stringify(r)}].  Please separate it out to the \`to.${n}\` field. Alternatively you may provide the full path as a string in <Link to="..."> and the router will parse it for you.` } function Cw(e) { return e.filter((t, n) => n === 0 || t.route.path && t.route.path.length > 0) } function nc(e) { let t = Cw(e); return t.map((n, r) => r === t.length - 1 ? n.pathname : n.pathnameBase) } function rc(e, t, n, r = !1) { let i; typeof e == "string" ? i = Sr(e) : (i = { ...e }, Y(!i.pathname || !i.pathname.includes("?"), ya("?", "pathname", "search", i)), Y(!i.pathname || !i.pathname.includes("#"), ya("#", "pathname", "hash", i)), Y(!i.search || !i.search.includes("#"), ya("#", "search", "hash", i))); let o = e === "" || i.pathname === "", s = o ? "/" : i.pathname, a; if (s == null) a = n; else { let f = t.length - 1; if (!r && s.startsWith("..")) { let d = s.split("/"); for (; d[0] === "..";)d.shift(), f -= 1; i.pathname = d.join("/") } a = f >= 0 ? t[f] : "/" } let l = Tw(i, a), u = s && s !== "/" && s.endsWith("/"), c = (o || s === ".") && n.endsWith("/"); return !l.pathname.endsWith("/") && (u || c) && (l.pathname += "/"), l } var _t = e => e.join("/").replace(/\/\/+/g, "/"), Pw = e => e.replace(/\/+$/, "").replace(/^\/*/, "/"), kw = e => !e || e === "?" ? "" : e.startsWith("?") ? e : "?" + e, Rw = e => !e || e === "#" ? "" : e.startsWith("#") ? e : "#" + e, Aw = class { constructor(e, t, n, r = !1) { this.status = e, this.statusText = t || "", this.internal = r, n instanceof Error ? (this.data = n.toString(), this.error = n) : this.data = n } }; function Lw(e) { return e != null && typeof e.status == "number" && typeof e.statusText == "string" && typeof e.internal == "boolean" && "data" in e } function Dw(e) { return e.map(t => t.route.path).filter(Boolean).join("/").replace(/\/\/*/g, "/") || "/" } var uy = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; function cy(e, t) { let n = e; if (typeof n != "string" || !ly.test(n)) return { absoluteURL: void 0, isExternal: !1, to: n }; let r = n, i = !1; if (uy) try { let o = new URL(window.location.href), s = n.startsWith("//") ? new URL(o.protocol + n) : new URL(n), a = It(s.pathname, t); s.origin === o.origin && a != null ? n = a + s.search + s.hash : i = !0 } catch { be(!1, `<Link to="${n}"> contains an invalid URL which will probably break when clicked - please update to a valid URL path.`) } return { absoluteURL: r, isExternal: i, to: n } } Object.getOwnPropertyNames(Object.prototype).sort().join("\0"); var fy = ["POST", "PUT", "PATCH", "DELETE"]; new Set(fy); var _w = ["GET", ...fy]; new Set(_w); var xr = w.createContext(null); xr.displayName = "DataRouter"; var Ms = w.createContext(null); Ms.displayName = "DataRouterState"; var Mw = w.createContext(!1), dy = w.createContext({ isTransitioning: !1 }); dy.displayName = "ViewTransition"; var Ow = w.createContext(new Map); Ow.displayName = "Fetchers"; var Nw = w.createContext(null); Nw.displayName = "Await"; var Ke = w.createContext(null); Ke.displayName = "Navigation"; var Oi = w.createContext(null); Oi.displayName = "Location"; var pt = w.createContext({ outlet: null, matches: [], isDataRoute: !1 }); pt.displayName = "Route"; var ic = w.createContext(null); ic.displayName = "RouteError"; var hy = "REACT_ROUTER_ERROR", Vw = "REDIRECT", Iw = "ROUTE_ERROR_RESPONSE"; function Fw(e) { if (e.startsWith(`${hy}:${Vw}:{`)) try { let t = JSON.parse(e.slice(28)); if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string" && typeof t.location == "string" && typeof t.reloadDocument == "boolean" && typeof t.replace == "boolean") return t } catch { } } function jw(e) { if (e.startsWith(`${hy}:${Iw}:{`)) try { let t = JSON.parse(e.slice(40)); if (typeof t == "object" && t && typeof t.status == "number" && typeof t.statusText == "string") return new Aw(t.status, t.statusText, t.data) } catch { } } function Bw(e, { relative: t } = {}) { Y(Er(), "useHref() may be used only in the context of a <Router> component."); let { basename: n, navigator: r } = w.useContext(Ke), { hash: i, pathname: o, search: s } = Ni(e, { relative: t }), a = o; return n !== "/" && (a = o === "/" ? n : _t([n, o])), r.createHref({ pathname: a, search: s, hash: i }) } function Er() { return w.useContext(Oi) != null } function Pt() { return Y(Er(), "useLocation() may be used only in the context of a <Router> component."), w.useContext(Oi).location } var py = "You should call navigate() in a React.useEffect(), not when your component is first rendered."; function my(e) { w.useContext(Ke).static || w.useLayoutEffect(e) } function oc() { let { isDataRoute: e } = w.useContext(pt); return e ? Jw() : zw() } function zw() { Y(Er(), "useNavigate() may be used only in the context of a <Router> component."); let e = w.useContext(xr), { basename: t, navigator: n } = w.useContext(Ke), { matches: r } = w.useContext(pt), { pathname: i } = Pt(), o = JSON.stringify(nc(r)), s = w.useRef(!1); return my(() => { s.current = !0 }), w.useCallback((l, u = {}) => { if (be(s.current, py), !s.current) return; if (typeof l == "number") { n.go(l); return } let c = rc(l, JSON.parse(o), i, u.relative === "path"); e == null && t !== "/" && (c.pathname = c.pathname === "/" ? t : _t([t, c.pathname])), (u.replace ? n.replace : n.push)(c, u.state, u) }, [t, n, o, i, e]) } w.createContext(null); function VR() { let { matches: e } = w.useContext(pt), t = e[e.length - 1]; return t ? t.params : {} } function Ni(e, { relative: t } = {}) { let { matches: n } = w.useContext(pt), { pathname: r } = Pt(), i = JSON.stringify(nc(n)); return w.useMemo(() => rc(e, JSON.parse(i), r, t === "path"), [e, i, r, t]) } function Uw(e, t) { return yy(e, t) } function yy(e, t, n, r, i) {
  var h; Y(Er(), "useRoutes() may be used only in the context of a <Router> component."); let { navigator: o } = w.useContext(Ke), { matches: s } = w.useContext(pt), a = s[s.length - 1], l = a ? a.params : {}, u = a ? a.pathname : "/", c = a ? a.pathnameBase : "/", f = a && a.route; {
    let m = f && f.path || ""; vy(u, !f || m.endsWith("*") || m.endsWith("*?"), `You rendered descendant <Routes> (or called \`useRoutes()\`) at "${u}" (under <Route path="${m}">) but the parent route path has no trailing "*". This means if you navigate deeper, the parent won't match anymore and therefore the child routes will never render.

Please change the parent <Route path="${m}"> to <Route path="${m === "/" ? "*" : `${m}/*`}">.`)
  } let d = Pt(), g; if (t) { let m = typeof t == "string" ? Sr(t) : t; Y(c === "/" || ((h = m.pathname) == null ? void 0 : h.startsWith(c)), `When overriding the location using \`<Routes location>\` or \`useRoutes(routes, location)\`, the location pathname must begin with the portion of the URL pathname that was matched by all parent routes. The current pathname base is "${c}" but pathname "${m.pathname}" was given in the \`location\` prop.`), g = m } else g = d; let y = g.pathname || "/", v = y; if (c !== "/") { let m = c.replace(/^\//, "").split("/"); v = "/" + y.replace(/^\//, "").split("/").slice(m.length).join("/") } let S = oy(e, { pathname: v }); be(f || S != null, `No routes matched location "${g.pathname}${g.search}${g.hash}" `), be(S == null || S[S.length - 1].route.element !== void 0 || S[S.length - 1].route.Component !== void 0 || S[S.length - 1].route.lazy !== void 0, `Matched leaf route at location "${g.pathname}${g.search}${g.hash}" does not have an element or Component. This means it will render an <Outlet /> with a null value by default resulting in an "empty" page.`); let p = Kw(S && S.map(m => Object.assign({}, m, { params: Object.assign({}, l, m.params), pathname: _t([c, o.encodeLocation ? o.encodeLocation(m.pathname.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : m.pathname]), pathnameBase: m.pathnameBase === "/" ? c : _t([c, o.encodeLocation ? o.encodeLocation(m.pathnameBase.replace(/\?/g, "%3F").replace(/#/g, "%23")).pathname : m.pathnameBase]) })), s, n, r, i); return t && p ? w.createElement(Oi.Provider, { value: { location: { pathname: "/", search: "", hash: "", state: null, key: "default", ...g }, navigationType: "POP" } }, p) : p
} function $w() { let e = qw(), t = Lw(e) ? `${e.status} ${e.statusText}` : e instanceof Error ? e.message : JSON.stringify(e), n = e instanceof Error ? e.stack : null, r = "rgba(200,200,200, 0.5)", i = { padding: "0.5rem", backgroundColor: r }, o = { padding: "2px 4px", backgroundColor: r }, s = null; return console.error("Error handled by React Router default ErrorBoundary:", e), s = w.createElement(w.Fragment, null, w.createElement("p", null, " Hey developer "), w.createElement("p", null, "You can provide a way better UX than this when your app throws errors by providing your own ", w.createElement("code", { style: o }, "ErrorBoundary"), " or", " ", w.createElement("code", { style: o }, "errorElement"), " prop on your route.")), w.createElement(w.Fragment, null, w.createElement("h2", null, "Unexpected Application Error!"), w.createElement("h3", { style: { fontStyle: "italic" } }, t), n ? w.createElement("pre", { style: i }, n) : null, s) } var bw = w.createElement($w, null), gy = class extends w.Component { constructor(e) { super(e), this.state = { location: e.location, revalidation: e.revalidation, error: e.error } } static getDerivedStateFromError(e) { return { error: e } } static getDerivedStateFromProps(e, t) { return t.location !== e.location || t.revalidation !== "idle" && e.revalidation === "idle" ? { error: e.error, location: e.location, revalidation: e.revalidation } : { error: e.error !== void 0 ? e.error : t.error, location: t.location, revalidation: e.revalidation || t.revalidation } } componentDidCatch(e, t) { this.props.onError ? this.props.onError(e, t) : console.error("React Router caught the following error during render", e) } render() { let e = this.state.error; if (this.context && typeof e == "object" && e && "digest" in e && typeof e.digest == "string") { const n = jw(e.digest); n && (e = n) } let t = e !== void 0 ? w.createElement(pt.Provider, { value: this.props.routeContext }, w.createElement(ic.Provider, { value: e, children: this.props.component })) : this.props.children; return this.context ? w.createElement(Ww, { error: e }, t) : t } }; gy.contextType = Mw; var ga = new WeakMap; function Ww({ children: e, error: t }) { let { basename: n } = w.useContext(Ke); if (typeof t == "object" && t && "digest" in t && typeof t.digest == "string") { let r = Fw(t.digest); if (r) { let i = ga.get(t); if (i) throw i; let o = cy(r.location, n); if (uy && !ga.get(t)) if (o.isExternal || r.reloadDocument) window.location.href = o.absoluteURL || o.to; else { const s = Promise.resolve().then(() => window.__reactRouterDataRouter.navigate(o.to, { replace: r.replace })); throw ga.set(t, s), s } return w.createElement("meta", { httpEquiv: "refresh", content: `0;url=${o.absoluteURL || o.to}` }) } } return e } function Hw({ routeContext: e, match: t, children: n }) { let r = w.useContext(xr); return r && r.static && r.staticContext && (t.route.errorElement || t.route.ErrorBoundary) && (r.staticContext._deepestRenderedBoundaryId = t.route.id), w.createElement(pt.Provider, { value: e }, n) } function Kw(e, t = [], n = null, r = null, i = null) { if (e == null) { if (!n) return null; if (n.errors) e = n.matches; else if (t.length === 0 && !n.initialized && n.matches.length > 0) e = n.matches; else return null } let o = e, s = n == null ? void 0 : n.errors; if (s != null) { let c = o.findIndex(f => f.route.id && (s == null ? void 0 : s[f.route.id]) !== void 0); Y(c >= 0, `Could not find a matching route for errors on route IDs: ${Object.keys(s).join(",")}`), o = o.slice(0, Math.min(o.length, c + 1)) } let a = !1, l = -1; if (n) for (let c = 0; c < o.length; c++) { let f = o[c]; if ((f.route.HydrateFallback || f.route.hydrateFallbackElement) && (l = c), f.route.id) { let { loaderData: d, errors: g } = n, y = f.route.loader && !d.hasOwnProperty(f.route.id) && (!g || g[f.route.id] === void 0); if (f.route.lazy || y) { a = !0, l >= 0 ? o = o.slice(0, l + 1) : o = [o[0]]; break } } } let u = n && r ? (c, f) => { var d, g; r(c, { location: n.location, params: ((g = (d = n.matches) == null ? void 0 : d[0]) == null ? void 0 : g.params) ?? {}, unstable_pattern: Dw(n.matches), errorInfo: f }) } : void 0; return o.reduceRight((c, f, d) => { let g, y = !1, v = null, S = null; n && (g = s && f.route.id ? s[f.route.id] : void 0, v = f.route.errorElement || bw, a && (l < 0 && d === 0 ? (vy("route-fallback", !1, "No `HydrateFallback` element provided to render during initial hydration"), y = !0, S = null) : l === d && (y = !0, S = f.route.hydrateFallbackElement || null))); let p = t.concat(o.slice(0, d + 1)), h = () => { let m; return g ? m = v : y ? m = S : f.route.Component ? m = w.createElement(f.route.Component, null) : f.route.element ? m = f.route.element : m = c, w.createElement(Hw, { match: f, routeContext: { outlet: c, matches: p, isDataRoute: n != null }, children: m }) }; return n && (f.route.ErrorBoundary || f.route.errorElement || d === 0) ? w.createElement(gy, { location: n.location, revalidation: n.revalidation, component: v, error: g, children: h(), routeContext: { outlet: null, matches: p, isDataRoute: !0 }, onError: u }) : h() }, null) } function sc(e) { return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function Gw(e) { let t = w.useContext(xr); return Y(t, sc(e)), t } function Xw(e) { let t = w.useContext(Ms); return Y(t, sc(e)), t } function Yw(e) { let t = w.useContext(pt); return Y(t, sc(e)), t } function ac(e) { let t = Yw(e), n = t.matches[t.matches.length - 1]; return Y(n.route.id, `${e} can only be used on routes that contain a unique "id"`), n.route.id } function Qw() { return ac("useRouteId") } function qw() { var r; let e = w.useContext(ic), t = Xw("useRouteError"), n = ac("useRouteError"); return e !== void 0 ? e : (r = t.errors) == null ? void 0 : r[n] } function Jw() { let { router: e } = Gw("useNavigate"), t = ac("useNavigate"), n = w.useRef(!1); return my(() => { n.current = !0 }), w.useCallback(async (i, o = {}) => { be(n.current, py), n.current && (typeof i == "number" ? await e.navigate(i) : await e.navigate(i, { fromRouteId: t, ...o })) }, [e, t]) } var cd = {}; function vy(e, t, n) { !t && !cd[e] && (cd[e] = !0, be(!1, n)) } w.memo(Zw); function Zw({ routes: e, future: t, state: n, onError: r }) { return yy(e, void 0, n, r, t) } function it({ to: e, replace: t, state: n, relative: r }) { Y(Er(), "<Navigate> may be used only in the context of a <Router> component."); let { static: i } = w.useContext(Ke); be(!i, "<Navigate> must not be used on the initial render in a <StaticRouter>. This is a no-op, but you should modify your code so the <Navigate> is only ever rendered in response to some user interaction or state change."); let { matches: o } = w.useContext(pt), { pathname: s } = Pt(), a = oc(), l = rc(e, nc(o), s, r === "path"), u = JSON.stringify(l); return w.useEffect(() => { a(JSON.parse(u), { replace: t, state: n, relative: r }) }, [a, u, r, t, n]), null } function se(e) { Y(!1, "A <Route> is only ever to be used as the child of <Routes> element, never rendered directly. Please wrap your <Route> in a <Routes>.") } function eS({ basename: e = "/", children: t = null, location: n, navigationType: r = "POP", navigator: i, static: o = !1, unstable_useTransitions: s }) { Y(!Er(), "You cannot render a <Router> inside another <Router>. You should never have more than one in your app."); let a = e.replace(/^\/*/, "/"), l = w.useMemo(() => ({ basename: a, navigator: i, static: o, unstable_useTransitions: s, future: {} }), [a, i, o, s]); typeof n == "string" && (n = Sr(n)); let { pathname: u = "/", search: c = "", hash: f = "", state: d = null, key: g = "default" } = n, y = w.useMemo(() => { let v = It(u, a); return v == null ? null : { location: { pathname: v, search: c, hash: f, state: d, key: g }, navigationType: r } }, [a, u, c, f, d, g, r]); return be(y != null, `<Router basename="${a}"> is not able to match the URL "${u}${c}${f}" because it does not start with the basename, so the <Router> won't render anything.`), y == null ? null : w.createElement(Ke.Provider, { value: l }, w.createElement(Oi.Provider, { children: t, value: y })) } function tS({ children: e, location: t }) { return Uw(Ol(e), t) } function Ol(e, t = []) { let n = []; return w.Children.forEach(e, (r, i) => { if (!w.isValidElement(r)) return; let o = [...t, i]; if (r.type === w.Fragment) { n.push.apply(n, Ol(r.props.children, o)); return } Y(r.type === se, `[${typeof r.type == "string" ? r.type : r.type.name}] is not a <Route> component. All component children of <Routes> must be a <Route> or <React.Fragment>`), Y(!r.props.index || !r.props.children, "An index route cannot have child routes."); let s = { id: r.props.id || o.join("-"), caseSensitive: r.props.caseSensitive, element: r.props.element, Component: r.props.Component, index: r.props.index, path: r.props.path, middleware: r.props.middleware, loader: r.props.loader, action: r.props.action, hydrateFallbackElement: r.props.hydrateFallbackElement, HydrateFallback: r.props.HydrateFallback, errorElement: r.props.errorElement, ErrorBoundary: r.props.ErrorBoundary, hasErrorBoundary: r.props.hasErrorBoundary === !0 || r.props.ErrorBoundary != null || r.props.errorElement != null, shouldRevalidate: r.props.shouldRevalidate, handle: r.props.handle, lazy: r.props.lazy }; r.props.children && (s.children = Ol(r.props.children, o)), n.push(s) }), n } var ko = "get", Ro = "application/x-www-form-urlencoded"; function Os(e) { return typeof HTMLElement < "u" && e instanceof HTMLElement } function nS(e) { return Os(e) && e.tagName.toLowerCase() === "button" } function rS(e) { return Os(e) && e.tagName.toLowerCase() === "form" } function iS(e) { return Os(e) && e.tagName.toLowerCase() === "input" } function oS(e) { return !!(e.metaKey || e.altKey || e.ctrlKey || e.shiftKey) } function sS(e, t) { return e.button === 0 && (!t || t === "_self") && !oS(e) } function Nl(e = "") { return new URLSearchParams(typeof e == "string" || Array.isArray(e) || e instanceof URLSearchParams ? e : Object.keys(e).reduce((t, n) => { let r = e[n]; return t.concat(Array.isArray(r) ? r.map(i => [n, i]) : [[n, r]]) }, [])) } function aS(e, t) { let n = Nl(e); return t && t.forEach((r, i) => { n.has(i) || t.getAll(i).forEach(o => { n.append(i, o) }) }), n } var ao = null; function lS() { if (ao === null) try { new FormData(document.createElement("form"), 0), ao = !1 } catch { ao = !0 } return ao } var uS = new Set(["application/x-www-form-urlencoded", "multipart/form-data", "text/plain"]); function va(e) { return e != null && !uS.has(e) ? (be(!1, `"${e}" is not a valid \`encType\` for \`<Form>\`/\`<fetcher.Form>\` and will default to "${Ro}"`), null) : e } function cS(e, t) { let n, r, i, o, s; if (rS(e)) { let a = e.getAttribute("action"); r = a ? It(a, t) : null, n = e.getAttribute("method") || ko, i = va(e.getAttribute("enctype")) || Ro, o = new FormData(e) } else if (nS(e) || iS(e) && (e.type === "submit" || e.type === "image")) { let a = e.form; if (a == null) throw new Error('Cannot submit a <button> or <input type="submit"> without a <form>'); let l = e.getAttribute("formaction") || a.getAttribute("action"); if (r = l ? It(l, t) : null, n = e.getAttribute("formmethod") || a.getAttribute("method") || ko, i = va(e.getAttribute("formenctype")) || va(a.getAttribute("enctype")) || Ro, o = new FormData(a, e), !lS()) { let { name: u, type: c, value: f } = e; if (c === "image") { let d = u ? `${u}.` : ""; o.append(`${d}x`, "0"), o.append(`${d}y`, "0") } else u && o.append(u, f) } } else { if (Os(e)) throw new Error('Cannot submit element that is not <form>, <button>, or <input type="submit|image">'); n = ko, r = null, i = Ro, s = e } return o && i === "text/plain" && (s = o, o = void 0), { action: r, method: n.toLowerCase(), encType: i, formData: o, body: s } } Object.getOwnPropertyNames(Object.prototype).sort().join("\0"); function lc(e, t) { if (e === !1 || e === null || typeof e > "u") throw new Error(t) } function fS(e, t, n, r) { let i = typeof e == "string" ? new URL(e, typeof window > "u" ? "server://singlefetch/" : window.location.origin) : e; return n ? i.pathname.endsWith("/") ? i.pathname = `${i.pathname}_.${r}` : i.pathname = `${i.pathname}.${r}` : i.pathname === "/" ? i.pathname = `_root.${r}` : t && It(i.pathname, t) === "/" ? i.pathname = `${t.replace(/\/$/, "")}/_root.${r}` : i.pathname = `${i.pathname.replace(/\/$/, "")}.${r}`, i } async function dS(e, t) { if (e.id in t) return t[e.id]; try { let n = await de(() => import(e.module), []); return t[e.id] = n, n } catch (n) { return console.error(`Error loading route module \`${e.module}\`, reloading page...`), console.error(n), window.__reactRouterContext && window.__reactRouterContext.isSpaMode, window.location.reload(), new Promise(() => { }) } } function hS(e) { return e != null && typeof e.page == "string" } function pS(e) { return e == null ? !1 : e.href == null ? e.rel === "preload" && typeof e.imageSrcSet == "string" && typeof e.imageSizes == "string" : typeof e.rel == "string" && typeof e.href == "string" } async function mS(e, t, n) { let r = await Promise.all(e.map(async i => { let o = t.routes[i.route.id]; if (o) { let s = await dS(o, n); return s.links ? s.links() : [] } return [] })); return wS(r.flat(1).filter(pS).filter(i => i.rel === "stylesheet" || i.rel === "preload").map(i => i.rel === "stylesheet" ? { ...i, rel: "prefetch", as: "style" } : { ...i, rel: "prefetch" })) } function fd(e, t, n, r, i, o) { let s = (l, u) => n[u] ? l.route.id !== n[u].route.id : !0, a = (l, u) => { var c; return n[u].pathname !== l.pathname || ((c = n[u].route.path) == null ? void 0 : c.endsWith("*")) && n[u].params["*"] !== l.params["*"] }; return o === "assets" ? t.filter((l, u) => s(l, u) || a(l, u)) : o === "data" ? t.filter((l, u) => { var f; let c = r.routes[l.route.id]; if (!c || !c.hasLoader) return !1; if (s(l, u) || a(l, u)) return !0; if (l.route.shouldRevalidate) { let d = l.route.shouldRevalidate({ currentUrl: new URL(i.pathname + i.search + i.hash, window.origin), currentParams: ((f = n[0]) == null ? void 0 : f.params) || {}, nextUrl: new URL(e, window.origin), nextParams: l.params, defaultShouldRevalidate: !0 }); if (typeof d == "boolean") return d } return !0 }) : [] } function yS(e, t, { includeHydrateFallback: n } = {}) { return gS(e.map(r => { let i = t.routes[r.route.id]; if (!i) return []; let o = [i.module]; return i.clientActionModule && (o = o.concat(i.clientActionModule)), i.clientLoaderModule && (o = o.concat(i.clientLoaderModule)), n && i.hydrateFallbackModule && (o = o.concat(i.hydrateFallbackModule)), i.imports && (o = o.concat(i.imports)), o }).flat(1)) } function gS(e) { return [...new Set(e)] } function vS(e) { let t = {}, n = Object.keys(e).sort(); for (let r of n) t[r] = e[r]; return t } function wS(e, t) { let n = new Set, r = new Set(t); return e.reduce((i, o) => { if (t && !hS(o) && o.as === "script" && o.href && r.has(o.href)) return i; let a = JSON.stringify(vS(o)); return n.has(a) || (n.add(a), i.push({ key: a, link: o })), i }, []) } function wy() { let e = w.useContext(xr); return lc(e, "You must render this element inside a <DataRouterContext.Provider> element"), e } function SS() { let e = w.useContext(Ms); return lc(e, "You must render this element inside a <DataRouterStateContext.Provider> element"), e } var uc = w.createContext(void 0); uc.displayName = "FrameworkContext"; function Sy() { let e = w.useContext(uc); return lc(e, "You must render this element inside a <HydratedRouter> element"), e } function xS(e, t) { let n = w.useContext(uc), [r, i] = w.useState(!1), [o, s] = w.useState(!1), { onFocus: a, onBlur: l, onMouseEnter: u, onMouseLeave: c, onTouchStart: f } = t, d = w.useRef(null); w.useEffect(() => { if (e === "render" && s(!0), e === "viewport") { let v = p => { p.forEach(h => { s(h.isIntersecting) }) }, S = new IntersectionObserver(v, { threshold: .5 }); return d.current && S.observe(d.current), () => { S.disconnect() } } }, [e]), w.useEffect(() => { if (r) { let v = setTimeout(() => { s(!0) }, 100); return () => { clearTimeout(v) } } }, [r]); let g = () => { i(!0) }, y = () => { i(!1), s(!1) }; return n ? e !== "intent" ? [o, d, {}] : [o, d, { onFocus: Fr(a, g), onBlur: Fr(l, y), onMouseEnter: Fr(u, g), onMouseLeave: Fr(c, y), onTouchStart: Fr(f, g) }] : [!1, d, {}] } function Fr(e, t) { return n => { e && e(n), n.defaultPrevented || t(n) } } function ES({ page: e, ...t }) { let { router: n } = wy(), r = w.useMemo(() => oy(n.routes, e, n.basename), [n.routes, e, n.basename]); return r ? w.createElement(CS, { page: e, matches: r, ...t }) : null } function TS(e) { let { manifest: t, routeModules: n } = Sy(), [r, i] = w.useState([]); return w.useEffect(() => { let o = !1; return mS(e, t, n).then(s => { o || i(s) }), () => { o = !0 } }, [e, t, n]), r } function CS({ page: e, matches: t, ...n }) { let r = Pt(), { future: i, manifest: o, routeModules: s } = Sy(), { basename: a } = wy(), { loaderData: l, matches: u } = SS(), c = w.useMemo(() => fd(e, t, u, o, r, "data"), [e, t, u, o, r]), f = w.useMemo(() => fd(e, t, u, o, r, "assets"), [e, t, u, o, r]), d = w.useMemo(() => { if (e === r.pathname + r.search + r.hash) return []; let v = new Set, S = !1; if (t.forEach(h => { var x; let m = o.routes[h.route.id]; !m || !m.hasLoader || (!c.some(E => E.route.id === h.route.id) && h.route.id in l && ((x = s[h.route.id]) != null && x.shouldRevalidate) || m.hasClientLoader ? S = !0 : v.add(h.route.id)) }), v.size === 0) return []; let p = fS(e, a, i.unstable_trailingSlashAwareDataRequests, "data"); return S && v.size > 0 && p.searchParams.set("_routes", t.filter(h => v.has(h.route.id)).map(h => h.route.id).join(",")), [p.pathname + p.search] }, [a, i.unstable_trailingSlashAwareDataRequests, l, r, o, c, t, e, s]), g = w.useMemo(() => yS(f, o), [f, o]), y = TS(f); return w.createElement(w.Fragment, null, d.map(v => w.createElement("link", { key: v, rel: "prefetch", as: "fetch", href: v, ...n })), g.map(v => w.createElement("link", { key: v, rel: "modulepreload", href: v, ...n })), y.map(({ key: v, link: S }) => w.createElement("link", { key: v, nonce: n.nonce, ...S }))) } function PS(...e) { return t => { e.forEach(n => { typeof n == "function" ? n(t) : n != null && (n.current = t) }) } } var kS = typeof window < "u" && typeof window.document < "u" && typeof window.document.createElement < "u"; try { kS && (window.__reactRouterVersion = "7.12.0") } catch { } function RS({ basename: e, children: t, unstable_useTransitions: n, window: r }) { let i = w.useRef(); i.current == null && (i.current = ow({ window: r, v5Compat: !0 })); let o = i.current, [s, a] = w.useState({ action: o.action, location: o.location }), l = w.useCallback(u => { n === !1 ? a(u) : w.startTransition(() => a(u)) }, [n]); return w.useLayoutEffect(() => o.listen(l), [o, l]), w.createElement(eS, { basename: e, children: t, location: s.location, navigationType: s.action, navigator: o, unstable_useTransitions: n }) } var xy = /^(?:[a-z][a-z0-9+.-]*:|\/\/)/i, Ey = w.forwardRef(function ({ onClick: t, discover: n = "render", prefetch: r = "none", relative: i, reloadDocument: o, replace: s, state: a, target: l, to: u, preventScrollReset: c, viewTransition: f, unstable_defaultShouldRevalidate: d, ...g }, y) { let { basename: v, unstable_useTransitions: S } = w.useContext(Ke), p = typeof u == "string" && xy.test(u), h = cy(u, v); u = h.to; let m = Bw(u, { relative: i }), [x, E, k] = xS(r, g), P = _S(u, { replace: s, state: a, target: l, preventScrollReset: c, relative: i, viewTransition: f, unstable_defaultShouldRevalidate: d, unstable_useTransitions: S }); function C(M) { t && t(M), M.defaultPrevented || P(M) } let O = w.createElement("a", { ...g, ...k, href: h.absoluteURL || m, onClick: h.isExternal || o ? t : C, ref: PS(y, E), target: l, "data-discover": !p && n === "render" ? "true" : void 0 }); return x && !p ? w.createElement(w.Fragment, null, O, w.createElement(ES, { page: m })) : O }); Ey.displayName = "Link"; var AS = w.forwardRef(function ({ "aria-current": t = "page", caseSensitive: n = !1, className: r = "", end: i = !1, style: o, to: s, viewTransition: a, children: l, ...u }, c) { let f = Ni(s, { relative: u.relative }), d = Pt(), g = w.useContext(Ms), { navigator: y, basename: v } = w.useContext(Ke), S = g != null && IS(f) && a === !0, p = y.encodeLocation ? y.encodeLocation(f).pathname : f.pathname, h = d.pathname, m = g && g.navigation && g.navigation.location ? g.navigation.location.pathname : null; n || (h = h.toLowerCase(), m = m ? m.toLowerCase() : null, p = p.toLowerCase()), m && v && (m = It(m, v) || m); const x = p !== "/" && p.endsWith("/") ? p.length - 1 : p.length; let E = h === p || !i && h.startsWith(p) && h.charAt(x) === "/", k = m != null && (m === p || !i && m.startsWith(p) && m.charAt(p.length) === "/"), P = { isActive: E, isPending: k, isTransitioning: S }, C = E ? t : void 0, O; typeof r == "function" ? O = r(P) : O = [r, E ? "active" : null, k ? "pending" : null, S ? "transitioning" : null].filter(Boolean).join(" "); let M = typeof o == "function" ? o(P) : o; return w.createElement(Ey, { ...u, "aria-current": C, className: O, ref: c, style: M, to: s, viewTransition: a }, typeof l == "function" ? l(P) : l) }); AS.displayName = "NavLink"; var LS = w.forwardRef(({ discover: e = "render", fetcherKey: t, navigate: n, reloadDocument: r, replace: i, state: o, method: s = ko, action: a, onSubmit: l, relative: u, preventScrollReset: c, viewTransition: f, unstable_defaultShouldRevalidate: d, ...g }, y) => { let { unstable_useTransitions: v } = w.useContext(Ke), S = NS(), p = VS(a, { relative: u }), h = s.toLowerCase() === "get" ? "get" : "post", m = typeof a == "string" && xy.test(a), x = E => { if (l && l(E), E.defaultPrevented) return; E.preventDefault(); let k = E.nativeEvent.submitter, P = (k == null ? void 0 : k.getAttribute("formmethod")) || s, C = () => S(k || E.currentTarget, { fetcherKey: t, method: P, navigate: n, replace: i, state: o, relative: u, preventScrollReset: c, viewTransition: f, unstable_defaultShouldRevalidate: d }); v && n !== !1 ? w.startTransition(() => C()) : C() }; return w.createElement("form", { ref: y, method: h, action: p, onSubmit: r ? l : x, ...g, "data-discover": !m && e === "render" ? "true" : void 0 }) }); LS.displayName = "Form"; function DS(e) { return `${e} must be used within a data router.  See https://reactrouter.com/en/main/routers/picking-a-router.` } function Ty(e) { let t = w.useContext(xr); return Y(t, DS(e)), t } function _S(e, { target: t, replace: n, state: r, preventScrollReset: i, relative: o, viewTransition: s, unstable_defaultShouldRevalidate: a, unstable_useTransitions: l } = {}) { let u = oc(), c = Pt(), f = Ni(e, { relative: o }); return w.useCallback(d => { if (sS(d, t)) { d.preventDefault(); let g = n !== void 0 ? n : Ei(c) === Ei(f), y = () => u(e, { replace: g, state: r, preventScrollReset: i, relative: o, viewTransition: s, unstable_defaultShouldRevalidate: a }); l ? w.startTransition(() => y()) : y() } }, [c, u, f, n, r, t, e, i, o, s, a, l]) } function IR(e) { be(typeof URLSearchParams < "u", "You cannot use the `useSearchParams` hook in a browser that does not support the URLSearchParams API. If you need to support Internet Explorer 11, we recommend you load a polyfill such as https://github.com/ungap/url-search-params."); let t = w.useRef(Nl(e)), n = w.useRef(!1), r = Pt(), i = w.useMemo(() => aS(r.search, n.current ? null : t.current), [r.search]), o = oc(), s = w.useCallback((a, l) => { const u = Nl(typeof a == "function" ? a(new URLSearchParams(i)) : a); n.current = !0, o("?" + u, l) }, [o, i]); return [i, s] } var MS = 0, OS = () => `__${String(++MS)}__`; function NS() { let { router: e } = Ty("useSubmit"), { basename: t } = w.useContext(Ke), n = Qw(), r = e.fetch, i = e.navigate; return w.useCallback(async (o, s = {}) => { let { action: a, method: l, encType: u, formData: c, body: f } = cS(o, t); if (s.navigate === !1) { let d = s.fetcherKey || OS(); await r(d, n, s.action || a, { unstable_defaultShouldRevalidate: s.unstable_defaultShouldRevalidate, preventScrollReset: s.preventScrollReset, formData: c, body: f, formMethod: s.method || l, formEncType: s.encType || u, flushSync: s.flushSync }) } else await i(s.action || a, { unstable_defaultShouldRevalidate: s.unstable_defaultShouldRevalidate, preventScrollReset: s.preventScrollReset, formData: c, body: f, formMethod: s.method || l, formEncType: s.encType || u, replace: s.replace, state: s.state, fromRouteId: n, flushSync: s.flushSync, viewTransition: s.viewTransition }) }, [r, i, t, n]) } function VS(e, { relative: t } = {}) { let { basename: n } = w.useContext(Ke), r = w.useContext(pt); Y(r, "useFormAction must be used inside a RouteContext"); let [i] = r.matches.slice(-1), o = { ...Ni(e || ".", { relative: t }) }, s = Pt(); if (e == null) { o.search = s.search; let a = new URLSearchParams(o.search), l = a.getAll("index"); if (l.some(c => c === "")) { a.delete("index"), l.filter(f => f).forEach(f => a.append("index", f)); let c = a.toString(); o.search = c ? `?${c}` : "" } } return (!e || e === ".") && i.route.index && (o.search = o.search ? o.search.replace(/^\?/, "?index&") : "?index"), n !== "/" && (o.pathname = o.pathname === "/" ? n : _t([n, o.pathname])), Ei(o) } function IS(e, { relative: t } = {}) { let n = w.useContext(dy); Y(n != null, "`useViewTransitionState` must be used within `react-router-dom`'s `RouterProvider`.  Did you accidentally import `RouterProvider` from `react-router`?"); let { basename: r } = Ty("useViewTransitionState"), i = Ni(e, { relative: t }); if (!n.isTransitioning) return !1; let o = It(n.currentLocation.pathname, r) || n.currentLocation.pathname, s = It(n.nextLocation.pathname, r) || n.nextLocation.pathname; return as(i.pathname, s) != null || as(i.pathname, o) != null } const cc = w.createContext({}); function fc(e) { const t = w.useRef(null); return t.current === null && (t.current = e()), t.current } const dc = typeof window < "u", Cy = dc ? w.useLayoutEffect : w.useEffect, Ns = w.createContext(null); function hc(e, t) { e.indexOf(t) === -1 && e.push(t) } function pc(e, t) { const n = e.indexOf(t); n > -1 && e.splice(n, 1) } const Ct = (e, t, n) => n > t ? t : n < e ? e : n; function dd(e, t) { return t ? `${e}. For more information and steps for solving, visit https://motion.dev/troubleshooting/${t}` : e } let Vi = () => { }, Mn = () => { }; var Kh; typeof process < "u" && ((Kh = process.env) == null ? void 0 : Kh.NODE_ENV) !== "production" && (Vi = (e, t, n) => { !e && typeof console < "u" && console.warn(dd(t, n)) }, Mn = (e, t, n) => { if (!e) throw new Error(dd(t, n)) }); const Ft = {}, Py = e => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(e); function ky(e) { return typeof e == "object" && e !== null } const Ry = e => /^0[^.\s]+$/u.test(e); function mc(e) { let t; return () => (t === void 0 && (t = e()), t) } const et = e => e, FS = (e, t) => n => t(e(n)), Ii = (...e) => e.reduce(FS), Ti = (e, t, n) => { const r = t - e; return r === 0 ? 1 : (n - e) / r }; class yc { constructor() { this.subscriptions = [] } add(t) { return hc(this.subscriptions, t), () => pc(this.subscriptions, t) } notify(t, n, r) { const i = this.subscriptions.length; if (i) if (i === 1) this.subscriptions[0](t, n, r); else for (let o = 0; o < i; o++) { const s = this.subscriptions[o]; s && s(t, n, r) } } getSize() { return this.subscriptions.length } clear() { this.subscriptions.length = 0 } } const Et = e => e * 1e3, Je = e => e / 1e3; function Ay(e, t) { return t ? e * (1e3 / t) : 0 } const Ly = (e, t, n) => (((1 - 3 * n + 3 * t) * e + (3 * n - 6 * t)) * e + 3 * t) * e, jS = 1e-7, BS = 12; function zS(e, t, n, r, i) { let o, s, a = 0; do s = t + (n - t) / 2, o = Ly(s, r, i) - e, o > 0 ? n = s : t = s; while (Math.abs(o) > jS && ++a < BS); return s } function Fi(e, t, n, r) { if (e === t && n === r) return et; const i = o => zS(o, 0, 1, e, n); return o => o === 0 || o === 1 ? o : Ly(i(o), t, r) } const Dy = e => t => t <= .5 ? e(2 * t) / 2 : (2 - e(2 * (1 - t))) / 2, _y = e => t => 1 - e(1 - t), My = Fi(.33, 1.53, .69, .99), gc = _y(My), Oy = Dy(gc), Ny = e => (e *= 2) < 1 ? .5 * gc(e) : .5 * (2 - Math.pow(2, -10 * (e - 1))), vc = e => 1 - Math.sin(Math.acos(e)), Vy = _y(vc), Iy = Dy(vc), US = Fi(.42, 0, 1, 1), $S = Fi(0, 0, .58, 1), Fy = Fi(.42, 0, .58, 1), bS = e => Array.isArray(e) && typeof e[0] != "number", jy = e => Array.isArray(e) && typeof e[0] == "number", hd = { linear: et, easeIn: US, easeInOut: Fy, easeOut: $S, circIn: vc, circInOut: Iy, circOut: Vy, backIn: gc, backInOut: Oy, backOut: My, anticipate: Ny }, WS = e => typeof e == "string", pd = e => { if (jy(e)) { Mn(e.length === 4, "Cubic bezier arrays must contain four numerical values.", "cubic-bezier-length"); const [t, n, r, i] = e; return Fi(t, n, r, i) } else if (WS(e)) return Mn(hd[e] !== void 0, `Invalid easing type '${e}'`, "invalid-easing-type"), hd[e]; return e }, lo = ["setup", "read", "resolveKeyframes", "preUpdate", "update", "preRender", "render", "postRender"], md = { value: null, addProjectionMetrics: null }; function HS(e, t) { let n = new Set, r = new Set, i = !1, o = !1; const s = new WeakSet; let a = { delta: 0, timestamp: 0, isProcessing: !1 }, l = 0; function u(f) { s.has(f) && (c.schedule(f), e()), l++, f(a) } const c = { schedule: (f, d = !1, g = !1) => { const v = g && i ? n : r; return d && s.add(f), v.has(f) || v.add(f), f }, cancel: f => { r.delete(f), s.delete(f) }, process: f => { if (a = f, i) { o = !0; return } i = !0, [n, r] = [r, n], n.forEach(u), t && md.value && md.value.frameloop[t].push(l), l = 0, n.clear(), i = !1, o && (o = !1, c.process(f)) } }; return c } const KS = 40; function By(e, t) { let n = !1, r = !0; const i = { delta: 0, timestamp: 0, isProcessing: !1 }, o = () => n = !0, s = lo.reduce((m, x) => (m[x] = HS(o, t ? x : void 0), m), {}), { setup: a, read: l, resolveKeyframes: u, preUpdate: c, update: f, preRender: d, render: g, postRender: y } = s, v = () => { const m = Ft.useManualTiming ? i.timestamp : performance.now(); n = !1, Ft.useManualTiming || (i.delta = r ? 1e3 / 60 : Math.max(Math.min(m - i.timestamp, KS), 1)), i.timestamp = m, i.isProcessing = !0, a.process(i), l.process(i), u.process(i), c.process(i), f.process(i), d.process(i), g.process(i), y.process(i), i.isProcessing = !1, n && t && (r = !1, e(v)) }, S = () => { n = !0, r = !0, i.isProcessing || e(v) }; return { schedule: lo.reduce((m, x) => { const E = s[x]; return m[x] = (k, P = !1, C = !1) => (n || S(), E.schedule(k, P, C)), m }, {}), cancel: m => { for (let x = 0; x < lo.length; x++)s[lo[x]].cancel(m) }, state: i, steps: s } } const { schedule: H, cancel: sn, state: pe, steps: wa } = By(typeof requestAnimationFrame < "u" ? requestAnimationFrame : et, !0); let Ao; function GS() { Ao = void 0 } const ke = { now: () => (Ao === void 0 && ke.set(pe.isProcessing || Ft.useManualTiming ? pe.timestamp : performance.now()), Ao), set: e => { Ao = e, queueMicrotask(GS) } }, zy = e => t => typeof t == "string" && t.startsWith(e), Uy = zy("--"), XS = zy("var(--"), wc = e => XS(e) ? YS.test(e.split("/*")[0].trim()) : !1, YS = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu; function yd(e) { return typeof e != "string" ? !1 : e.split("/*")[0].includes("var(--") } const Tr = { test: e => typeof e == "number", parse: parseFloat, transform: e => e }, Ci = { ...Tr, transform: e => Ct(0, 1, e) }, uo = { ...Tr, default: 1 }, ti = e => Math.round(e * 1e5) / 1e5, Sc = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu; function QS(e) { return e == null } const qS = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu, xc = (e, t) => n => !!(typeof n == "string" && qS.test(n) && n.startsWith(e) || t && !QS(n) && Object.prototype.hasOwnProperty.call(n, t)), $y = (e, t, n) => r => { if (typeof r != "string") return r; const [i, o, s, a] = r.match(Sc); return { [e]: parseFloat(i), [t]: parseFloat(o), [n]: parseFloat(s), alpha: a !== void 0 ? parseFloat(a) : 1 } }, JS = e => Ct(0, 255, e), Sa = { ...Tr, transform: e => Math.round(JS(e)) }, xn = { test: xc("rgb", "red"), parse: $y("red", "green", "blue"), transform: ({ red: e, green: t, blue: n, alpha: r = 1 }) => "rgba(" + Sa.transform(e) + ", " + Sa.transform(t) + ", " + Sa.transform(n) + ", " + ti(Ci.transform(r)) + ")" }; function ZS(e) { let t = "", n = "", r = "", i = ""; return e.length > 5 ? (t = e.substring(1, 3), n = e.substring(3, 5), r = e.substring(5, 7), i = e.substring(7, 9)) : (t = e.substring(1, 2), n = e.substring(2, 3), r = e.substring(3, 4), i = e.substring(4, 5), t += t, n += n, r += r, i += i), { red: parseInt(t, 16), green: parseInt(n, 16), blue: parseInt(r, 16), alpha: i ? parseInt(i, 16) / 255 : 1 } } const Vl = { test: xc("#"), parse: ZS, transform: xn.transform }, ji = e => ({ test: t => typeof t == "string" && t.endsWith(e) && t.split(" ").length === 1, parse: parseFloat, transform: t => `${t}${e}` }), Ut = ji("deg"), Tt = ji("%"), D = ji("px"), ex = ji("vh"), tx = ji("vw"), gd = (() => ({ ...Tt, parse: e => Tt.parse(e) / 100, transform: e => Tt.transform(e * 100) }))(), Qn = { test: xc("hsl", "hue"), parse: $y("hue", "saturation", "lightness"), transform: ({ hue: e, saturation: t, lightness: n, alpha: r = 1 }) => "hsla(" + Math.round(e) + ", " + Tt.transform(ti(t)) + ", " + Tt.transform(ti(n)) + ", " + ti(Ci.transform(r)) + ")" }, re = { test: e => xn.test(e) || Vl.test(e) || Qn.test(e), parse: e => xn.test(e) ? xn.parse(e) : Qn.test(e) ? Qn.parse(e) : Vl.parse(e), transform: e => typeof e == "string" ? e : e.hasOwnProperty("red") ? xn.transform(e) : Qn.transform(e), getAnimatableNone: e => { const t = re.parse(e); return t.alpha = 0, re.transform(t) } }, nx = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu; function rx(e) { var t, n; return isNaN(e) && typeof e == "string" && (((t = e.match(Sc)) == null ? void 0 : t.length) || 0) + (((n = e.match(nx)) == null ? void 0 : n.length) || 0) > 0 } const by = "number", Wy = "color", ix = "var", ox = "var(", vd = "${}", sx = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu; function Pi(e) { const t = e.toString(), n = [], r = { color: [], number: [], var: [] }, i = []; let o = 0; const a = t.replace(sx, l => (re.test(l) ? (r.color.push(o), i.push(Wy), n.push(re.parse(l))) : l.startsWith(ox) ? (r.var.push(o), i.push(ix), n.push(l)) : (r.number.push(o), i.push(by), n.push(parseFloat(l))), ++o, vd)).split(vd); return { values: n, split: a, indexes: r, types: i } } function Hy(e) { return Pi(e).values } function Ky(e) { const { split: t, types: n } = Pi(e), r = t.length; return i => { let o = ""; for (let s = 0; s < r; s++)if (o += t[s], i[s] !== void 0) { const a = n[s]; a === by ? o += ti(i[s]) : a === Wy ? o += re.transform(i[s]) : o += i[s] } return o } } const ax = e => typeof e == "number" ? 0 : re.test(e) ? re.getAnimatableNone(e) : e; function lx(e) { const t = Hy(e); return Ky(e)(t.map(ax)) } const an = { test: rx, parse: Hy, createTransformer: Ky, getAnimatableNone: lx }; function xa(e, t, n) { return n < 0 && (n += 1), n > 1 && (n -= 1), n < 1 / 6 ? e + (t - e) * 6 * n : n < 1 / 2 ? t : n < 2 / 3 ? e + (t - e) * (2 / 3 - n) * 6 : e } function ux({ hue: e, saturation: t, lightness: n, alpha: r }) { e /= 360, t /= 100, n /= 100; let i = 0, o = 0, s = 0; if (!t) i = o = s = n; else { const a = n < .5 ? n * (1 + t) : n + t - n * t, l = 2 * n - a; i = xa(l, a, e + 1 / 3), o = xa(l, a, e), s = xa(l, a, e - 1 / 3) } return { red: Math.round(i * 255), green: Math.round(o * 255), blue: Math.round(s * 255), alpha: r } } function ls(e, t) { return n => n > 0 ? t : e } const J = (e, t, n) => e + (t - e) * n, Ea = (e, t, n) => { const r = e * e, i = n * (t * t - r) + r; return i < 0 ? 0 : Math.sqrt(i) }, cx = [Vl, xn, Qn], fx = e => cx.find(t => t.test(e)); function wd(e) { const t = fx(e); if (Vi(!!t, `'${e}' is not an animatable color. Use the equivalent color code instead.`, "color-not-animatable"), !t) return !1; let n = t.parse(e); return t === Qn && (n = ux(n)), n } const Sd = (e, t) => { const n = wd(e), r = wd(t); if (!n || !r) return ls(e, t); const i = { ...n }; return o => (i.red = Ea(n.red, r.red, o), i.green = Ea(n.green, r.green, o), i.blue = Ea(n.blue, r.blue, o), i.alpha = J(n.alpha, r.alpha, o), xn.transform(i)) }, Il = new Set(["none", "hidden"]); function dx(e, t) { return Il.has(e) ? n => n <= 0 ? e : t : n => n >= 1 ? t : e } function hx(e, t) { return n => J(e, t, n) } function Ec(e) { return typeof e == "number" ? hx : typeof e == "string" ? wc(e) ? ls : re.test(e) ? Sd : yx : Array.isArray(e) ? Gy : typeof e == "object" ? re.test(e) ? Sd : px : ls } function Gy(e, t) { const n = [...e], r = n.length, i = e.map((o, s) => Ec(o)(o, t[s])); return o => { for (let s = 0; s < r; s++)n[s] = i[s](o); return n } } function px(e, t) { const n = { ...e, ...t }, r = {}; for (const i in n) e[i] !== void 0 && t[i] !== void 0 && (r[i] = Ec(e[i])(e[i], t[i])); return i => { for (const o in r) n[o] = r[o](i); return n } } function mx(e, t) { const n = [], r = { color: 0, var: 0, number: 0 }; for (let i = 0; i < t.values.length; i++) { const o = t.types[i], s = e.indexes[o][r[o]], a = e.values[s] ?? 0; n[i] = a, r[o]++ } return n } const yx = (e, t) => { const n = an.createTransformer(t), r = Pi(e), i = Pi(t); return r.indexes.var.length === i.indexes.var.length && r.indexes.color.length === i.indexes.color.length && r.indexes.number.length >= i.indexes.number.length ? Il.has(e) && !i.values.length || Il.has(t) && !r.values.length ? dx(e, t) : Ii(Gy(mx(r, i), i.values), n) : (Vi(!0, `Complex values '${e}' and '${t}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`, "complex-values-different"), ls(e, t)) }; function Xy(e, t, n) { return typeof e == "number" && typeof t == "number" && typeof n == "number" ? J(e, t, n) : Ec(e)(e, t) } const gx = e => { const t = ({ timestamp: n }) => e(n); return { start: (n = !0) => H.update(t, n), stop: () => sn(t), now: () => pe.isProcessing ? pe.timestamp : ke.now() } }, Yy = (e, t, n = 10) => { let r = ""; const i = Math.max(Math.round(t / n), 2); for (let o = 0; o < i; o++)r += Math.round(e(o / (i - 1)) * 1e4) / 1e4 + ", "; return `linear(${r.substring(0, r.length - 2)})` }, us = 2e4; function Tc(e) { let t = 0; const n = 50; let r = e.next(t); for (; !r.done && t < us;)t += n, r = e.next(t); return t >= us ? 1 / 0 : t } function vx(e, t = 100, n) { const r = n({ ...e, keyframes: [0, t] }), i = Math.min(Tc(r), us); return { type: "keyframes", ease: o => r.next(i * o).value / t, duration: Je(i) } } const wx = 5; function Qy(e, t, n) { const r = Math.max(t - wx, 0); return Ay(n - e(r), t - r) } const Q = { stiffness: 100, damping: 10, mass: 1, velocity: 0, duration: 800, bounce: .3, visualDuration: .3, restSpeed: { granular: .01, default: 2 }, restDelta: { granular: .005, default: .5 }, minDuration: .01, maxDuration: 10, minDamping: .05, maxDamping: 1 }, Ta = .001; function Sx({ duration: e = Q.duration, bounce: t = Q.bounce, velocity: n = Q.velocity, mass: r = Q.mass }) { let i, o; Vi(e <= Et(Q.maxDuration), "Spring duration must be 10 seconds or less", "spring-duration-limit"); let s = 1 - t; s = Ct(Q.minDamping, Q.maxDamping, s), e = Ct(Q.minDuration, Q.maxDuration, Je(e)), s < 1 ? (i = u => { const c = u * s, f = c * e, d = c - n, g = Fl(u, s), y = Math.exp(-f); return Ta - d / g * y }, o = u => { const f = u * s * e, d = f * n + n, g = Math.pow(s, 2) * Math.pow(u, 2) * e, y = Math.exp(-f), v = Fl(Math.pow(u, 2), s); return (-i(u) + Ta > 0 ? -1 : 1) * ((d - g) * y) / v }) : (i = u => { const c = Math.exp(-u * e), f = (u - n) * e + 1; return -Ta + c * f }, o = u => { const c = Math.exp(-u * e), f = (n - u) * (e * e); return c * f }); const a = 5 / e, l = Ex(i, o, a); if (e = Et(e), isNaN(l)) return { stiffness: Q.stiffness, damping: Q.damping, duration: e }; { const u = Math.pow(l, 2) * r; return { stiffness: u, damping: s * 2 * Math.sqrt(r * u), duration: e } } } const xx = 12; function Ex(e, t, n) { let r = n; for (let i = 1; i < xx; i++)r = r - e(r) / t(r); return r } function Fl(e, t) { return e * Math.sqrt(1 - t * t) } const Tx = ["duration", "bounce"], Cx = ["stiffness", "damping", "mass"]; function xd(e, t) { return t.some(n => e[n] !== void 0) } function Px(e) { let t = { velocity: Q.velocity, stiffness: Q.stiffness, damping: Q.damping, mass: Q.mass, isResolvedFromDuration: !1, ...e }; if (!xd(e, Cx) && xd(e, Tx)) if (e.visualDuration) { const n = e.visualDuration, r = 2 * Math.PI / (n * 1.2), i = r * r, o = 2 * Ct(.05, 1, 1 - (e.bounce || 0)) * Math.sqrt(i); t = { ...t, mass: Q.mass, stiffness: i, damping: o } } else { const n = Sx(e); t = { ...t, ...n, mass: Q.mass }, t.isResolvedFromDuration = !0 } return t } function cs(e = Q.visualDuration, t = Q.bounce) { const n = typeof e != "object" ? { visualDuration: e, keyframes: [0, 1], bounce: t } : e; let { restSpeed: r, restDelta: i } = n; const o = n.keyframes[0], s = n.keyframes[n.keyframes.length - 1], a = { done: !1, value: o }, { stiffness: l, damping: u, mass: c, duration: f, velocity: d, isResolvedFromDuration: g } = Px({ ...n, velocity: -Je(n.velocity || 0) }), y = d || 0, v = u / (2 * Math.sqrt(l * c)), S = s - o, p = Je(Math.sqrt(l / c)), h = Math.abs(S) < 5; r || (r = h ? Q.restSpeed.granular : Q.restSpeed.default), i || (i = h ? Q.restDelta.granular : Q.restDelta.default); let m; if (v < 1) { const E = Fl(p, v); m = k => { const P = Math.exp(-v * p * k); return s - P * ((y + v * p * S) / E * Math.sin(E * k) + S * Math.cos(E * k)) } } else if (v === 1) m = E => s - Math.exp(-p * E) * (S + (y + p * S) * E); else { const E = p * Math.sqrt(v * v - 1); m = k => { const P = Math.exp(-v * p * k), C = Math.min(E * k, 300); return s - P * ((y + v * p * S) * Math.sinh(C) + E * S * Math.cosh(C)) / E } } const x = { calculatedDuration: g && f || null, next: E => { const k = m(E); if (g) a.done = E >= f; else { let P = E === 0 ? y : 0; v < 1 && (P = E === 0 ? Et(y) : Qy(m, E, k)); const C = Math.abs(P) <= r, O = Math.abs(s - k) <= i; a.done = C && O } return a.value = a.done ? s : k, a }, toString: () => { const E = Math.min(Tc(x), us), k = Yy(P => x.next(E * P).value, E, 30); return E + "ms " + k }, toTransition: () => { } }; return x } cs.applyToOptions = e => { const t = vx(e, 100, cs); return e.ease = t.ease, e.duration = Et(t.duration), e.type = "keyframes", e }; function jl({ keyframes: e, velocity: t = 0, power: n = .8, timeConstant: r = 325, bounceDamping: i = 10, bounceStiffness: o = 500, modifyTarget: s, min: a, max: l, restDelta: u = .5, restSpeed: c }) { const f = e[0], d = { done: !1, value: f }, g = C => a !== void 0 && C < a || l !== void 0 && C > l, y = C => a === void 0 ? l : l === void 0 || Math.abs(a - C) < Math.abs(l - C) ? a : l; let v = n * t; const S = f + v, p = s === void 0 ? S : s(S); p !== S && (v = p - f); const h = C => -v * Math.exp(-C / r), m = C => p + h(C), x = C => { const O = h(C), M = m(C); d.done = Math.abs(O) <= u, d.value = d.done ? p : M }; let E, k; const P = C => { g(d.value) && (E = C, k = cs({ keyframes: [d.value, y(d.value)], velocity: Qy(m, C, d.value), damping: i, stiffness: o, restDelta: u, restSpeed: c })) }; return P(0), { calculatedDuration: null, next: C => { let O = !1; return !k && E === void 0 && (O = !0, x(C), P(C)), E !== void 0 && C >= E ? k.next(C - E) : (!O && x(C), d) } } } function kx(e, t, n) { const r = [], i = n || Ft.mix || Xy, o = e.length - 1; for (let s = 0; s < o; s++) { let a = i(e[s], e[s + 1]); if (t) { const l = Array.isArray(t) ? t[s] || et : t; a = Ii(l, a) } r.push(a) } return r } function Rx(e, t, { clamp: n = !0, ease: r, mixer: i } = {}) { const o = e.length; if (Mn(o === t.length, "Both input and output ranges must be the same length", "range-length"), o === 1) return () => t[0]; if (o === 2 && t[0] === t[1]) return () => t[1]; const s = e[0] === e[1]; e[0] > e[o - 1] && (e = [...e].reverse(), t = [...t].reverse()); const a = kx(t, r, i), l = a.length, u = c => { if (s && c < e[0]) return t[0]; let f = 0; if (l > 1) for (; f < e.length - 2 && !(c < e[f + 1]); f++); const d = Ti(e[f], e[f + 1], c); return a[f](d) }; return n ? c => u(Ct(e[0], e[o - 1], c)) : u } function Ax(e, t) { const n = e[e.length - 1]; for (let r = 1; r <= t; r++) { const i = Ti(0, t, r); e.push(J(n, 1, i)) } } function Lx(e) { const t = [0]; return Ax(t, e.length - 1), t } function Dx(e, t) { return e.map(n => n * t) } function _x(e, t) { return e.map(() => t || Fy).splice(0, e.length - 1) } function ni({ duration: e = 300, keyframes: t, times: n, ease: r = "easeInOut" }) { const i = bS(r) ? r.map(pd) : pd(r), o = { done: !1, value: t[0] }, s = Dx(n && n.length === t.length ? n : Lx(t), e), a = Rx(s, t, { ease: Array.isArray(i) ? i : _x(t, i) }); return { calculatedDuration: e, next: l => (o.value = a(l), o.done = l >= e, o) } } const Mx = e => e !== null; function Cc(e, { repeat: t, repeatType: n = "loop" }, r, i = 1) { const o = e.filter(Mx), a = i < 0 || t && n !== "loop" && t % 2 === 1 ? 0 : o.length - 1; return !a || r === void 0 ? o[a] : r } const Ox = { decay: jl, inertia: jl, tween: ni, keyframes: ni, spring: cs }; function qy(e) { typeof e.type == "string" && (e.type = Ox[e.type]) } class Pc { constructor() { this.updateFinished() } get finished() { return this._finished } updateFinished() { this._finished = new Promise(t => { this.resolve = t }) } notifyFinished() { this.resolve() } then(t, n) { return this.finished.then(t, n) } } const Nx = e => e / 100; class kc extends Pc { constructor(t) { super(), this.state = "idle", this.startTime = null, this.isStopped = !1, this.currentTime = 0, this.holdTime = null, this.playbackSpeed = 1, this.stop = () => { var r, i; const { motionValue: n } = this.options; n && n.updatedAt !== ke.now() && this.tick(ke.now()), this.isStopped = !0, this.state !== "idle" && (this.teardown(), (i = (r = this.options).onStop) == null || i.call(r)) }, this.options = t, this.initAnimation(), this.play(), t.autoplay === !1 && this.pause() } initAnimation() { const { options: t } = this; qy(t); const { type: n = ni, repeat: r = 0, repeatDelay: i = 0, repeatType: o, velocity: s = 0 } = t; let { keyframes: a } = t; const l = n || ni; l !== ni && typeof a[0] != "number" && (this.mixKeyframes = Ii(Nx, Xy(a[0], a[1])), a = [0, 100]); const u = l({ ...t, keyframes: a }); o === "mirror" && (this.mirroredGenerator = l({ ...t, keyframes: [...a].reverse(), velocity: -s })), u.calculatedDuration === null && (u.calculatedDuration = Tc(u)); const { calculatedDuration: c } = u; this.calculatedDuration = c, this.resolvedDuration = c + i, this.totalDuration = this.resolvedDuration * (r + 1) - i, this.generator = u } updateTime(t) { const n = Math.round(t - this.startTime) * this.playbackSpeed; this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = n } tick(t, n = !1) { const { generator: r, totalDuration: i, mixKeyframes: o, mirroredGenerator: s, resolvedDuration: a, calculatedDuration: l } = this; if (this.startTime === null) return r.next(0); const { delay: u = 0, keyframes: c, repeat: f, repeatType: d, repeatDelay: g, type: y, onUpdate: v, finalKeyframe: S } = this.options; this.speed > 0 ? this.startTime = Math.min(this.startTime, t) : this.speed < 0 && (this.startTime = Math.min(t - i / this.speed, this.startTime)), n ? this.currentTime = t : this.updateTime(t); const p = this.currentTime - u * (this.playbackSpeed >= 0 ? 1 : -1), h = this.playbackSpeed >= 0 ? p < 0 : p > i; this.currentTime = Math.max(p, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = i); let m = this.currentTime, x = r; if (f) { const C = Math.min(this.currentTime, i) / a; let O = Math.floor(C), M = C % 1; !M && C >= 1 && (M = 1), M === 1 && O--, O = Math.min(O, f + 1), !!(O % 2) && (d === "reverse" ? (M = 1 - M, g && (M -= g / a)) : d === "mirror" && (x = s)), m = Ct(0, 1, M) * a } const E = h ? { done: !1, value: c[0] } : x.next(m); o && (E.value = o(E.value)); let { done: k } = E; !h && l !== null && (k = this.playbackSpeed >= 0 ? this.currentTime >= i : this.currentTime <= 0); const P = this.holdTime === null && (this.state === "finished" || this.state === "running" && k); return P && y !== jl && (E.value = Cc(c, this.options, S, this.speed)), v && v(E.value), P && this.finish(), E } then(t, n) { return this.finished.then(t, n) } get duration() { return Je(this.calculatedDuration) } get iterationDuration() { const { delay: t = 0 } = this.options || {}; return this.duration + Je(t) } get time() { return Je(this.currentTime) } set time(t) { var n; t = Et(t), this.currentTime = t, this.startTime === null || this.holdTime !== null || this.playbackSpeed === 0 ? this.holdTime = t : this.driver && (this.startTime = this.driver.now() - t / this.playbackSpeed), (n = this.driver) == null || n.start(!1) } get speed() { return this.playbackSpeed } set speed(t) { this.updateTime(ke.now()); const n = this.playbackSpeed !== t; this.playbackSpeed = t, n && (this.time = Je(this.currentTime)) } play() { var i, o; if (this.isStopped) return; const { driver: t = gx, startTime: n } = this.options; this.driver || (this.driver = t(s => this.tick(s))), (o = (i = this.options).onPlay) == null || o.call(i); const r = this.driver.now(); this.state === "finished" ? (this.updateFinished(), this.startTime = r) : this.holdTime !== null ? this.startTime = r - this.holdTime : this.startTime || (this.startTime = n ?? r), this.state === "finished" && this.speed < 0 && (this.startTime += this.calculatedDuration), this.holdTime = null, this.state = "running", this.driver.start() } pause() { this.state = "paused", this.updateTime(ke.now()), this.holdTime = this.currentTime } complete() { this.state !== "running" && this.play(), this.state = "finished", this.holdTime = null } finish() { var t, n; this.notifyFinished(), this.teardown(), this.state = "finished", (n = (t = this.options).onComplete) == null || n.call(t) } cancel() { var t, n; this.holdTime = null, this.startTime = 0, this.tick(0), this.teardown(), (n = (t = this.options).onCancel) == null || n.call(t) } teardown() { this.state = "idle", this.stopDriver(), this.startTime = this.holdTime = null } stopDriver() { this.driver && (this.driver.stop(), this.driver = void 0) } sample(t) { return this.startTime = 0, this.tick(t, !0) } attachTimeline(t) { var n; return this.options.allowFlatten && (this.options.type = "keyframes", this.options.ease = "linear", this.initAnimation()), (n = this.driver) == null || n.stop(), t.observe(this) } } function Vx(e) { for (let t = 1; t < e.length; t++)e[t] ?? (e[t] = e[t - 1]) } const En = e => e * 180 / Math.PI, Bl = e => { const t = En(Math.atan2(e[1], e[0])); return zl(t) }, Ix = { x: 4, y: 5, translateX: 4, translateY: 5, scaleX: 0, scaleY: 3, scale: e => (Math.abs(e[0]) + Math.abs(e[3])) / 2, rotate: Bl, rotateZ: Bl, skewX: e => En(Math.atan(e[1])), skewY: e => En(Math.atan(e[2])), skew: e => (Math.abs(e[1]) + Math.abs(e[2])) / 2 }, zl = e => (e = e % 360, e < 0 && (e += 360), e), Ed = Bl, Td = e => Math.sqrt(e[0] * e[0] + e[1] * e[1]), Cd = e => Math.sqrt(e[4] * e[4] + e[5] * e[5]), Fx = { x: 12, y: 13, z: 14, translateX: 12, translateY: 13, translateZ: 14, scaleX: Td, scaleY: Cd, scale: e => (Td(e) + Cd(e)) / 2, rotateX: e => zl(En(Math.atan2(e[6], e[5]))), rotateY: e => zl(En(Math.atan2(-e[2], e[0]))), rotateZ: Ed, rotate: Ed, skewX: e => En(Math.atan(e[4])), skewY: e => En(Math.atan(e[1])), skew: e => (Math.abs(e[1]) + Math.abs(e[4])) / 2 }; function Ul(e) { return e.includes("scale") ? 1 : 0 } function $l(e, t) { if (!e || e === "none") return Ul(t); const n = e.match(/^matrix3d\(([-\d.e\s,]+)\)$/u); let r, i; if (n) r = Fx, i = n; else { const a = e.match(/^matrix\(([-\d.e\s,]+)\)$/u); r = Ix, i = a } if (!i) return Ul(t); const o = r[t], s = i[1].split(",").map(Bx); return typeof o == "function" ? o(s) : s[o] } const jx = (e, t) => { const { transform: n = "none" } = getComputedStyle(e); return $l(n, t) }; function Bx(e) { return parseFloat(e.trim()) } const Cr = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"], Pr = (() => new Set(Cr))(), Pd = e => e === Tr || e === D, zx = new Set(["x", "y", "z"]), Ux = Cr.filter(e => !zx.has(e)); function $x(e) { const t = []; return Ux.forEach(n => { const r = e.getValue(n); r !== void 0 && (t.push([n, r.get()]), r.set(n.startsWith("scale") ? 1 : 0)) }), t } const Xt = { width: ({ x: e }, { paddingLeft: t = "0", paddingRight: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), height: ({ y: e }, { paddingTop: t = "0", paddingBottom: n = "0" }) => e.max - e.min - parseFloat(t) - parseFloat(n), top: (e, { top: t }) => parseFloat(t), left: (e, { left: t }) => parseFloat(t), bottom: ({ y: e }, { top: t }) => parseFloat(t) + (e.max - e.min), right: ({ x: e }, { left: t }) => parseFloat(t) + (e.max - e.min), x: (e, { transform: t }) => $l(t, "x"), y: (e, { transform: t }) => $l(t, "y") }; Xt.translateX = Xt.x; Xt.translateY = Xt.y; const kn = new Set; let bl = !1, Wl = !1, Hl = !1; function Jy() { if (Wl) { const e = Array.from(kn).filter(r => r.needsMeasurement), t = new Set(e.map(r => r.element)), n = new Map; t.forEach(r => { const i = $x(r); i.length && (n.set(r, i), r.render()) }), e.forEach(r => r.measureInitialState()), t.forEach(r => { r.render(); const i = n.get(r); i && i.forEach(([o, s]) => { var a; (a = r.getValue(o)) == null || a.set(s) }) }), e.forEach(r => r.measureEndState()), e.forEach(r => { r.suspendedScrollY !== void 0 && window.scrollTo(0, r.suspendedScrollY) }) } Wl = !1, bl = !1, kn.forEach(e => e.complete(Hl)), kn.clear() } function Zy() { kn.forEach(e => { e.readKeyframes(), e.needsMeasurement && (Wl = !0) }) } function bx() { Hl = !0, Zy(), Jy(), Hl = !1 } class Rc { constructor(t, n, r, i, o, s = !1) { this.state = "pending", this.isAsync = !1, this.needsMeasurement = !1, this.unresolvedKeyframes = [...t], this.onComplete = n, this.name = r, this.motionValue = i, this.element = o, this.isAsync = s } scheduleResolve() { this.state = "scheduled", this.isAsync ? (kn.add(this), bl || (bl = !0, H.read(Zy), H.resolveKeyframes(Jy))) : (this.readKeyframes(), this.complete()) } readKeyframes() { const { unresolvedKeyframes: t, name: n, element: r, motionValue: i } = this; if (t[0] === null) { const o = i == null ? void 0 : i.get(), s = t[t.length - 1]; if (o !== void 0) t[0] = o; else if (r && n) { const a = r.readValue(n, s); a != null && (t[0] = a) } t[0] === void 0 && (t[0] = s), i && o === void 0 && i.set(t[0]) } Vx(t) } setFinalKeyframe() { } measureInitialState() { } renderEndStyles() { } measureEndState() { } complete(t = !1) { this.state = "complete", this.onComplete(this.unresolvedKeyframes, this.finalKeyframe, t), kn.delete(this) } cancel() { this.state === "scheduled" && (kn.delete(this), this.state = "pending") } resume() { this.state === "pending" && this.scheduleResolve() } } const Wx = e => e.startsWith("--"); function Hx(e, t, n) { Wx(t) ? e.style.setProperty(t, n) : e.style[t] = n } const Kx = mc(() => window.ScrollTimeline !== void 0), Gx = {}; function Xx(e, t) { const n = mc(e); return () => Gx[t] ?? n() } const eg = Xx(() => { try { document.createElement("div").animate({ opacity: 0 }, { easing: "linear(0, 1)" }) } catch { return !1 } return !0 }, "linearEasing"), Wr = ([e, t, n, r]) => `cubic-bezier(${e}, ${t}, ${n}, ${r})`, kd = { linear: "linear", ease: "ease", easeIn: "ease-in", easeOut: "ease-out", easeInOut: "ease-in-out", circIn: Wr([0, .65, .55, 1]), circOut: Wr([.55, 0, 1, .45]), backIn: Wr([.31, .01, .66, -.59]), backOut: Wr([.33, 1.53, .69, .99]) }; function tg(e, t) { if (e) return typeof e == "function" ? eg() ? Yy(e, t) : "ease-out" : jy(e) ? Wr(e) : Array.isArray(e) ? e.map(n => tg(n, t) || kd.easeOut) : kd[e] } function Yx(e, t, n, { delay: r = 0, duration: i = 300, repeat: o = 0, repeatType: s = "loop", ease: a = "easeOut", times: l } = {}, u = void 0) { const c = { [t]: n }; l && (c.offset = l); const f = tg(a, i); Array.isArray(f) && (c.easing = f); const d = { delay: r, duration: i, easing: Array.isArray(f) ? "linear" : f, fill: "both", iterations: o + 1, direction: s === "reverse" ? "alternate" : "normal" }; return u && (d.pseudoElement = u), e.animate(c, d) } function ng(e) { return typeof e == "function" && "applyToOptions" in e } function Qx({ type: e, ...t }) { return ng(e) && eg() ? e.applyToOptions(t) : (t.duration ?? (t.duration = 300), t.ease ?? (t.ease = "easeOut"), t) } class qx extends Pc { constructor(t) { if (super(), this.finishedTime = null, this.isStopped = !1, this.manualStartTime = null, !t) return; const { element: n, name: r, keyframes: i, pseudoElement: o, allowFlatten: s = !1, finalKeyframe: a, onComplete: l } = t; this.isPseudoElement = !!o, this.allowFlatten = s, this.options = t, Mn(typeof t.type != "string", `Mini animate() doesn't support "type" as a string.`, "mini-spring"); const u = Qx(t); this.animation = Yx(n, r, i, u, o), u.autoplay === !1 && this.animation.pause(), this.animation.onfinish = () => { if (this.finishedTime = this.time, !o) { const c = Cc(i, this.options, a, this.speed); this.updateMotionValue ? this.updateMotionValue(c) : Hx(n, r, c), this.animation.cancel() } l == null || l(), this.notifyFinished() } } play() { this.isStopped || (this.manualStartTime = null, this.animation.play(), this.state === "finished" && this.updateFinished()) } pause() { this.animation.pause() } complete() { var t, n; (n = (t = this.animation).finish) == null || n.call(t) } cancel() { try { this.animation.cancel() } catch { } } stop() { if (this.isStopped) return; this.isStopped = !0; const { state: t } = this; t === "idle" || t === "finished" || (this.updateMotionValue ? this.updateMotionValue() : this.commitStyles(), this.isPseudoElement || this.cancel()) } commitStyles() { var t, n; this.isPseudoElement || (n = (t = this.animation).commitStyles) == null || n.call(t) } get duration() { var n, r; const t = ((r = (n = this.animation.effect) == null ? void 0 : n.getComputedTiming) == null ? void 0 : r.call(n).duration) || 0; return Je(Number(t)) } get iterationDuration() { const { delay: t = 0 } = this.options || {}; return this.duration + Je(t) } get time() { return Je(Number(this.animation.currentTime) || 0) } set time(t) { this.manualStartTime = null, this.finishedTime = null, this.animation.currentTime = Et(t) } get speed() { return this.animation.playbackRate } set speed(t) { t < 0 && (this.finishedTime = null), this.animation.playbackRate = t } get state() { return this.finishedTime !== null ? "finished" : this.animation.playState } get startTime() { return this.manualStartTime ?? Number(this.animation.startTime) } set startTime(t) { this.manualStartTime = this.animation.startTime = t } attachTimeline({ timeline: t, observe: n }) { var r; return this.allowFlatten && ((r = this.animation.effect) == null || r.updateTiming({ easing: "linear" })), this.animation.onfinish = null, t && Kx() ? (this.animation.timeline = t, et) : n(this) } } const rg = { anticipate: Ny, backInOut: Oy, circInOut: Iy }; function Jx(e) { return e in rg } function Zx(e) { typeof e.ease == "string" && Jx(e.ease) && (e.ease = rg[e.ease]) } const Ca = 10; class eE extends qx { constructor(t) { Zx(t), qy(t), super(t), t.startTime !== void 0 && (this.startTime = t.startTime), this.options = t } updateMotionValue(t) { const { motionValue: n, onUpdate: r, onComplete: i, element: o, ...s } = this.options; if (!n) return; if (t !== void 0) { n.set(t); return } const a = new kc({ ...s, autoplay: !1 }), l = Math.max(Ca, ke.now() - this.startTime), u = Ct(0, Ca, l - Ca); n.setWithVelocity(a.sample(Math.max(0, l - u)).value, a.sample(l).value, u), a.stop() } } const Rd = (e, t) => t === "zIndex" ? !1 : !!(typeof e == "number" || Array.isArray(e) || typeof e == "string" && (an.test(e) || e === "0") && !e.startsWith("url(")); function tE(e) { const t = e[0]; if (e.length === 1) return !0; for (let n = 0; n < e.length; n++)if (e[n] !== t) return !0 } function nE(e, t, n, r) { const i = e[0]; if (i === null) return !1; if (t === "display" || t === "visibility") return !0; const o = e[e.length - 1], s = Rd(i, t), a = Rd(o, t); return Vi(s === a, `You are trying to animate ${t} from "${i}" to "${o}". "${s ? o : i}" is not an animatable value.`, "value-not-animatable"), !s || !a ? !1 : tE(e) || (n === "spring" || ng(n)) && r } function Kl(e) { e.duration = 0, e.type = "keyframes" } const rE = new Set(["opacity", "clipPath", "filter", "transform"]), iE = mc(() => Object.hasOwnProperty.call(Element.prototype, "animate")); function oE(e) { var c; const { motionValue: t, name: n, repeatDelay: r, repeatType: i, damping: o, type: s } = e; if (!(((c = t == null ? void 0 : t.owner) == null ? void 0 : c.current) instanceof HTMLElement)) return !1; const { onUpdate: l, transformTemplate: u } = t.owner.getProps(); return iE() && n && rE.has(n) && (n !== "transform" || !u) && !l && !r && i !== "mirror" && o !== 0 && s !== "inertia" } const sE = 40; class aE extends Pc { constructor({ autoplay: t = !0, delay: n = 0, type: r = "keyframes", repeat: i = 0, repeatDelay: o = 0, repeatType: s = "loop", keyframes: a, name: l, motionValue: u, element: c, ...f }) { var y; super(), this.stop = () => { var v, S; this._animation && (this._animation.stop(), (v = this.stopTimeline) == null || v.call(this)), (S = this.keyframeResolver) == null || S.cancel() }, this.createdAt = ke.now(); const d = { autoplay: t, delay: n, type: r, repeat: i, repeatDelay: o, repeatType: s, name: l, motionValue: u, element: c, ...f }, g = (c == null ? void 0 : c.KeyframeResolver) || Rc; this.keyframeResolver = new g(a, (v, S, p) => this.onKeyframesResolved(v, S, d, !p), l, u, c), (y = this.keyframeResolver) == null || y.scheduleResolve() } onKeyframesResolved(t, n, r, i) { this.keyframeResolver = void 0; const { name: o, type: s, velocity: a, delay: l, isHandoff: u, onUpdate: c } = r; this.resolvedAt = ke.now(), nE(t, o, s, a) || ((Ft.instantAnimations || !l) && (c == null || c(Cc(t, r, n))), t[0] = t[t.length - 1], Kl(r), r.repeat = 0); const d = { startTime: i ? this.resolvedAt ? this.resolvedAt - this.createdAt > sE ? this.resolvedAt : this.createdAt : this.createdAt : void 0, finalKeyframe: n, ...r, keyframes: t }, g = !u && oE(d) ? new eE({ ...d, element: d.motionValue.owner.current }) : new kc(d); g.finished.then(() => this.notifyFinished()).catch(et), this.pendingTimeline && (this.stopTimeline = g.attachTimeline(this.pendingTimeline), this.pendingTimeline = void 0), this._animation = g } get finished() { return this._animation ? this.animation.finished : this._finished } then(t, n) { return this.finished.finally(t).then(() => { }) } get animation() { var t; return this._animation || ((t = this.keyframeResolver) == null || t.resume(), bx()), this._animation } get duration() { return this.animation.duration } get iterationDuration() { return this.animation.iterationDuration } get time() { return this.animation.time } set time(t) { this.animation.time = t } get speed() { return this.animation.speed } get state() { return this.animation.state } set speed(t) { this.animation.speed = t } get startTime() { return this.animation.startTime } attachTimeline(t) { return this._animation ? this.stopTimeline = this.animation.attachTimeline(t) : this.pendingTimeline = t, () => this.stop() } play() { this.animation.play() } pause() { this.animation.pause() } complete() { this.animation.complete() } cancel() { var t; this._animation && this.animation.cancel(), (t = this.keyframeResolver) == null || t.cancel() } } const lE = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u; function uE(e) { const t = lE.exec(e); if (!t) return [,]; const [, n, r, i] = t; return [`--${n ?? r}`, i] } const cE = 4; function ig(e, t, n = 1) { Mn(n <= cE, `Max CSS variable fallback depth detected in property "${e}". This may indicate a circular fallback dependency.`, "max-css-var-depth"); const [r, i] = uE(e); if (!r) return; const o = window.getComputedStyle(t).getPropertyValue(r); if (o) { const s = o.trim(); return Py(s) ? parseFloat(s) : s } return wc(i) ? ig(i, t, n + 1) : i } function Ac(e, t) { return (e == null ? void 0 : e[t]) ?? (e == null ? void 0 : e.default) ?? e } const og = new Set(["width", "height", "top", "left", "right", "bottom", ...Cr]), fE = { test: e => e === "auto", parse: e => e }, sg = e => t => t.test(e), ag = [Tr, D, Tt, Ut, tx, ex, fE], Ad = e => ag.find(sg(e)); function dE(e) { return typeof e == "number" ? e === 0 : e !== null ? e === "none" || e === "0" || Ry(e) : !0 } const hE = new Set(["brightness", "contrast", "saturate", "opacity"]); function pE(e) { const [t, n] = e.slice(0, -1).split("("); if (t === "drop-shadow") return e; const [r] = n.match(Sc) || []; if (!r) return e; const i = n.replace(r, ""); let o = hE.has(t) ? 1 : 0; return r !== n && (o *= 100), t + "(" + o + i + ")" } const mE = /\b([a-z-]*)\(.*?\)/gu, Gl = { ...an, getAnimatableNone: e => { const t = e.match(mE); return t ? t.map(pE).join(" ") : e } }, Ld = { ...Tr, transform: Math.round }, yE = { rotate: Ut, rotateX: Ut, rotateY: Ut, rotateZ: Ut, scale: uo, scaleX: uo, scaleY: uo, scaleZ: uo, skew: Ut, skewX: Ut, skewY: Ut, distance: D, translateX: D, translateY: D, translateZ: D, x: D, y: D, z: D, perspective: D, transformPerspective: D, opacity: Ci, originX: gd, originY: gd, originZ: D }, Lc = { borderWidth: D, borderTopWidth: D, borderRightWidth: D, borderBottomWidth: D, borderLeftWidth: D, borderRadius: D, radius: D, borderTopLeftRadius: D, borderTopRightRadius: D, borderBottomRightRadius: D, borderBottomLeftRadius: D, width: D, maxWidth: D, height: D, maxHeight: D, top: D, right: D, bottom: D, left: D, inset: D, insetBlock: D, insetBlockStart: D, insetBlockEnd: D, insetInline: D, insetInlineStart: D, insetInlineEnd: D, padding: D, paddingTop: D, paddingRight: D, paddingBottom: D, paddingLeft: D, paddingBlock: D, paddingBlockStart: D, paddingBlockEnd: D, paddingInline: D, paddingInlineStart: D, paddingInlineEnd: D, margin: D, marginTop: D, marginRight: D, marginBottom: D, marginLeft: D, marginBlock: D, marginBlockStart: D, marginBlockEnd: D, marginInline: D, marginInlineStart: D, marginInlineEnd: D, backgroundPositionX: D, backgroundPositionY: D, ...yE, zIndex: Ld, fillOpacity: Ci, strokeOpacity: Ci, numOctaves: Ld }, gE = { ...Lc, color: re, backgroundColor: re, outlineColor: re, fill: re, stroke: re, borderColor: re, borderTopColor: re, borderRightColor: re, borderBottomColor: re, borderLeftColor: re, filter: Gl, WebkitFilter: Gl }, lg = e => gE[e]; function ug(e, t) { let n = lg(e); return n !== Gl && (n = an), n.getAnimatableNone ? n.getAnimatableNone(t) : void 0 } const vE = new Set(["auto", "none", "0"]); function wE(e, t, n) { let r = 0, i; for (; r < e.length && !i;) { const o = e[r]; typeof o == "string" && !vE.has(o) && Pi(o).values.length && (i = e[r]), r++ } if (i && n) for (const o of t) e[o] = ug(n, i) } class SE extends Rc { constructor(t, n, r, i, o) { super(t, n, r, i, o, !0) } readKeyframes() { const { unresolvedKeyframes: t, element: n, name: r } = this; if (!n || !n.current) return; super.readKeyframes(); for (let c = 0; c < t.length; c++) { let f = t[c]; if (typeof f == "string" && (f = f.trim(), wc(f))) { const d = ig(f, n.current); d !== void 0 && (t[c] = d), c === t.length - 1 && (this.finalKeyframe = f) } } if (this.resolveNoneKeyframes(), !og.has(r) || t.length !== 2) return; const [i, o] = t, s = Ad(i), a = Ad(o), l = yd(i), u = yd(o); if (l !== u && Xt[r]) { this.needsMeasurement = !0; return } if (s !== a) if (Pd(s) && Pd(a)) for (let c = 0; c < t.length; c++) { const f = t[c]; typeof f == "string" && (t[c] = parseFloat(f)) } else Xt[r] && (this.needsMeasurement = !0) } resolveNoneKeyframes() { const { unresolvedKeyframes: t, name: n } = this, r = []; for (let i = 0; i < t.length; i++)(t[i] === null || dE(t[i])) && r.push(i); r.length && wE(t, r, n) } measureInitialState() { const { element: t, unresolvedKeyframes: n, name: r } = this; if (!t || !t.current) return; r === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = Xt[r](t.measureViewportBox(), window.getComputedStyle(t.current)), n[0] = this.measuredOrigin; const i = n[n.length - 1]; i !== void 0 && t.getValue(r, i).jump(i, !1) } measureEndState() { var a; const { element: t, name: n, unresolvedKeyframes: r } = this; if (!t || !t.current) return; const i = t.getValue(n); i && i.jump(this.measuredOrigin, !1); const o = r.length - 1, s = r[o]; r[o] = Xt[n](t.measureViewportBox(), window.getComputedStyle(t.current)), s !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = s), (a = this.removedTransforms) != null && a.length && this.removedTransforms.forEach(([l, u]) => { t.getValue(l).set(u) }), this.resolveNoneKeyframes() } } function xE(e, t, n) { if (e instanceof EventTarget) return [e]; if (typeof e == "string") { let r = document; t && (r = t.current); const i = (n == null ? void 0 : n[e]) ?? r.querySelectorAll(e); return i ? Array.from(i) : [] } return Array.from(e) } const cg = (e, t) => t && typeof e == "number" ? t.transform(e) : e; function fg(e) { return ky(e) && "offsetHeight" in e } const Dd = 30, EE = e => !isNaN(parseFloat(e)); class TE { constructor(t, n = {}) { this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = r => { var o; const i = ke.now(); if (this.updatedAt !== i && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(r), this.current !== this.prev && ((o = this.events.change) == null || o.notify(this.current), this.dependents)) for (const s of this.dependents) s.dirty() }, this.hasAnimated = !1, this.setCurrent(t), this.owner = n.owner } setCurrent(t) { this.current = t, this.updatedAt = ke.now(), this.canTrackVelocity === null && t !== void 0 && (this.canTrackVelocity = EE(this.current)) } setPrevFrameValue(t = this.current) { this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt } onChange(t) { return this.on("change", t) } on(t, n) { this.events[t] || (this.events[t] = new yc); const r = this.events[t].add(n); return t === "change" ? () => { r(), H.read(() => { this.events.change.getSize() || this.stop() }) } : r } clearListeners() { for (const t in this.events) this.events[t].clear() } attach(t, n) { this.passiveEffect = t, this.stopPassiveEffect = n } set(t) { this.passiveEffect ? this.passiveEffect(t, this.updateAndNotify) : this.updateAndNotify(t) } setWithVelocity(t, n, r) { this.set(n), this.prev = void 0, this.prevFrameValue = t, this.prevUpdatedAt = this.updatedAt - r } jump(t, n = !0) { this.updateAndNotify(t), this.prev = t, this.prevUpdatedAt = this.prevFrameValue = void 0, n && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } dirty() { var t; (t = this.events.change) == null || t.notify(this.current) } addDependent(t) { this.dependents || (this.dependents = new Set), this.dependents.add(t) } removeDependent(t) { this.dependents && this.dependents.delete(t) } get() { return this.current } getPrevious() { return this.prev } getVelocity() { const t = ke.now(); if (!this.canTrackVelocity || this.prevFrameValue === void 0 || t - this.updatedAt > Dd) return 0; const n = Math.min(this.updatedAt - this.prevUpdatedAt, Dd); return Ay(parseFloat(this.current) - parseFloat(this.prevFrameValue), n) } start(t) { return this.stop(), new Promise(n => { this.hasAnimated = !0, this.animation = t(n), this.events.animationStart && this.events.animationStart.notify() }).then(() => { this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation() }) } stop() { this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation() } isAnimating() { return !!this.animation } clearAnimation() { delete this.animation } destroy() { var t, n; (t = this.dependents) == null || t.clear(), (n = this.events.destroy) == null || n.notify(), this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect() } } function pr(e, t) { return new TE(e, t) } const { schedule: Dc, cancel: FR } = By(queueMicrotask, !1), st = { x: !1, y: !1 }; function dg() { return st.x || st.y } function CE(e) { return e === "x" || e === "y" ? st[e] ? null : (st[e] = !0, () => { st[e] = !1 }) : st.x || st.y ? null : (st.x = st.y = !0, () => { st.x = st.y = !1 }) } function hg(e, t) { const n = xE(e), r = new AbortController, i = { passive: !0, ...t, signal: r.signal }; return [n, i, () => r.abort()] } function _d(e) { return !(e.pointerType === "touch" || dg()) } function PE(e, t, n = {}) { const [r, i, o] = hg(e, n), s = a => { if (!_d(a)) return; const { target: l } = a, u = t(l, a); if (typeof u != "function" || !l) return; const c = f => { _d(f) && (u(f), l.removeEventListener("pointerleave", c)) }; l.addEventListener("pointerleave", c, i) }; return r.forEach(a => { a.addEventListener("pointerenter", s, i) }), o } const pg = (e, t) => t ? e === t ? !0 : pg(e, t.parentElement) : !1, _c = e => e.pointerType === "mouse" ? typeof e.button != "number" || e.button <= 0 : e.isPrimary !== !1, kE = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]); function mg(e) { return kE.has(e.tagName) || e.isContentEditable === !0 } const Lo = new WeakSet; function Md(e) { return t => { t.key === "Enter" && e(t) } } function Pa(e, t) { e.dispatchEvent(new PointerEvent("pointer" + t, { isPrimary: !0, bubbles: !0 })) } const RE = (e, t) => { const n = e.currentTarget; if (!n) return; const r = Md(() => { if (Lo.has(n)) return; Pa(n, "down"); const i = Md(() => { Pa(n, "up") }), o = () => Pa(n, "cancel"); n.addEventListener("keyup", i, t), n.addEventListener("blur", o, t) }); n.addEventListener("keydown", r, t), n.addEventListener("blur", () => n.removeEventListener("keydown", r), t) }; function Od(e) { return _c(e) && !dg() } function AE(e, t, n = {}) { const [r, i, o] = hg(e, n), s = a => { const l = a.currentTarget; if (!Od(a)) return; Lo.add(l); const u = t(l, a), c = (g, y) => { window.removeEventListener("pointerup", f), window.removeEventListener("pointercancel", d), Lo.has(l) && Lo.delete(l), Od(g) && typeof u == "function" && u(g, { success: y }) }, f = g => { c(g, l === window || l === document || n.useGlobalTarget || pg(l, g.target)) }, d = g => { c(g, !1) }; window.addEventListener("pointerup", f, i), window.addEventListener("pointercancel", d, i) }; return r.forEach(a => { (n.useGlobalTarget ? window : a).addEventListener("pointerdown", s, i), fg(a) && (a.addEventListener("focus", u => RE(u, i)), !mg(a) && !a.hasAttribute("tabindex") && (a.tabIndex = 0)) }), o } function yg(e) { return ky(e) && "ownerSVGElement" in e } function LE(e) { return yg(e) && e.tagName === "svg" } const xe = e => !!(e && e.getVelocity), DE = [...ag, re, an], _E = e => DE.find(sg(e)), Mc = w.createContext({ transformPagePoint: e => e, isStatic: !1, reducedMotion: "never" }); function Nd(e, t) { if (typeof e == "function") return e(t); e != null && (e.current = t) } function ME(...e) { return t => { let n = !1; const r = e.map(i => { const o = Nd(i, t); return !n && typeof o == "function" && (n = !0), o }); if (n) return () => { for (let i = 0; i < r.length; i++) { const o = r[i]; typeof o == "function" ? o() : Nd(e[i], null) } } } } function OE(...e) { return w.useCallback(ME(...e), e) } class NE extends w.Component { getSnapshotBeforeUpdate(t) { const n = this.props.childRef.current; if (n && t.isPresent && !this.props.isPresent) { const r = n.offsetParent, i = fg(r) && r.offsetWidth || 0, o = this.props.sizeRef.current; o.height = n.offsetHeight || 0, o.width = n.offsetWidth || 0, o.top = n.offsetTop, o.left = n.offsetLeft, o.right = i - o.width - o.left } return null } componentDidUpdate() { } render() { return this.props.children } } function VE({ children: e, isPresent: t, anchorX: n, root: r }) {
  var c; const i = w.useId(), o = w.useRef(null), s = w.useRef({ width: 0, height: 0, top: 0, left: 0, right: 0 }), { nonce: a } = w.useContext(Mc), l = ((c = e.props) == null ? void 0 : c.ref) ?? (e == null ? void 0 : e.ref), u = OE(o, l); return w.useInsertionEffect(() => {
    const { width: f, height: d, top: g, left: y, right: v } = s.current; if (t || !o.current || !f || !d) return; const S = n === "left" ? `left: ${y}` : `right: ${v}`; o.current.dataset.motionPopId = i; const p = document.createElement("style"); a && (p.nonce = a); const h = r ?? document.head; return h.appendChild(p), p.sheet && p.sheet.insertRule(`
          [data-motion-pop-id="${i}"] {
            position: absolute !important;
            width: ${f}px !important;
            height: ${d}px !important;
            ${S}px !important;
            top: ${g}px !important;
          }
        `), () => { h.contains(p) && h.removeChild(p) }
  }, [t]), R.jsx(NE, { isPresent: t, childRef: o, sizeRef: s, children: w.cloneElement(e, { ref: u }) })
} const IE = ({ children: e, initial: t, isPresent: n, onExitComplete: r, custom: i, presenceAffectsLayout: o, mode: s, anchorX: a, root: l }) => { const u = fc(FE), c = w.useId(); let f = !0, d = w.useMemo(() => (f = !1, { id: c, initial: t, isPresent: n, custom: i, onExitComplete: g => { u.set(g, !0); for (const y of u.values()) if (!y) return; r && r() }, register: g => (u.set(g, !1), () => u.delete(g)) }), [n, u, r]); return o && f && (d = { ...d }), w.useMemo(() => { u.forEach((g, y) => u.set(y, !1)) }, [n]), w.useEffect(() => { !n && !u.size && r && r() }, [n]), s === "popLayout" && (e = R.jsx(VE, { isPresent: n, anchorX: a, root: l, children: e })), R.jsx(Ns.Provider, { value: d, children: e }) }; function FE() { return new Map } function gg(e = !0) { const t = w.useContext(Ns); if (t === null) return [!0, null]; const { isPresent: n, onExitComplete: r, register: i } = t, o = w.useId(); w.useEffect(() => { if (e) return i(o) }, [e]); const s = w.useCallback(() => e && r && r(o), [o, r, e]); return !n && r ? [!1, s] : [!0] } const co = e => e.key || ""; function Vd(e) { const t = []; return w.Children.forEach(e, n => { w.isValidElement(n) && t.push(n) }), t } const vg = ({ children: e, custom: t, initial: n = !0, onExitComplete: r, presenceAffectsLayout: i = !0, mode: o = "sync", propagate: s = !1, anchorX: a = "left", root: l }) => { const [u, c] = gg(s), f = w.useMemo(() => Vd(e), [e]), d = s && !u ? [] : f.map(co), g = w.useRef(!0), y = w.useRef(f), v = fc(() => new Map), S = w.useRef(new Set), [p, h] = w.useState(f), [m, x] = w.useState(f); Cy(() => { g.current = !1, y.current = f; for (let P = 0; P < m.length; P++) { const C = co(m[P]); d.includes(C) ? (v.delete(C), S.current.delete(C)) : v.get(C) !== !0 && v.set(C, !1) } }, [m, d.length, d.join("-")]); const E = []; if (f !== p) { let P = [...f]; for (let C = 0; C < m.length; C++) { const O = m[C], M = co(O); d.includes(M) || (P.splice(C, 0, O), E.push(O)) } return o === "wait" && E.length && (P = E), x(Vd(P)), h(f), null } const { forceRender: k } = w.useContext(cc); return R.jsx(R.Fragment, { children: m.map(P => { const C = co(P), O = s && !u ? !1 : f === m || d.includes(C), M = () => { if (S.current.has(C)) return; if (S.current.add(C), v.has(C)) v.set(C, !0); else return; let K = !0; v.forEach(Te => { Te || (K = !1) }), K && (k == null || k(), x(y.current), s && (c == null || c()), r && r()) }; return R.jsx(IE, { isPresent: O, initial: !g.current || n ? void 0 : !1, custom: t, presenceAffectsLayout: i, mode: o, root: l, onExitComplete: O ? void 0 : M, anchorX: a, children: P }, C) }) }) }, wg = w.createContext({ strict: !1 }), Id = { animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"], exit: ["exit"], drag: ["drag", "dragControls"], focus: ["whileFocus"], hover: ["whileHover", "onHoverStart", "onHoverEnd"], tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"], pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"], inView: ["whileInView", "onViewportEnter", "onViewportLeave"], layout: ["layout", "layoutId"] }, mr = {}; for (const e in Id) mr[e] = { isEnabled: t => Id[e].some(n => !!t[n]) }; function jE(e) { for (const t in e) mr[t] = { ...mr[t], ...e[t] } } const BE = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]); function fs(e) { return e.startsWith("while") || e.startsWith("drag") && e !== "draggable" || e.startsWith("layout") || e.startsWith("onTap") || e.startsWith("onPan") || e.startsWith("onLayout") || BE.has(e) } let Sg = e => !fs(e); function zE(e) { typeof e == "function" && (Sg = t => t.startsWith("on") ? !fs(t) : e(t)) } try { zE(require("@emotion/is-prop-valid").default) } catch { } function UE(e, t, n) { const r = {}; for (const i in e) i === "values" && typeof e.values == "object" || (Sg(i) || n === !0 && fs(i) || !t && !fs(i) || e.draggable && i.startsWith("onDrag")) && (r[i] = e[i]); return r } const Vs = w.createContext({}); function Is(e) { return e !== null && typeof e == "object" && typeof e.start == "function" } function ki(e) { return typeof e == "string" || Array.isArray(e) } const Oc = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"], Nc = ["initial", ...Oc]; function Fs(e) { return Is(e.animate) || Nc.some(t => ki(e[t])) } function xg(e) { return !!(Fs(e) || e.variants) } function $E(e, t) { if (Fs(e)) { const { initial: n, animate: r } = e; return { initial: n === !1 || ki(n) ? n : void 0, animate: ki(r) ? r : void 0 } } return e.inherit !== !1 ? t : {} } function bE(e) { const { initial: t, animate: n } = $E(e, w.useContext(Vs)); return w.useMemo(() => ({ initial: t, animate: n }), [Fd(t), Fd(n)]) } function Fd(e) { return Array.isArray(e) ? e.join(" ") : e } function jd(e, t) { return t.max === t.min ? 0 : e / (t.max - t.min) * 100 } const jr = { correct: (e, t) => { if (!t.target) return e; if (typeof e == "string") if (D.test(e)) e = parseFloat(e); else return e; const n = jd(e, t.target.x), r = jd(e, t.target.y); return `${n}% ${r}%` } }, WE = { correct: (e, { treeScale: t, projectionDelta: n }) => { const r = e, i = an.parse(e); if (i.length > 5) return r; const o = an.createTransformer(e), s = typeof i[0] != "number" ? 1 : 0, a = n.x.scale * t.x, l = n.y.scale * t.y; i[0 + s] /= a, i[1 + s] /= l; const u = J(a, l, .5); return typeof i[2 + s] == "number" && (i[2 + s] /= u), typeof i[3 + s] == "number" && (i[3 + s] /= u), o(i) } }, Xl = { borderRadius: { ...jr, applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"] }, borderTopLeftRadius: jr, borderTopRightRadius: jr, borderBottomLeftRadius: jr, borderBottomRightRadius: jr, boxShadow: WE }; function Eg(e, { layout: t, layoutId: n }) { return Pr.has(e) || e.startsWith("origin") || (t || n !== void 0) && (!!Xl[e] || e === "opacity") } const HE = { x: "translateX", y: "translateY", z: "translateZ", transformPerspective: "perspective" }, KE = Cr.length; function GE(e, t, n) { let r = "", i = !0; for (let o = 0; o < KE; o++) { const s = Cr[o], a = e[s]; if (a === void 0) continue; let l = !0; if (typeof a == "number" ? l = a === (s.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || n) { const u = cg(a, Lc[s]); if (!l) { i = !1; const c = HE[s] || s; r += `${c}(${u}) ` } n && (t[s] = u) } } return r = r.trim(), n ? r = n(t, i ? "" : r) : i && (r = "none"), r } function Vc(e, t, n) { const { style: r, vars: i, transformOrigin: o } = e; let s = !1, a = !1; for (const l in t) { const u = t[l]; if (Pr.has(l)) { s = !0; continue } else if (Uy(l)) { i[l] = u; continue } else { const c = cg(u, Lc[l]); l.startsWith("origin") ? (a = !0, o[l] = c) : r[l] = c } } if (t.transform || (s || n ? r.transform = GE(t, e.transform, n) : r.transform && (r.transform = "none")), a) { const { originX: l = "50%", originY: u = "50%", originZ: c = 0 } = o; r.transformOrigin = `${l} ${u} ${c}` } } const Ic = () => ({ style: {}, transform: {}, transformOrigin: {}, vars: {} }); function Tg(e, t, n) { for (const r in t) !xe(t[r]) && !Eg(r, n) && (e[r] = t[r]) } function XE({ transformTemplate: e }, t) { return w.useMemo(() => { const n = Ic(); return Vc(n, t, e), Object.assign({}, n.vars, n.style) }, [t]) } function YE(e, t) { const n = e.style || {}, r = {}; return Tg(r, n, e), Object.assign(r, XE(e, t)), r } function QE(e, t) { const n = {}, r = YE(e, t); return e.drag && e.dragListener !== !1 && (n.draggable = !1, r.userSelect = r.WebkitUserSelect = r.WebkitTouchCallout = "none", r.touchAction = e.drag === !0 ? "none" : `pan-${e.drag === "x" ? "y" : "x"}`), e.tabIndex === void 0 && (e.onTap || e.onTapStart || e.whileTap) && (n.tabIndex = 0), n.style = r, n } const qE = { offset: "stroke-dashoffset", array: "stroke-dasharray" }, JE = { offset: "strokeDashoffset", array: "strokeDasharray" }; function ZE(e, t, n = 1, r = 0, i = !0) { e.pathLength = 1; const o = i ? qE : JE; e[o.offset] = D.transform(-r); const s = D.transform(t), a = D.transform(n); e[o.array] = `${s} ${a}` } const eT = ["offsetDistance", "offsetPath", "offsetRotate", "offsetAnchor"]; function Cg(e, { attrX: t, attrY: n, attrScale: r, pathLength: i, pathSpacing: o = 1, pathOffset: s = 0, ...a }, l, u, c) { if (Vc(e, a, u), l) { e.style.viewBox && (e.attrs.viewBox = e.style.viewBox); return } e.attrs = e.style, e.style = {}; const { attrs: f, style: d } = e; f.transform && (d.transform = f.transform, delete f.transform), (d.transform || f.transformOrigin) && (d.transformOrigin = f.transformOrigin ?? "50% 50%", delete f.transformOrigin), d.transform && (d.transformBox = (c == null ? void 0 : c.transformBox) ?? "fill-box", delete f.transformBox); for (const g of eT) f[g] !== void 0 && (d[g] = f[g], delete f[g]); t !== void 0 && (f.x = t), n !== void 0 && (f.y = n), r !== void 0 && (f.scale = r), i !== void 0 && ZE(f, i, o, s, !1) } const Pg = () => ({ ...Ic(), attrs: {} }), kg = e => typeof e == "string" && e.toLowerCase() === "svg"; function tT(e, t, n, r) { const i = w.useMemo(() => { const o = Pg(); return Cg(o, t, kg(r), e.transformTemplate, e.style), { ...o.attrs, style: { ...o.style } } }, [t]); if (e.style) { const o = {}; Tg(o, e.style, e), i.style = { ...o, ...i.style } } return i } const nT = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"]; function Fc(e) { return typeof e != "string" || e.includes("-") ? !1 : !!(nT.indexOf(e) > -1 || /[A-Z]/u.test(e)) } function rT(e, t, n, { latestValues: r }, i, o = !1, s) { const l = (s ?? Fc(e) ? tT : QE)(t, r, i, e), u = UE(t, typeof e == "string", o), c = e !== w.Fragment ? { ...u, ...l, ref: n } : {}, { children: f } = t, d = w.useMemo(() => xe(f) ? f.get() : f, [f]); return w.createElement(e, { ...c, children: d }) } function Bd(e) { const t = [{}, {}]; return e == null || e.values.forEach((n, r) => { t[0][r] = n.get(), t[1][r] = n.getVelocity() }), t } function jc(e, t, n, r) { if (typeof t == "function") { const [i, o] = Bd(r); t = t(n !== void 0 ? n : e.custom, i, o) } if (typeof t == "string" && (t = e.variants && e.variants[t]), typeof t == "function") { const [i, o] = Bd(r); t = t(n !== void 0 ? n : e.custom, i, o) } return t } function Do(e) { return xe(e) ? e.get() : e } function iT({ scrapeMotionValuesFromProps: e, createRenderState: t }, n, r, i) { return { latestValues: oT(n, r, i, e), renderState: t() } } function oT(e, t, n, r) { const i = {}, o = r(e, {}); for (const d in o) i[d] = Do(o[d]); let { initial: s, animate: a } = e; const l = Fs(e), u = xg(e); t && u && !l && e.inherit !== !1 && (s === void 0 && (s = t.initial), a === void 0 && (a = t.animate)); let c = n ? n.initial === !1 : !1; c = c || s === !1; const f = c ? a : s; if (f && typeof f != "boolean" && !Is(f)) { const d = Array.isArray(f) ? f : [f]; for (let g = 0; g < d.length; g++) { const y = jc(e, d[g]); if (y) { const { transitionEnd: v, transition: S, ...p } = y; for (const h in p) { let m = p[h]; if (Array.isArray(m)) { const x = c ? m.length - 1 : 0; m = m[x] } m !== null && (i[h] = m) } for (const h in v) i[h] = v[h] } } } return i } const Rg = e => (t, n) => { const r = w.useContext(Vs), i = w.useContext(Ns), o = () => iT(e, t, r, i); return n ? o() : fc(o) }; function Bc(e, t, n) { var o; const { style: r } = e, i = {}; for (const s in r) (xe(r[s]) || t.style && xe(t.style[s]) || Eg(s, e) || ((o = n == null ? void 0 : n.getValue(s)) == null ? void 0 : o.liveStyle) !== void 0) && (i[s] = r[s]); return i } const sT = Rg({ scrapeMotionValuesFromProps: Bc, createRenderState: Ic }); function Ag(e, t, n) { const r = Bc(e, t, n); for (const i in e) if (xe(e[i]) || xe(t[i])) { const o = Cr.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i; r[o] = e[i] } return r } const aT = Rg({ scrapeMotionValuesFromProps: Ag, createRenderState: Pg }), lT = Symbol.for("motionComponentSymbol"); function uT(e, t, n) { const r = w.useRef(n); w.useInsertionEffect(() => { r.current = n }); const i = w.useRef(null); return w.useCallback(o => { var a; o && ((a = e.onMount) == null || a.call(e, o)), t && (o ? t.mount(o) : t.unmount()); const s = r.current; if (typeof s == "function") if (o) { const l = s(o); typeof l == "function" && (i.current = l) } else i.current ? (i.current(), i.current = null) : s(o); else s && (s.current = o) }, [t]) } const zc = e => e.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(), cT = "framerAppearId", Lg = "data-" + zc(cT), Dg = w.createContext({}); function Hr(e) { return e && typeof e == "object" && Object.prototype.hasOwnProperty.call(e, "current") } function fT(e, t, n, r, i, o) { var S, p; const { visualElement: s } = w.useContext(Vs), a = w.useContext(wg), l = w.useContext(Ns), u = w.useContext(Mc).reducedMotion, c = w.useRef(null); r = r || a.renderer, !c.current && r && (c.current = r(e, { visualState: t, parent: s, props: n, presenceContext: l, blockInitialAnimation: l ? l.initial === !1 : !1, reducedMotionConfig: u, isSVG: o })); const f = c.current, d = w.useContext(Dg); f && !f.projection && i && (f.type === "html" || f.type === "svg") && dT(c.current, n, i, d); const g = w.useRef(!1); w.useInsertionEffect(() => { f && g.current && f.update(n, l) }); const y = n[Lg], v = w.useRef(!!y && !((S = window.MotionHandoffIsComplete) != null && S.call(window, y)) && ((p = window.MotionHasOptimisedAnimation) == null ? void 0 : p.call(window, y))); return Cy(() => { f && (g.current = !0, window.MotionIsMounted = !0, f.updateFeatures(), f.scheduleRenderMicrotask(), v.current && f.animationState && f.animationState.animateChanges()) }), w.useEffect(() => { f && (!v.current && f.animationState && f.animationState.animateChanges(), v.current && (queueMicrotask(() => { var h; (h = window.MotionHandoffMarkAsComplete) == null || h.call(window, y) }), v.current = !1), f.enteringChildren = void 0) }), f } function dT(e, t, n, r) { const { layoutId: i, layout: o, drag: s, dragConstraints: a, layoutScroll: l, layoutRoot: u, layoutCrossfade: c } = t; e.projection = new n(e.latestValues, t["data-framer-portal-id"] ? void 0 : _g(e.parent)), e.projection.setOptions({ layoutId: i, layout: o, alwaysMeasureLayout: !!s || a && Hr(a), visualElement: e, animationType: typeof o == "string" ? o : "both", initialPromotionConfig: r, crossfade: c, layoutScroll: l, layoutRoot: u }) } function _g(e) { if (e) return e.options.allowProjection !== !1 ? e.projection : _g(e.parent) } function ka(e, { forwardMotionProps: t = !1, type: n } = {}, r, i) { r && jE(r); const o = n ? n === "svg" : Fc(e), s = o ? aT : sT; function a(u, c) { let f; const d = { ...w.useContext(Mc), ...u, layoutId: hT(u) }, { isStatic: g } = d, y = bE(u), v = s(u, g); if (!g && dc) { pT(); const S = mT(d); f = S.MeasureLayout, y.visualElement = fT(e, v, d, i, S.ProjectionNode, o) } return R.jsxs(Vs.Provider, { value: y, children: [f && y.visualElement ? R.jsx(f, { visualElement: y.visualElement, ...d }) : null, rT(e, u, uT(v, y.visualElement, c), v, g, t, o)] }) } a.displayName = `motion.${typeof e == "string" ? e : `create(${e.displayName ?? e.name ?? ""})`}`; const l = w.forwardRef(a); return l[lT] = e, l } function hT({ layoutId: e }) { const t = w.useContext(cc).id; return t && e !== void 0 ? t + "-" + e : e } function pT(e, t) { w.useContext(wg).strict } function mT(e) { const { drag: t, layout: n } = mr; if (!t && !n) return {}; const r = { ...t, ...n }; return { MeasureLayout: t != null && t.isEnabled(e) || n != null && n.isEnabled(e) ? r.MeasureLayout : void 0, ProjectionNode: r.ProjectionNode } } function yT(e, t) { if (typeof Proxy > "u") return ka; const n = new Map, r = (o, s) => ka(o, s, e, t), i = (o, s) => r(o, s); return new Proxy(i, { get: (o, s) => s === "create" ? r : (n.has(s) || n.set(s, ka(s, void 0, e, t)), n.get(s)) }) } function Mg({ top: e, left: t, right: n, bottom: r }) { return { x: { min: t, max: n }, y: { min: e, max: r } } } function gT({ x: e, y: t }) { return { top: t.min, right: e.max, bottom: t.max, left: e.min } } function vT(e, t) { if (!t) return e; const n = t({ x: e.left, y: e.top }), r = t({ x: e.right, y: e.bottom }); return { top: n.y, left: n.x, bottom: r.y, right: r.x } } function Ra(e) { return e === void 0 || e === 1 } function Yl({ scale: e, scaleX: t, scaleY: n }) { return !Ra(e) || !Ra(t) || !Ra(n) } function gn(e) { return Yl(e) || Og(e) || e.z || e.rotate || e.rotateX || e.rotateY || e.skewX || e.skewY } function Og(e) { return zd(e.x) || zd(e.y) } function zd(e) { return e && e !== "0%" } function ds(e, t, n) { const r = e - n, i = t * r; return n + i } function Ud(e, t, n, r, i) { return i !== void 0 && (e = ds(e, i, r)), ds(e, n, r) + t } function Ql(e, t = 0, n = 1, r, i) { e.min = Ud(e.min, t, n, r, i), e.max = Ud(e.max, t, n, r, i) } function Ng(e, { x: t, y: n }) { Ql(e.x, t.translate, t.scale, t.originPoint), Ql(e.y, n.translate, n.scale, n.originPoint) } const $d = .999999999999, bd = 1.0000000000001; function wT(e, t, n, r = !1) { const i = n.length; if (!i) return; t.x = t.y = 1; let o, s; for (let a = 0; a < i; a++) { o = n[a], s = o.projectionDelta; const { visualElement: l } = o.options; l && l.props.style && l.props.style.display === "contents" || (r && o.options.layoutScroll && o.scroll && o !== o.root && Jn(e, { x: -o.scroll.offset.x, y: -o.scroll.offset.y }), s && (t.x *= s.x.scale, t.y *= s.y.scale, Ng(e, s)), r && gn(o.latestValues) && Jn(e, o.latestValues)) } t.x < bd && t.x > $d && (t.x = 1), t.y < bd && t.y > $d && (t.y = 1) } function qn(e, t) { e.min = e.min + t, e.max = e.max + t } function Wd(e, t, n, r, i = .5) { const o = J(e.min, e.max, i); Ql(e, t, n, o, r) } function Jn(e, t) { Wd(e.x, t.x, t.scaleX, t.scale, t.originX), Wd(e.y, t.y, t.scaleY, t.scale, t.originY) } function Vg(e, t) { return Mg(vT(e.getBoundingClientRect(), t)) } function ST(e, t, n) { const r = Vg(e, n), { scroll: i } = t; return i && (qn(r.x, i.offset.x), qn(r.y, i.offset.y)), r } const Hd = () => ({ translate: 0, scale: 1, origin: 0, originPoint: 0 }), Zn = () => ({ x: Hd(), y: Hd() }), Kd = () => ({ min: 0, max: 0 }), ae = () => ({ x: Kd(), y: Kd() }), ql = { current: null }, Ig = { current: !1 }; function xT() { if (Ig.current = !0, !!dc) if (window.matchMedia) { const e = window.matchMedia("(prefers-reduced-motion)"), t = () => ql.current = e.matches; e.addEventListener("change", t), t() } else ql.current = !1 } const ET = new WeakMap; function TT(e, t, n) { for (const r in t) { const i = t[r], o = n[r]; if (xe(i)) e.addValue(r, i); else if (xe(o)) e.addValue(r, pr(i, { owner: e })); else if (o !== i) if (e.hasValue(r)) { const s = e.getValue(r); s.liveStyle === !0 ? s.jump(i) : s.hasAnimated || s.set(i) } else { const s = e.getStaticValue(r); e.addValue(r, pr(s !== void 0 ? s : i, { owner: e })) } } for (const r in n) t[r] === void 0 && e.removeValue(r); return t } const Gd = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"]; class CT { scrapeMotionValuesFromProps(t, n, r) { return {} } constructor({ parent: t, props: n, presenceContext: r, reducedMotionConfig: i, blockInitialAnimation: o, visualState: s }, a = {}) { this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = Rc, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => { this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection)) }, this.renderScheduledAt = 0, this.scheduleRender = () => { const d = ke.now(); this.renderScheduledAt < d && (this.renderScheduledAt = d, H.render(this.render, !1, !0)) }; const { latestValues: l, renderState: u } = s; this.latestValues = l, this.baseTarget = { ...l }, this.initialValues = n.initial ? { ...l } : {}, this.renderState = u, this.parent = t, this.props = n, this.presenceContext = r, this.depth = t ? t.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!o, this.isControllingVariants = Fs(n), this.isVariantNode = xg(n), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(t && t.current); const { willChange: c, ...f } = this.scrapeMotionValuesFromProps(n, {}, this); for (const d in f) { const g = f[d]; l[d] !== void 0 && xe(g) && g.set(l[d]) } } mount(t) { var n; this.current = t, ET.set(t, this), this.projection && !this.projection.instance && this.projection.mount(t), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((r, i) => this.bindToMotionValue(i, r)), this.reducedMotionConfig === "never" ? this.shouldReduceMotion = !1 : this.reducedMotionConfig === "always" ? this.shouldReduceMotion = !0 : (Ig.current || xT(), this.shouldReduceMotion = ql.current), (n = this.parent) == null || n.addChild(this), this.update(this.props, this.presenceContext) } unmount() { var t; this.projection && this.projection.unmount(), sn(this.notifyUpdate), sn(this.render), this.valueSubscriptions.forEach(n => n()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), (t = this.parent) == null || t.removeChild(this); for (const n in this.events) this.events[n].clear(); for (const n in this.features) { const r = this.features[n]; r && (r.unmount(), r.isMounted = !1) } this.current = null } addChild(t) { this.children.add(t), this.enteringChildren ?? (this.enteringChildren = new Set), this.enteringChildren.add(t) } removeChild(t) { this.children.delete(t), this.enteringChildren && this.enteringChildren.delete(t) } bindToMotionValue(t, n) { this.valueSubscriptions.has(t) && this.valueSubscriptions.get(t)(); const r = Pr.has(t); r && this.onBindTransform && this.onBindTransform(); const i = n.on("change", s => { this.latestValues[t] = s, this.props.onUpdate && H.preRender(this.notifyUpdate), r && this.projection && (this.projection.isTransformDirty = !0), this.scheduleRender() }); let o; window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, t, n)), this.valueSubscriptions.set(t, () => { i(), o && o(), n.owner && n.stop() }) } sortNodePosition(t) { return !this.current || !this.sortInstanceNodePosition || this.type !== t.type ? 0 : this.sortInstanceNodePosition(this.current, t.current) } updateFeatures() { let t = "animation"; for (t in mr) { const n = mr[t]; if (!n) continue; const { isEnabled: r, Feature: i } = n; if (!this.features[t] && i && r(this.props) && (this.features[t] = new i(this)), this.features[t]) { const o = this.features[t]; o.isMounted ? o.update() : (o.mount(), o.isMounted = !0) } } } triggerBuild() { this.build(this.renderState, this.latestValues, this.props) } measureViewportBox() { return this.current ? this.measureInstanceViewportBox(this.current, this.props) : ae() } getStaticValue(t) { return this.latestValues[t] } setStaticValue(t, n) { this.latestValues[t] = n } update(t, n) { (t.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = t, this.prevPresenceContext = this.presenceContext, this.presenceContext = n; for (let r = 0; r < Gd.length; r++) { const i = Gd[r]; this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]); const o = "on" + i, s = t[o]; s && (this.propEventSubscriptions[i] = this.on(i, s)) } this.prevMotionValues = TT(this, this.scrapeMotionValuesFromProps(t, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue() } getProps() { return this.props } getVariant(t) { return this.props.variants ? this.props.variants[t] : void 0 } getDefaultTransition() { return this.props.transition } getTransformPagePoint() { return this.props.transformPagePoint } getClosestVariantNode() { return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0 } addVariantChild(t) { const n = this.getClosestVariantNode(); if (n) return n.variantChildren && n.variantChildren.add(t), () => n.variantChildren.delete(t) } addValue(t, n) { const r = this.values.get(t); n !== r && (r && this.removeValue(t), this.bindToMotionValue(t, n), this.values.set(t, n), this.latestValues[t] = n.get()) } removeValue(t) { this.values.delete(t); const n = this.valueSubscriptions.get(t); n && (n(), this.valueSubscriptions.delete(t)), delete this.latestValues[t], this.removeValueFromRenderState(t, this.renderState) } hasValue(t) { return this.values.has(t) } getValue(t, n) { if (this.props.values && this.props.values[t]) return this.props.values[t]; let r = this.values.get(t); return r === void 0 && n !== void 0 && (r = pr(n === null ? void 0 : n, { owner: this }), this.addValue(t, r)), r } readValue(t, n) { let r = this.latestValues[t] !== void 0 || !this.current ? this.latestValues[t] : this.getBaseTargetFromProps(this.props, t) ?? this.readValueFromInstance(this.current, t, this.options); return r != null && (typeof r == "string" && (Py(r) || Ry(r)) ? r = parseFloat(r) : !_E(r) && an.test(n) && (r = ug(t, n)), this.setBaseTarget(t, xe(r) ? r.get() : r)), xe(r) ? r.get() : r } setBaseTarget(t, n) { this.baseTarget[t] = n } getBaseTarget(t) { var o; const { initial: n } = this.props; let r; if (typeof n == "string" || typeof n == "object") { const s = jc(this.props, n, (o = this.presenceContext) == null ? void 0 : o.custom); s && (r = s[t]) } if (n && r !== void 0) return r; const i = this.getBaseTargetFromProps(this.props, t); return i !== void 0 && !xe(i) ? i : this.initialValues[t] !== void 0 && r === void 0 ? void 0 : this.baseTarget[t] } on(t, n) { return this.events[t] || (this.events[t] = new yc), this.events[t].add(n) } notify(t, ...n) { this.events[t] && this.events[t].notify(...n) } scheduleRenderMicrotask() { Dc.render(this.render) } } class Fg extends CT { constructor() { super(...arguments), this.KeyframeResolver = SE } sortInstanceNodePosition(t, n) { return t.compareDocumentPosition(n) & 2 ? 1 : -1 } getBaseTargetFromProps(t, n) { return t.style ? t.style[n] : void 0 } removeValueFromRenderState(t, { vars: n, style: r }) { delete n[t], delete r[t] } handleChildMotionValue() { this.childSubscription && (this.childSubscription(), delete this.childSubscription); const { children: t } = this.props; xe(t) && (this.childSubscription = t.on("change", n => { this.current && (this.current.textContent = `${n}`) })) } } function jg(e, { style: t, vars: n }, r, i) { const o = e.style; let s; for (s in t) o[s] = t[s]; i == null || i.applyProjectionStyles(o, r); for (s in n) o.setProperty(s, n[s]) } function PT(e) { return window.getComputedStyle(e) } class kT extends Fg { constructor() { super(...arguments), this.type = "html", this.renderInstance = jg } readValueFromInstance(t, n) { var r; if (Pr.has(n)) return (r = this.projection) != null && r.isProjecting ? Ul(n) : jx(t, n); { const i = PT(t), o = (Uy(n) ? i.getPropertyValue(n) : i[n]) || 0; return typeof o == "string" ? o.trim() : o } } measureInstanceViewportBox(t, { transformPagePoint: n }) { return Vg(t, n) } build(t, n, r) { Vc(t, n, r.transformTemplate) } scrapeMotionValuesFromProps(t, n, r) { return Bc(t, n, r) } } const Bg = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]); function RT(e, t, n, r) { jg(e, t, void 0, r); for (const i in t.attrs) e.setAttribute(Bg.has(i) ? i : zc(i), t.attrs[i]) } class AT extends Fg { constructor() { super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = ae } getBaseTargetFromProps(t, n) { return t[n] } readValueFromInstance(t, n) { if (Pr.has(n)) { const r = lg(n); return r && r.default || 0 } return n = Bg.has(n) ? n : zc(n), t.getAttribute(n) } scrapeMotionValuesFromProps(t, n, r) { return Ag(t, n, r) } build(t, n, r) { Cg(t, n, this.isSVGTag, r.transformTemplate, r.style) } renderInstance(t, n, r, i) { RT(t, n, r, i) } mount(t) { this.isSVGTag = kg(t.tagName), super.mount(t) } } const LT = (e, t) => t.isSVG ?? Fc(e) ? new AT(t) : new kT(t, { allowProjection: e !== w.Fragment }); function sr(e, t, n) { const r = e.getProps(); return jc(r, t, n !== void 0 ? n : r.custom, e) } const Jl = e => Array.isArray(e); function DT(e, t, n) { e.hasValue(t) ? e.getValue(t).set(n) : e.addValue(t, pr(n)) } function _T(e) { return Jl(e) ? e[e.length - 1] || 0 : e } function MT(e, t) { const n = sr(e, t); let { transitionEnd: r = {}, transition: i = {}, ...o } = n || {}; o = { ...o, ...r }; for (const s in o) { const a = _T(o[s]); DT(e, s, a) } } function OT(e) { return !!(xe(e) && e.add) } function Zl(e, t) { const n = e.getValue("willChange"); if (OT(n)) return n.add(t); if (!n && Ft.WillChange) { const r = new Ft.WillChange("auto"); e.addValue("willChange", r), r.add(t) } } function zg(e) { return e.props[Lg] } const NT = e => e !== null; function VT(e, { repeat: t, repeatType: n = "loop" }, r) { const i = e.filter(NT), o = t && n !== "loop" && t % 2 === 1 ? 0 : i.length - 1; return !o || r === void 0 ? i[o] : r } const IT = { type: "spring", stiffness: 500, damping: 25, restSpeed: 10 }, FT = e => ({ type: "spring", stiffness: 550, damping: e === 0 ? 2 * Math.sqrt(550) : 30, restSpeed: 10 }), jT = { type: "keyframes", duration: .8 }, BT = { type: "keyframes", ease: [.25, .1, .35, 1], duration: .3 }, zT = (e, { keyframes: t }) => t.length > 2 ? jT : Pr.has(e) ? e.startsWith("scale") ? FT(t[1]) : IT : BT; function UT({ when: e, delay: t, delayChildren: n, staggerChildren: r, staggerDirection: i, repeat: o, repeatType: s, repeatDelay: a, from: l, elapsed: u, ...c }) { return !!Object.keys(c).length } const Uc = (e, t, n, r = {}, i, o) => s => { const a = Ac(r, e) || {}, l = a.delay || r.delay || 0; let { elapsed: u = 0 } = r; u = u - Et(l); const c = { keyframes: Array.isArray(n) ? n : [null, n], ease: "easeOut", velocity: t.getVelocity(), ...a, delay: -u, onUpdate: d => { t.set(d), a.onUpdate && a.onUpdate(d) }, onComplete: () => { s(), a.onComplete && a.onComplete() }, name: e, motionValue: t, element: o ? void 0 : i }; UT(a) || Object.assign(c, zT(e, c)), c.duration && (c.duration = Et(c.duration)), c.repeatDelay && (c.repeatDelay = Et(c.repeatDelay)), c.from !== void 0 && (c.keyframes[0] = c.from); let f = !1; if ((c.type === !1 || c.duration === 0 && !c.repeatDelay) && (Kl(c), c.delay === 0 && (f = !0)), (Ft.instantAnimations || Ft.skipAnimations) && (f = !0, Kl(c), c.delay = 0), c.allowFlatten = !a.type && !a.ease, f && !o && t.get() !== void 0) { const d = VT(c.keyframes, a); if (d !== void 0) { H.update(() => { c.onUpdate(d), c.onComplete() }); return } } return a.isSync ? new kc(c) : new aE(c) }; function $T({ protectedKeys: e, needsAnimating: t }, n) { const r = e.hasOwnProperty(n) && t[n] !== !0; return t[n] = !1, r } function Ug(e, t, { delay: n = 0, transitionOverride: r, type: i } = {}) { let { transition: o = e.getDefaultTransition(), transitionEnd: s, ...a } = t; r && (o = r); const l = [], u = i && e.animationState && e.animationState.getState()[i]; for (const c in a) { const f = e.getValue(c, e.latestValues[c] ?? null), d = a[c]; if (d === void 0 || u && $T(u, c)) continue; const g = { delay: n, ...Ac(o || {}, c) }, y = f.get(); if (y !== void 0 && !f.isAnimating && !Array.isArray(d) && d === y && !g.velocity) continue; let v = !1; if (window.MotionHandoffAnimation) { const p = zg(e); if (p) { const h = window.MotionHandoffAnimation(p, c, H); h !== null && (g.startTime = h, v = !0) } } Zl(e, c), f.start(Uc(c, f, d, e.shouldReduceMotion && og.has(c) ? { type: !1 } : g, e, v)); const S = f.animation; S && l.push(S) } return s && Promise.all(l).then(() => { H.update(() => { s && MT(e, s) }) }), l } function $g(e, t, n, r = 0, i = 1) { const o = Array.from(e).sort((u, c) => u.sortNodePosition(c)).indexOf(t), s = e.size, a = (s - 1) * r; return typeof n == "function" ? n(o, s) : i === 1 ? o * r : a - o * r } function eu(e, t, n = {}) { var l; const r = sr(e, t, n.type === "exit" ? (l = e.presenceContext) == null ? void 0 : l.custom : void 0); let { transition: i = e.getDefaultTransition() || {} } = r || {}; n.transitionOverride && (i = n.transitionOverride); const o = r ? () => Promise.all(Ug(e, r, n)) : () => Promise.resolve(), s = e.variantChildren && e.variantChildren.size ? (u = 0) => { const { delayChildren: c = 0, staggerChildren: f, staggerDirection: d } = i; return bT(e, t, u, c, f, d, n) } : () => Promise.resolve(), { when: a } = i; if (a) { const [u, c] = a === "beforeChildren" ? [o, s] : [s, o]; return u().then(() => c()) } else return Promise.all([o(), s(n.delay)]) } function bT(e, t, n = 0, r = 0, i = 0, o = 1, s) { const a = []; for (const l of e.variantChildren) l.notify("AnimationStart", t), a.push(eu(l, t, { ...s, delay: n + (typeof r == "function" ? 0 : r) + $g(e.variantChildren, l, r, i, o) }).then(() => l.notify("AnimationComplete", t))); return Promise.all(a) } function WT(e, t, n = {}) { e.notify("AnimationStart", t); let r; if (Array.isArray(t)) { const i = t.map(o => eu(e, o, n)); r = Promise.all(i) } else if (typeof t == "string") r = eu(e, t, n); else { const i = typeof t == "function" ? sr(e, t, n.custom) : t; r = Promise.all(Ug(e, i, n)) } return r.then(() => { e.notify("AnimationComplete", t) }) } function bg(e, t) { if (!Array.isArray(t)) return !1; const n = t.length; if (n !== e.length) return !1; for (let r = 0; r < n; r++)if (t[r] !== e[r]) return !1; return !0 } const HT = Nc.length; function Wg(e) { if (!e) return; if (!e.isControllingVariants) { const n = e.parent ? Wg(e.parent) || {} : {}; return e.props.initial !== void 0 && (n.initial = e.props.initial), n } const t = {}; for (let n = 0; n < HT; n++) { const r = Nc[n], i = e.props[r]; (ki(i) || i === !1) && (t[r] = i) } return t } const KT = [...Oc].reverse(), GT = Oc.length; function XT(e) { return t => Promise.all(t.map(({ animation: n, options: r }) => WT(e, n, r))) } function YT(e) { let t = XT(e), n = Xd(), r = !0; const i = l => (u, c) => { var d; const f = sr(e, c, l === "exit" ? (d = e.presenceContext) == null ? void 0 : d.custom : void 0); if (f) { const { transition: g, transitionEnd: y, ...v } = f; u = { ...u, ...v, ...y } } return u }; function o(l) { t = l(e) } function s(l) { const { props: u } = e, c = Wg(e.parent) || {}, f = [], d = new Set; let g = {}, y = 1 / 0; for (let S = 0; S < GT; S++) { const p = KT[S], h = n[p], m = u[p] !== void 0 ? u[p] : c[p], x = ki(m), E = p === l ? h.isActive : null; E === !1 && (y = S); let k = m === c[p] && m !== u[p] && x; if (k && r && e.manuallyAnimateOnMount && (k = !1), h.protectedKeys = { ...g }, !h.isActive && E === null || !m && !h.prevProp || Is(m) || typeof m == "boolean") continue; const P = QT(h.prevProp, m); let C = P || p === l && h.isActive && !k && x || S > y && x, O = !1; const M = Array.isArray(m) ? m : [m]; let K = M.reduce(i(p), {}); E === !1 && (K = {}); const { prevResolvedValues: Te = {} } = h, Fe = { ...Te, ...K }, je = G => { C = !0, d.has(G) && (O = !0, d.delete(G)), h.needsAnimating[G] = !0; const L = e.getValue(G); L && (L.liveStyle = !1) }; for (const G in Fe) { const L = K[G], N = Te[G]; if (g.hasOwnProperty(G)) continue; let V = !1; Jl(L) && Jl(N) ? V = !bg(L, N) : V = L !== N, V ? L != null ? je(G) : d.add(G) : L !== void 0 && d.has(G) ? je(G) : h.protectedKeys[G] = !0 } h.prevProp = m, h.prevResolvedValues = K, h.isActive && (g = { ...g, ...K }), r && e.blockInitialAnimation && (C = !1); const dn = k && P; C && (!dn || O) && f.push(...M.map(G => { const L = { type: p }; if (typeof G == "string" && r && !dn && e.manuallyAnimateOnMount && e.parent) { const { parent: N } = e, V = sr(N, G); if (N.enteringChildren && V) { const { delayChildren: B } = V.transition || {}; L.delay = $g(N.enteringChildren, e, B) } } return { animation: G, options: L } })) } if (d.size) { const S = {}; if (typeof u.initial != "boolean") { const p = sr(e, Array.isArray(u.initial) ? u.initial[0] : u.initial); p && p.transition && (S.transition = p.transition) } d.forEach(p => { const h = e.getBaseTarget(p), m = e.getValue(p); m && (m.liveStyle = !0), S[p] = h ?? null }), f.push({ animation: S }) } let v = !!f.length; return r && (u.initial === !1 || u.initial === u.animate) && !e.manuallyAnimateOnMount && (v = !1), r = !1, v ? t(f) : Promise.resolve() } function a(l, u) { var f; if (n[l].isActive === u) return Promise.resolve(); (f = e.variantChildren) == null || f.forEach(d => { var g; return (g = d.animationState) == null ? void 0 : g.setActive(l, u) }), n[l].isActive = u; const c = s(l); for (const d in n) n[d].protectedKeys = {}; return c } return { animateChanges: s, setActive: a, setAnimateFunction: o, getState: () => n, reset: () => { n = Xd() } } } function QT(e, t) { return typeof t == "string" ? t !== e : Array.isArray(t) ? !bg(t, e) : !1 } function pn(e = !1) { return { isActive: e, protectedKeys: {}, needsAnimating: {}, prevResolvedValues: {} } } function Xd() { return { animate: pn(!0), whileInView: pn(), whileHover: pn(), whileTap: pn(), whileDrag: pn(), whileFocus: pn(), exit: pn() } } class fn { constructor(t) { this.isMounted = !1, this.node = t } update() { } } class qT extends fn { constructor(t) { super(t), t.animationState || (t.animationState = YT(t)) } updateAnimationControlsSubscription() { const { animate: t } = this.node.getProps(); Is(t) && (this.unmountControls = t.subscribe(this.node)) } mount() { this.updateAnimationControlsSubscription() } update() { const { animate: t } = this.node.getProps(), { animate: n } = this.node.prevProps || {}; t !== n && this.updateAnimationControlsSubscription() } unmount() { var t; this.node.animationState.reset(), (t = this.unmountControls) == null || t.call(this) } } let JT = 0; class ZT extends fn { constructor() { super(...arguments), this.id = JT++ } update() { if (!this.node.presenceContext) return; const { isPresent: t, onExitComplete: n } = this.node.presenceContext, { isPresent: r } = this.node.prevPresenceContext || {}; if (!this.node.animationState || t === r) return; const i = this.node.animationState.setActive("exit", !t); n && !t && i.then(() => { n(this.id) }) } mount() { const { register: t, onExitComplete: n } = this.node.presenceContext || {}; n && n(this.id), t && (this.unmount = t(this.id)) } unmount() { } } const eC = { animation: { Feature: qT }, exit: { Feature: ZT } }; function Ri(e, t, n, r = { passive: !0 }) { return e.addEventListener(t, n, r), () => e.removeEventListener(t, n) } function Bi(e) { return { point: { x: e.pageX, y: e.pageY } } } const tC = e => t => _c(t) && e(t, Bi(t)); function ri(e, t, n, r) { return Ri(e, t, tC(n), r) } const Hg = 1e-4, nC = 1 - Hg, rC = 1 + Hg, Kg = .01, iC = 0 - Kg, oC = 0 + Kg; function Re(e) { return e.max - e.min } function sC(e, t, n) { return Math.abs(e - t) <= n } function Yd(e, t, n, r = .5) { e.origin = r, e.originPoint = J(t.min, t.max, e.origin), e.scale = Re(n) / Re(t), e.translate = J(n.min, n.max, e.origin) - e.originPoint, (e.scale >= nC && e.scale <= rC || isNaN(e.scale)) && (e.scale = 1), (e.translate >= iC && e.translate <= oC || isNaN(e.translate)) && (e.translate = 0) } function ii(e, t, n, r) { Yd(e.x, t.x, n.x, r ? r.originX : void 0), Yd(e.y, t.y, n.y, r ? r.originY : void 0) } function Qd(e, t, n) { e.min = n.min + t.min, e.max = e.min + Re(t) } function aC(e, t, n) { Qd(e.x, t.x, n.x), Qd(e.y, t.y, n.y) } function qd(e, t, n) { e.min = t.min - n.min, e.max = e.min + Re(t) } function hs(e, t, n) { qd(e.x, t.x, n.x), qd(e.y, t.y, n.y) } function Xe(e) { return [e("x"), e("y")] } const Gg = ({ current: e }) => e ? e.ownerDocument.defaultView : null, Jd = (e, t) => Math.abs(e - t); function lC(e, t) { const n = Jd(e.x, t.x), r = Jd(e.y, t.y); return Math.sqrt(n ** 2 + r ** 2) } const Zd = new Set(["auto", "scroll"]); class Xg { constructor(t, n, { transformPagePoint: r, contextWindow: i = window, dragSnapToOrigin: o = !1, distanceThreshold: s = 3, element: a } = {}) { if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.scrollPositions = new Map, this.removeScrollListeners = null, this.onElementScroll = g => { this.handleScroll(g.target) }, this.onWindowScroll = () => { this.handleScroll(window) }, this.updatePoint = () => { if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return; const g = La(this.lastMoveEventInfo, this.history), y = this.startEvent !== null, v = lC(g.offset, { x: 0, y: 0 }) >= this.distanceThreshold; if (!y && !v) return; const { point: S } = g, { timestamp: p } = pe; this.history.push({ ...S, timestamp: p }); const { onStart: h, onMove: m } = this.handlers; y || (h && h(this.lastMoveEvent, g), this.startEvent = this.lastMoveEvent), m && m(this.lastMoveEvent, g) }, this.handlePointerMove = (g, y) => { this.lastMoveEvent = g, this.lastMoveEventInfo = Aa(y, this.transformPagePoint), H.update(this.updatePoint, !0) }, this.handlePointerUp = (g, y) => { this.end(); const { onEnd: v, onSessionEnd: S, resumeAnimation: p } = this.handlers; if ((this.dragSnapToOrigin || !this.startEvent) && p && p(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return; const h = La(g.type === "pointercancel" ? this.lastMoveEventInfo : Aa(y, this.transformPagePoint), this.history); this.startEvent && v && v(g, h), S && S(g, h) }, !_c(t)) return; this.dragSnapToOrigin = o, this.handlers = n, this.transformPagePoint = r, this.distanceThreshold = s, this.contextWindow = i || window; const l = Bi(t), u = Aa(l, this.transformPagePoint), { point: c } = u, { timestamp: f } = pe; this.history = [{ ...c, timestamp: f }]; const { onSessionStart: d } = n; d && d(t, La(u, this.history)), this.removeListeners = Ii(ri(this.contextWindow, "pointermove", this.handlePointerMove), ri(this.contextWindow, "pointerup", this.handlePointerUp), ri(this.contextWindow, "pointercancel", this.handlePointerUp)), a && this.startScrollTracking(a) } startScrollTracking(t) { let n = t.parentElement; for (; n;) { const r = getComputedStyle(n); (Zd.has(r.overflowX) || Zd.has(r.overflowY)) && this.scrollPositions.set(n, { x: n.scrollLeft, y: n.scrollTop }), n = n.parentElement } this.scrollPositions.set(window, { x: window.scrollX, y: window.scrollY }), window.addEventListener("scroll", this.onElementScroll, { capture: !0, passive: !0 }), window.addEventListener("scroll", this.onWindowScroll, { passive: !0 }), this.removeScrollListeners = () => { window.removeEventListener("scroll", this.onElementScroll, { capture: !0 }), window.removeEventListener("scroll", this.onWindowScroll) } } handleScroll(t) { const n = this.scrollPositions.get(t); if (!n) return; const r = t === window, i = r ? { x: window.scrollX, y: window.scrollY } : { x: t.scrollLeft, y: t.scrollTop }, o = { x: i.x - n.x, y: i.y - n.y }; o.x === 0 && o.y === 0 || (r ? this.lastMoveEventInfo && (this.lastMoveEventInfo.point.x += o.x, this.lastMoveEventInfo.point.y += o.y) : this.history.length > 0 && (this.history[0].x -= o.x, this.history[0].y -= o.y), this.scrollPositions.set(t, i), H.update(this.updatePoint, !0)) } updateHandlers(t) { this.handlers = t } end() { this.removeListeners && this.removeListeners(), this.removeScrollListeners && this.removeScrollListeners(), this.scrollPositions.clear(), sn(this.updatePoint) } } function Aa(e, t) { return t ? { point: t(e.point) } : e } function eh(e, t) { return { x: e.x - t.x, y: e.y - t.y } } function La({ point: e }, t) { return { point: e, delta: eh(e, Yg(t)), offset: eh(e, uC(t)), velocity: cC(t, .1) } } function uC(e) { return e[0] } function Yg(e) { return e[e.length - 1] } function cC(e, t) { if (e.length < 2) return { x: 0, y: 0 }; let n = e.length - 1, r = null; const i = Yg(e); for (; n >= 0 && (r = e[n], !(i.timestamp - r.timestamp > Et(t)));)n--; if (!r) return { x: 0, y: 0 }; const o = Je(i.timestamp - r.timestamp); if (o === 0) return { x: 0, y: 0 }; const s = { x: (i.x - r.x) / o, y: (i.y - r.y) / o }; return s.x === 1 / 0 && (s.x = 0), s.y === 1 / 0 && (s.y = 0), s } function fC(e, { min: t, max: n }, r) { return t !== void 0 && e < t ? e = r ? J(t, e, r.min) : Math.max(e, t) : n !== void 0 && e > n && (e = r ? J(n, e, r.max) : Math.min(e, n)), e } function th(e, t, n) { return { min: t !== void 0 ? e.min + t : void 0, max: n !== void 0 ? e.max + n - (e.max - e.min) : void 0 } } function dC(e, { top: t, left: n, bottom: r, right: i }) { return { x: th(e.x, n, i), y: th(e.y, t, r) } } function nh(e, t) { let n = t.min - e.min, r = t.max - e.max; return t.max - t.min < e.max - e.min && ([n, r] = [r, n]), { min: n, max: r } } function hC(e, t) { return { x: nh(e.x, t.x), y: nh(e.y, t.y) } } function pC(e, t) { let n = .5; const r = Re(e), i = Re(t); return i > r ? n = Ti(t.min, t.max - r, e.min) : r > i && (n = Ti(e.min, e.max - i, t.min)), Ct(0, 1, n) } function mC(e, t) { const n = {}; return t.min !== void 0 && (n.min = t.min - e.min), t.max !== void 0 && (n.max = t.max - e.min), n } const tu = .35; function yC(e = tu) { return e === !1 ? e = 0 : e === !0 && (e = tu), { x: rh(e, "left", "right"), y: rh(e, "top", "bottom") } } function rh(e, t, n) { return { min: ih(e, t), max: ih(e, n) } } function ih(e, t) { return typeof e == "number" ? e : e[t] || 0 } const gC = new WeakMap; class vC { constructor(t) { this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = { x: 0, y: 0 }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = ae(), this.latestPointerEvent = null, this.latestPanInfo = null, this.visualElement = t } start(t, { snapToCursor: n = !1, distanceThreshold: r } = {}) { const { presenceContext: i } = this.visualElement; if (i && i.isPresent === !1) return; const o = f => { n ? (this.stopAnimation(), this.snapToCursor(Bi(f).point)) : this.pauseAnimation() }, s = (f, d) => { this.stopAnimation(); const { drag: g, dragPropagation: y, onDragStart: v } = this.getProps(); if (g && !y && (this.openDragLock && this.openDragLock(), this.openDragLock = CE(g), !this.openDragLock)) return; this.latestPointerEvent = f, this.latestPanInfo = d, this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), Xe(p => { let h = this.getAxisMotionValue(p).get() || 0; if (Tt.test(h)) { const { projection: m } = this.visualElement; if (m && m.layout) { const x = m.layout.layoutBox[p]; x && (h = Re(x) * (parseFloat(h) / 100)) } } this.originPoint[p] = h }), v && H.postRender(() => v(f, d)), Zl(this.visualElement, "transform"); const { animationState: S } = this.visualElement; S && S.setActive("whileDrag", !0) }, a = (f, d) => { this.latestPointerEvent = f, this.latestPanInfo = d; const { dragPropagation: g, dragDirectionLock: y, onDirectionLock: v, onDrag: S } = this.getProps(); if (!g && !this.openDragLock) return; const { offset: p } = d; if (y && this.currentDirection === null) { this.currentDirection = wC(p), this.currentDirection !== null && v && v(this.currentDirection); return } this.updateAxis("x", d.point, p), this.updateAxis("y", d.point, p), this.visualElement.render(), S && S(f, d) }, l = (f, d) => { this.latestPointerEvent = f, this.latestPanInfo = d, this.stop(f, d), this.latestPointerEvent = null, this.latestPanInfo = null }, u = () => Xe(f => { var d; return this.getAnimationState(f) === "paused" && ((d = this.getAxisMotionValue(f).animation) == null ? void 0 : d.play()) }), { dragSnapToOrigin: c } = this.getProps(); this.panSession = new Xg(t, { onSessionStart: o, onStart: s, onMove: a, onSessionEnd: l, resumeAnimation: u }, { transformPagePoint: this.visualElement.getTransformPagePoint(), dragSnapToOrigin: c, distanceThreshold: r, contextWindow: Gg(this.visualElement), element: this.visualElement.current }) } stop(t, n) { const r = t || this.latestPointerEvent, i = n || this.latestPanInfo, o = this.isDragging; if (this.cancel(), !o || !i || !r) return; const { velocity: s } = i; this.startAnimation(s); const { onDragEnd: a } = this.getProps(); a && H.postRender(() => a(r, i)) } cancel() { this.isDragging = !1; const { projection: t, animationState: n } = this.visualElement; t && (t.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0; const { dragPropagation: r } = this.getProps(); !r && this.openDragLock && (this.openDragLock(), this.openDragLock = null), n && n.setActive("whileDrag", !1) } updateAxis(t, n, r) { const { drag: i } = this.getProps(); if (!r || !fo(t, i, this.currentDirection)) return; const o = this.getAxisMotionValue(t); let s = this.originPoint[t] + r[t]; this.constraints && this.constraints[t] && (s = fC(s, this.constraints[t], this.elastic[t])), o.set(s) } resolveConstraints() { var o; const { dragConstraints: t, dragElastic: n } = this.getProps(), r = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (o = this.visualElement.projection) == null ? void 0 : o.layout, i = this.constraints; t && Hr(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && r ? this.constraints = dC(r.layoutBox, t) : this.constraints = !1, this.elastic = yC(n), i !== this.constraints && r && this.constraints && !this.hasMutatedConstraints && Xe(s => { this.constraints !== !1 && this.getAxisMotionValue(s) && (this.constraints[s] = mC(r.layoutBox[s], this.constraints[s])) }) } resolveRefConstraints() { const { dragConstraints: t, onMeasureDragConstraints: n } = this.getProps(); if (!t || !Hr(t)) return !1; const r = t.current; Mn(r !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.", "drag-constraints-ref"); const { projection: i } = this.visualElement; if (!i || !i.layout) return !1; const o = ST(r, i.root, this.visualElement.getTransformPagePoint()); let s = hC(i.layout.layoutBox, o); if (n) { const a = n(gT(s)); this.hasMutatedConstraints = !!a, a && (s = Mg(a)) } return s } startAnimation(t) { const { drag: n, dragMomentum: r, dragElastic: i, dragTransition: o, dragSnapToOrigin: s, onDragTransitionEnd: a } = this.getProps(), l = this.constraints || {}, u = Xe(c => { if (!fo(c, n, this.currentDirection)) return; let f = l && l[c] || {}; s && (f = { min: 0, max: 0 }); const d = i ? 200 : 1e6, g = i ? 40 : 1e7, y = { type: "inertia", velocity: r ? t[c] : 0, bounceStiffness: d, bounceDamping: g, timeConstant: 750, restDelta: 1, restSpeed: 10, ...o, ...f }; return this.startAxisValueAnimation(c, y) }); return Promise.all(u).then(a) } startAxisValueAnimation(t, n) { const r = this.getAxisMotionValue(t); return Zl(this.visualElement, t), r.start(Uc(t, r, 0, n, this.visualElement, !1)) } stopAnimation() { Xe(t => this.getAxisMotionValue(t).stop()) } pauseAnimation() { Xe(t => { var n; return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.pause() }) } getAnimationState(t) { var n; return (n = this.getAxisMotionValue(t).animation) == null ? void 0 : n.state } getAxisMotionValue(t) { const n = `_drag${t.toUpperCase()}`, r = this.visualElement.getProps(), i = r[n]; return i || this.visualElement.getValue(t, (r.initial ? r.initial[t] : void 0) || 0) } snapToCursor(t) { Xe(n => { const { drag: r } = this.getProps(); if (!fo(n, r, this.currentDirection)) return; const { projection: i } = this.visualElement, o = this.getAxisMotionValue(n); if (i && i.layout) { const { min: s, max: a } = i.layout.layoutBox[n], l = o.get() || 0; o.set(t[n] - J(s, a, .5) + l) } }) } scalePositionWithinConstraints() { if (!this.visualElement.current) return; const { drag: t, dragConstraints: n } = this.getProps(), { projection: r } = this.visualElement; if (!Hr(n) || !r || !this.constraints) return; this.stopAnimation(); const i = { x: 0, y: 0 }; Xe(s => { const a = this.getAxisMotionValue(s); if (a && this.constraints !== !1) { const l = a.get(); i[s] = pC({ min: l, max: l }, this.constraints[s]) } }); const { transformTemplate: o } = this.visualElement.getProps(); this.visualElement.current.style.transform = o ? o({}, "") : "none", r.root && r.root.updateScroll(), r.updateLayout(), this.resolveConstraints(), Xe(s => { if (!fo(s, t, null)) return; const a = this.getAxisMotionValue(s), { min: l, max: u } = this.constraints[s]; a.set(J(l, u, i[s])) }) } addListeners() { if (!this.visualElement.current) return; gC.set(this.visualElement, this); const t = this.visualElement.current, n = ri(t, "pointerdown", l => { const { drag: u, dragListener: c = !0 } = this.getProps(); u && c && !mg(l.target) && this.start(l) }), r = () => { const { dragConstraints: l } = this.getProps(); Hr(l) && l.current && (this.constraints = this.resolveRefConstraints()) }, { projection: i } = this.visualElement, o = i.addEventListener("measure", r); i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), H.read(r); const s = Ri(window, "resize", () => this.scalePositionWithinConstraints()), a = i.addEventListener("didUpdate", ({ delta: l, hasLayoutChanged: u }) => { this.isDragging && u && (Xe(c => { const f = this.getAxisMotionValue(c); f && (this.originPoint[c] += l[c].translate, f.set(f.get() + l[c].translate)) }), this.visualElement.render()) }); return () => { s(), n(), o(), a && a() } } getProps() { const t = this.visualElement.getProps(), { drag: n = !1, dragDirectionLock: r = !1, dragPropagation: i = !1, dragConstraints: o = !1, dragElastic: s = tu, dragMomentum: a = !0 } = t; return { ...t, drag: n, dragDirectionLock: r, dragPropagation: i, dragConstraints: o, dragElastic: s, dragMomentum: a } } } function fo(e, t, n) { return (t === !0 || t === e) && (n === null || n === e) } function wC(e, t = 10) { let n = null; return Math.abs(e.y) > t ? n = "y" : Math.abs(e.x) > t && (n = "x"), n } class SC extends fn { constructor(t) { super(t), this.removeGroupControls = et, this.removeListeners = et, this.controls = new vC(t) } mount() { const { dragControls: t } = this.node.getProps(); t && (this.removeGroupControls = t.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || et } update() { const { dragControls: t } = this.node.getProps(), { dragControls: n } = this.node.prevProps || {}; t !== n && (this.removeGroupControls(), t && (this.removeGroupControls = t.subscribe(this.controls))) } unmount() { this.removeGroupControls(), this.removeListeners() } } const oh = e => (t, n) => { e && H.postRender(() => e(t, n)) }; class xC extends fn { constructor() { super(...arguments), this.removePointerDownListener = et } onPointerDown(t) { this.session = new Xg(t, this.createPanHandlers(), { transformPagePoint: this.node.getTransformPagePoint(), contextWindow: Gg(this.node) }) } createPanHandlers() { const { onPanSessionStart: t, onPanStart: n, onPan: r, onPanEnd: i } = this.node.getProps(); return { onSessionStart: oh(t), onStart: oh(n), onMove: r, onEnd: (o, s) => { delete this.session, i && H.postRender(() => i(o, s)) } } } mount() { this.removePointerDownListener = ri(this.node.current, "pointerdown", t => this.onPointerDown(t)) } update() { this.session && this.session.updateHandlers(this.createPanHandlers()) } unmount() { this.removePointerDownListener(), this.session && this.session.end() } } const _o = { hasAnimatedSinceResize: !0, hasEverUpdated: !1 }; let Da = !1; class EC extends w.Component { componentDidMount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r, layoutId: i } = this.props, { projection: o } = t; o && (n.group && n.group.add(o), r && r.register && i && r.register(o), Da && o.root.didUpdate(), o.addEventListener("animationComplete", () => { this.safeToRemove() }), o.setOptions({ ...o.options, onExitComplete: () => this.safeToRemove() })), _o.hasEverUpdated = !0 } getSnapshotBeforeUpdate(t) { const { layoutDependency: n, visualElement: r, drag: i, isPresent: o } = this.props, { projection: s } = r; return s && (s.isPresent = o, Da = !0, i || t.layoutDependency !== n || n === void 0 || t.isPresent !== o ? s.willUpdate() : this.safeToRemove(), t.isPresent !== o && (o ? s.promote() : s.relegate() || H.postRender(() => { const a = s.getStack(); (!a || !a.members.length) && this.safeToRemove() }))), null } componentDidUpdate() { const { projection: t } = this.props.visualElement; t && (t.root.didUpdate(), Dc.postRender(() => { !t.currentAnimation && t.isLead() && this.safeToRemove() })) } componentWillUnmount() { const { visualElement: t, layoutGroup: n, switchLayoutGroup: r } = this.props, { projection: i } = t; Da = !0, i && (i.scheduleCheckAfterUnmount(), n && n.group && n.group.remove(i), r && r.deregister && r.deregister(i)) } safeToRemove() { const { safeToRemove: t } = this.props; t && t() } render() { return null } } function Qg(e) { const [t, n] = gg(), r = w.useContext(cc); return R.jsx(EC, { ...e, layoutGroup: r, switchLayoutGroup: w.useContext(Dg), isPresent: t, safeToRemove: n }) } function TC(e, t, n) { const r = xe(e) ? e : pr(e); return r.start(Uc("", r, t, n)), r.animation } const CC = (e, t) => e.depth - t.depth; class PC { constructor() { this.children = [], this.isDirty = !1 } add(t) { hc(this.children, t), this.isDirty = !0 } remove(t) { pc(this.children, t), this.isDirty = !0 } forEach(t) { this.isDirty && this.children.sort(CC), this.isDirty = !1, this.children.forEach(t) } } function kC(e, t) { const n = ke.now(), r = ({ timestamp: i }) => { const o = i - n; o >= t && (sn(r), e(o - t)) }; return H.setup(r, !0), () => sn(r) } const qg = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"], RC = qg.length, sh = e => typeof e == "string" ? parseFloat(e) : e, ah = e => typeof e == "number" || D.test(e); function AC(e, t, n, r, i, o) { i ? (e.opacity = J(0, n.opacity ?? 1, LC(r)), e.opacityExit = J(t.opacity ?? 1, 0, DC(r))) : o && (e.opacity = J(t.opacity ?? 1, n.opacity ?? 1, r)); for (let s = 0; s < RC; s++) { const a = `border${qg[s]}Radius`; let l = lh(t, a), u = lh(n, a); if (l === void 0 && u === void 0) continue; l || (l = 0), u || (u = 0), l === 0 || u === 0 || ah(l) === ah(u) ? (e[a] = Math.max(J(sh(l), sh(u), r), 0), (Tt.test(u) || Tt.test(l)) && (e[a] += "%")) : e[a] = u } (t.rotate || n.rotate) && (e.rotate = J(t.rotate || 0, n.rotate || 0, r)) } function lh(e, t) { return e[t] !== void 0 ? e[t] : e.borderRadius } const LC = Jg(0, .5, Vy), DC = Jg(.5, .95, et); function Jg(e, t, n) { return r => r < e ? 0 : r > t ? 1 : n(Ti(e, t, r)) } function uh(e, t) { e.min = t.min, e.max = t.max } function ot(e, t) { uh(e.x, t.x), uh(e.y, t.y) } function ch(e, t) { e.translate = t.translate, e.scale = t.scale, e.originPoint = t.originPoint, e.origin = t.origin } function fh(e, t, n, r, i) { return e -= t, e = ds(e, 1 / n, r), i !== void 0 && (e = ds(e, 1 / i, r)), e } function _C(e, t = 0, n = 1, r = .5, i, o = e, s = e) { if (Tt.test(t) && (t = parseFloat(t), t = J(s.min, s.max, t / 100) - s.min), typeof t != "number") return; let a = J(o.min, o.max, r); e === o && (a -= t), e.min = fh(e.min, t, n, a, i), e.max = fh(e.max, t, n, a, i) } function dh(e, t, [n, r, i], o, s) { _C(e, t[n], t[r], t[i], t.scale, o, s) } const MC = ["x", "scaleX", "originX"], OC = ["y", "scaleY", "originY"]; function hh(e, t, n, r) { dh(e.x, t, MC, n ? n.x : void 0, r ? r.x : void 0), dh(e.y, t, OC, n ? n.y : void 0, r ? r.y : void 0) } function ph(e) { return e.translate === 0 && e.scale === 1 } function Zg(e) { return ph(e.x) && ph(e.y) } function mh(e, t) { return e.min === t.min && e.max === t.max } function NC(e, t) { return mh(e.x, t.x) && mh(e.y, t.y) } function yh(e, t) { return Math.round(e.min) === Math.round(t.min) && Math.round(e.max) === Math.round(t.max) } function e0(e, t) { return yh(e.x, t.x) && yh(e.y, t.y) } function gh(e) { return Re(e.x) / Re(e.y) } function vh(e, t) { return e.translate === t.translate && e.scale === t.scale && e.originPoint === t.originPoint } class VC { constructor() { this.members = [] } add(t) { hc(this.members, t), t.scheduleRender() } remove(t) { if (pc(this.members, t), t === this.prevLead && (this.prevLead = void 0), t === this.lead) { const n = this.members[this.members.length - 1]; n && this.promote(n) } } relegate(t) { const n = this.members.findIndex(i => t === i); if (n === 0) return !1; let r; for (let i = n; i >= 0; i--) { const o = this.members[i]; if (o.isPresent !== !1) { r = o; break } } return r ? (this.promote(r), !0) : !1 } promote(t, n) { const r = this.lead; if (t !== r && (this.prevLead = r, this.lead = t, t.show(), r)) { r.instance && r.scheduleRender(), t.scheduleRender(), t.resumeFrom = r, n && (t.resumeFrom.preserveOpacity = !0), r.snapshot && (t.snapshot = r.snapshot, t.snapshot.latestValues = r.animationValues || r.latestValues), t.root && t.root.isUpdating && (t.isLayoutDirty = !0); const { crossfade: i } = t.options; i === !1 && r.hide() } } exitAnimationComplete() { this.members.forEach(t => { const { options: n, resumingFrom: r } = t; n.onExitComplete && n.onExitComplete(), r && r.options.onExitComplete && r.options.onExitComplete() }) } scheduleRender() { this.members.forEach(t => { t.instance && t.scheduleRender(!1) }) } removeLeadSnapshot() { this.lead && this.lead.snapshot && (this.lead.snapshot = void 0) } } function IC(e, t, n) { let r = ""; const i = e.x.translate / t.x, o = e.y.translate / t.y, s = (n == null ? void 0 : n.z) || 0; if ((i || o || s) && (r = `translate3d(${i}px, ${o}px, ${s}px) `), (t.x !== 1 || t.y !== 1) && (r += `scale(${1 / t.x}, ${1 / t.y}) `), n) { const { transformPerspective: u, rotate: c, rotateX: f, rotateY: d, skewX: g, skewY: y } = n; u && (r = `perspective(${u}px) ${r}`), c && (r += `rotate(${c}deg) `), f && (r += `rotateX(${f}deg) `), d && (r += `rotateY(${d}deg) `), g && (r += `skewX(${g}deg) `), y && (r += `skewY(${y}deg) `) } const a = e.x.scale * t.x, l = e.y.scale * t.y; return (a !== 1 || l !== 1) && (r += `scale(${a}, ${l})`), r || "none" } const _a = ["", "X", "Y", "Z"], FC = 1e3; let jC = 0; function Ma(e, t, n, r) { const { latestValues: i } = t; i[e] && (n[e] = i[e], t.setStaticValue(e, 0), r && (r[e] = 0)) } function t0(e) { if (e.hasCheckedOptimisedAppear = !0, e.root === e) return; const { visualElement: t } = e.options; if (!t) return; const n = zg(t); if (window.MotionHasOptimisedAnimation(n, "transform")) { const { layout: i, layoutId: o } = e.options; window.MotionCancelOptimisedAnimation(n, "transform", H, !(i || o)) } const { parent: r } = e; r && !r.hasCheckedOptimisedAppear && t0(r) } function n0({ attachResizeListener: e, defaultParent: t, measureScroll: n, checkIsScrollRoot: r, resetTransform: i }) { return class { constructor(s = {}, a = t == null ? void 0 : t()) { this.id = jC++, this.animationId = 0, this.animationCommitId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = { x: 1, y: 1 }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.layoutVersion = 0, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => { this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots()) }, this.updateProjection = () => { this.projectionUpdateScheduled = !1, this.nodes.forEach(UC), this.nodes.forEach(HC), this.nodes.forEach(KC), this.nodes.forEach($C) }, this.resolvedRelativeTargetAt = 0, this.linkedParentVersion = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = s, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0; for (let l = 0; l < this.path.length; l++)this.path[l].shouldResetTransform = !0; this.root === this && (this.nodes = new PC) } addEventListener(s, a) { return this.eventHandlers.has(s) || this.eventHandlers.set(s, new yc), this.eventHandlers.get(s).add(a) } notifyListeners(s, ...a) { const l = this.eventHandlers.get(s); l && l.notify(...a) } hasListeners(s) { return this.eventHandlers.has(s) } mount(s) { if (this.instance) return; this.isSVG = yg(s) && !LE(s), this.instance = s; const { layoutId: a, layout: l, visualElement: u } = this.options; if (u && !u.current && u.mount(s), this.root.nodes.add(this), this.parent && this.parent.children.add(this), this.root.hasTreeAnimated && (l || a) && (this.isLayoutDirty = !0), e) { let c, f = 0; const d = () => this.root.updateBlockedByResize = !1; H.read(() => { f = window.innerWidth }), e(s, () => { const g = window.innerWidth; g !== f && (f = g, this.root.updateBlockedByResize = !0, c && c(), c = kC(d, 250), _o.hasAnimatedSinceResize && (_o.hasAnimatedSinceResize = !1, this.nodes.forEach(xh))) }) } a && this.root.registerSharedNode(a, this), this.options.animate !== !1 && u && (a || l) && this.addEventListener("didUpdate", ({ delta: c, hasLayoutChanged: f, hasRelativeLayoutChanged: d, layout: g }) => { if (this.isTreeAnimationBlocked()) { this.target = void 0, this.relativeTarget = void 0; return } const y = this.options.transition || u.getDefaultTransition() || qC, { onLayoutAnimationStart: v, onLayoutAnimationComplete: S } = u.getProps(), p = !this.targetLayout || !e0(this.targetLayout, g), h = !f && d; if (this.options.layoutRoot || this.resumeFrom || h || f && (p || !this.currentAnimation)) { this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0); const m = { ...Ac(y, "layout"), onPlay: v, onComplete: S }; (u.shouldReduceMotion || this.options.layoutRoot) && (m.delay = 0, m.type = !1), this.startAnimation(m), this.setAnimationOrigin(c, h) } else f || xh(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete(); this.targetLayout = g }) } unmount() { this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this); const s = this.getStack(); s && s.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, this.eventHandlers.clear(), sn(this.updateProjection) } blockUpdate() { this.updateManuallyBlocked = !0 } unblockUpdate() { this.updateManuallyBlocked = !1 } isUpdateBlocked() { return this.updateManuallyBlocked || this.updateBlockedByResize } isTreeAnimationBlocked() { return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1 } startUpdate() { this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(GC), this.animationId++) } getTransformTemplate() { const { visualElement: s } = this.options; return s && s.getProps().transformTemplate } willUpdate(s = !0) { if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) { this.options.onExitComplete && this.options.onExitComplete(); return } if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && t0(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return; this.isLayoutDirty = !0; for (let c = 0; c < this.path.length; c++) { const f = this.path[c]; f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1) } const { layoutId: a, layout: l } = this.options; if (a === void 0 && !l) return; const u = this.getTransformTemplate(); this.prevTransformTemplateValue = u ? u(this.latestValues, "") : void 0, this.updateSnapshot(), s && this.notifyListeners("willUpdate") } update() { if (this.updateScheduled = !1, this.isUpdateBlocked()) { this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(wh); return } if (this.animationId <= this.animationCommitId) { this.nodes.forEach(Sh); return } this.animationCommitId = this.animationId, this.isUpdating ? (this.isUpdating = !1, this.nodes.forEach(WC), this.nodes.forEach(BC), this.nodes.forEach(zC)) : this.nodes.forEach(Sh), this.clearAllSnapshots(); const a = ke.now(); pe.delta = Ct(0, 1e3 / 60, a - pe.timestamp), pe.timestamp = a, pe.isProcessing = !0, wa.update.process(pe), wa.preRender.process(pe), wa.render.process(pe), pe.isProcessing = !1 } didUpdate() { this.updateScheduled || (this.updateScheduled = !0, Dc.read(this.scheduleUpdate)) } clearAllSnapshots() { this.nodes.forEach(bC), this.sharedNodes.forEach(XC) } scheduleUpdateProjection() { this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, H.preRender(this.updateProjection, !1, !0)) } scheduleCheckAfterUnmount() { H.postRender(() => { this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed() }) } updateSnapshot() { this.snapshot || !this.instance || (this.snapshot = this.measure(), this.snapshot && !Re(this.snapshot.measuredBox.x) && !Re(this.snapshot.measuredBox.y) && (this.snapshot = void 0)) } updateLayout() { if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return; if (this.resumeFrom && !this.resumeFrom.instance) for (let l = 0; l < this.path.length; l++)this.path[l].updateScroll(); const s = this.layout; this.layout = this.measure(!1), this.layoutVersion++, this.layoutCorrected = ae(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox); const { visualElement: a } = this.options; a && a.notify("LayoutMeasure", this.layout.layoutBox, s ? s.layoutBox : void 0) } updateScroll(s = "measure") { let a = !!(this.options.layoutScroll && this.instance); if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === s && (a = !1), a && this.instance) { const l = r(this.instance); this.scroll = { animationId: this.root.animationId, phase: s, isRoot: l, offset: n(this.instance), wasRoot: this.scroll ? this.scroll.isRoot : l } } } resetTransform() { if (!i) return; const s = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout, a = this.projectionDelta && !Zg(this.projectionDelta), l = this.getTransformTemplate(), u = l ? l(this.latestValues, "") : void 0, c = u !== this.prevTransformTemplateValue; s && this.instance && (a || gn(this.latestValues) || c) && (i(this.instance, u), this.shouldResetTransform = !1, this.scheduleRender()) } measure(s = !0) { const a = this.measurePageBox(); let l = this.removeElementScroll(a); return s && (l = this.removeTransform(l)), JC(l), { animationId: this.root.animationId, measuredBox: a, layoutBox: l, latestValues: {}, source: this.id } } measurePageBox() { var u; const { visualElement: s } = this.options; if (!s) return ae(); const a = s.measureViewportBox(); if (!(((u = this.scroll) == null ? void 0 : u.wasRoot) || this.path.some(ZC))) { const { scroll: c } = this.root; c && (qn(a.x, c.offset.x), qn(a.y, c.offset.y)) } return a } removeElementScroll(s) { var l; const a = ae(); if (ot(a, s), (l = this.scroll) != null && l.wasRoot) return a; for (let u = 0; u < this.path.length; u++) { const c = this.path[u], { scroll: f, options: d } = c; c !== this.root && f && d.layoutScroll && (f.wasRoot && ot(a, s), qn(a.x, f.offset.x), qn(a.y, f.offset.y)) } return a } applyTransform(s, a = !1) { const l = ae(); ot(l, s); for (let u = 0; u < this.path.length; u++) { const c = this.path[u]; !a && c.options.layoutScroll && c.scroll && c !== c.root && Jn(l, { x: -c.scroll.offset.x, y: -c.scroll.offset.y }), gn(c.latestValues) && Jn(l, c.latestValues) } return gn(this.latestValues) && Jn(l, this.latestValues), l } removeTransform(s) { const a = ae(); ot(a, s); for (let l = 0; l < this.path.length; l++) { const u = this.path[l]; if (!u.instance || !gn(u.latestValues)) continue; Yl(u.latestValues) && u.updateSnapshot(); const c = ae(), f = u.measurePageBox(); ot(c, f), hh(a, u.latestValues, u.snapshot ? u.snapshot.layoutBox : void 0, c) } return gn(this.latestValues) && hh(a, this.latestValues), a } setTargetDelta(s) { this.targetDelta = s, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0 } setOptions(s) { this.options = { ...this.options, ...s, crossfade: s.crossfade !== void 0 ? s.crossfade : !0 } } clearMeasurements() { this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1 } forceRelativeParentToResolveTarget() { this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== pe.timestamp && this.relativeParent.resolveTargetDelta(!0) } resolveTargetDelta(s = !1) { var g; const a = this.getLead(); this.isProjectionDirty || (this.isProjectionDirty = a.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = a.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = a.isSharedProjectionDirty); const l = !!this.resumingFrom || this !== a; if (!(s || l && this.isSharedProjectionDirty || this.isProjectionDirty || (g = this.parent) != null && g.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return; const { layout: c, layoutId: f } = this.options; if (!this.layout || !(c || f)) return; this.resolvedRelativeTargetAt = pe.timestamp; const d = this.getClosestProjectingParent(); d && this.linkedParentVersion !== d.layoutVersion && !d.options.layoutRoot && this.removeRelativeTarget(), !this.targetDelta && !this.relativeTarget && (d && d.layout ? this.createRelativeTarget(d, this.layout.layoutBox, d.layout.layoutBox) : this.removeRelativeTarget()), !(!this.relativeTarget && !this.targetDelta) && (this.target || (this.target = ae(), this.targetWithTransforms = ae()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), aC(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : ot(this.target, this.layout.layoutBox), Ng(this.target, this.targetDelta)) : ot(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget && (this.attemptToResolveRelativeTarget = !1, d && !!d.resumingFrom == !!this.resumingFrom && !d.options.layoutScroll && d.target && this.animationProgress !== 1 ? this.createRelativeTarget(d, this.target, d.target) : this.relativeParent = this.relativeTarget = void 0)) } getClosestProjectingParent() { if (!(!this.parent || Yl(this.parent.latestValues) || Og(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent() } isProjecting() { return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout) } createRelativeTarget(s, a, l) { this.relativeParent = s, this.linkedParentVersion = s.layoutVersion, this.forceRelativeParentToResolveTarget(), this.relativeTarget = ae(), this.relativeTargetOrigin = ae(), hs(this.relativeTargetOrigin, a, l), ot(this.relativeTarget, this.relativeTargetOrigin) } removeRelativeTarget() { this.relativeParent = this.relativeTarget = void 0 } calcProjection() { var y; const s = this.getLead(), a = !!this.resumingFrom || this !== s; let l = !0; if ((this.isProjectionDirty || (y = this.parent) != null && y.isProjectionDirty) && (l = !1), a && (this.isSharedProjectionDirty || this.isTransformDirty) && (l = !1), this.resolvedRelativeTargetAt === pe.timestamp && (l = !1), l) return; const { layout: u, layoutId: c } = this.options; if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || c)) return; ot(this.layoutCorrected, this.layout.layoutBox); const f = this.treeScale.x, d = this.treeScale.y; wT(this.layoutCorrected, this.treeScale, this.path, a), s.layout && !s.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (s.target = s.layout.layoutBox, s.targetWithTransforms = ae()); const { target: g } = s; if (!g) { this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender()); return } !this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (ch(this.prevProjectionDelta.x, this.projectionDelta.x), ch(this.prevProjectionDelta.y, this.projectionDelta.y)), ii(this.projectionDelta, this.layoutCorrected, g, this.latestValues), (this.treeScale.x !== f || this.treeScale.y !== d || !vh(this.projectionDelta.x, this.prevProjectionDelta.x) || !vh(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", g)) } hide() { this.isVisible = !1 } show() { this.isVisible = !0 } scheduleRender(s = !0) { var a; if ((a = this.options.visualElement) == null || a.scheduleRender(), s) { const l = this.getStack(); l && l.scheduleRender() } this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0) } createProjectionDeltas() { this.prevProjectionDelta = Zn(), this.projectionDelta = Zn(), this.projectionDeltaWithTransform = Zn() } setAnimationOrigin(s, a = !1) { const l = this.snapshot, u = l ? l.latestValues : {}, c = { ...this.latestValues }, f = Zn(); (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a; const d = ae(), g = l ? l.source : void 0, y = this.layout ? this.layout.source : void 0, v = g !== y, S = this.getStack(), p = !S || S.members.length <= 1, h = !!(v && !p && this.options.crossfade === !0 && !this.path.some(QC)); this.animationProgress = 0; let m; this.mixTargetDelta = x => { const E = x / 1e3; Eh(f.x, s.x, E), Eh(f.y, s.y, E), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (hs(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), YC(this.relativeTarget, this.relativeTargetOrigin, d, E), m && NC(this.relativeTarget, m) && (this.isProjectionDirty = !1), m || (m = ae()), ot(m, this.relativeTarget)), v && (this.animationValues = c, AC(c, u, this.latestValues, E, h, p)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = E }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0) } startAnimation(s) { var a, l, u; this.notifyListeners("animationStart"), (a = this.currentAnimation) == null || a.stop(), (u = (l = this.resumingFrom) == null ? void 0 : l.currentAnimation) == null || u.stop(), this.pendingAnimation && (sn(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = H.update(() => { _o.hasAnimatedSinceResize = !0, this.motionValue || (this.motionValue = pr(0)), this.currentAnimation = TC(this.motionValue, [0, 1e3], { ...s, velocity: 0, isSync: !0, onUpdate: c => { this.mixTargetDelta(c), s.onUpdate && s.onUpdate(c) }, onStop: () => { }, onComplete: () => { s.onComplete && s.onComplete(), this.completeAnimation() } }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0 }) } completeAnimation() { this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0); const s = this.getStack(); s && s.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete") } finishAnimation() { this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(FC), this.currentAnimation.stop()), this.completeAnimation() } applyTransformsToTarget() { const s = this.getLead(); let { targetWithTransforms: a, target: l, layout: u, latestValues: c } = s; if (!(!a || !l || !u)) { if (this !== s && this.layout && u && r0(this.options.animationType, this.layout.layoutBox, u.layoutBox)) { l = this.target || ae(); const f = Re(this.layout.layoutBox.x); l.x.min = s.target.x.min, l.x.max = l.x.min + f; const d = Re(this.layout.layoutBox.y); l.y.min = s.target.y.min, l.y.max = l.y.min + d } ot(a, l), Jn(a, c), ii(this.projectionDeltaWithTransform, this.layoutCorrected, a, c) } } registerSharedNode(s, a) { this.sharedNodes.has(s) || this.sharedNodes.set(s, new VC), this.sharedNodes.get(s).add(a); const u = a.options.initialPromotionConfig; a.promote({ transition: u ? u.transition : void 0, preserveFollowOpacity: u && u.shouldPreserveFollowOpacity ? u.shouldPreserveFollowOpacity(a) : void 0 }) } isLead() { const s = this.getStack(); return s ? s.lead === this : !0 } getLead() { var a; const { layoutId: s } = this.options; return s ? ((a = this.getStack()) == null ? void 0 : a.lead) || this : this } getPrevLead() { var a; const { layoutId: s } = this.options; return s ? (a = this.getStack()) == null ? void 0 : a.prevLead : void 0 } getStack() { const { layoutId: s } = this.options; if (s) return this.root.sharedNodes.get(s) } promote({ needsReset: s, transition: a, preserveFollowOpacity: l } = {}) { const u = this.getStack(); u && u.promote(this, l), s && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({ transition: a }) } relegate() { const s = this.getStack(); return s ? s.relegate(this) : !1 } resetSkewAndRotation() { const { visualElement: s } = this.options; if (!s) return; let a = !1; const { latestValues: l } = s; if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return; const u = {}; l.z && Ma("z", s, u, this.animationValues); for (let c = 0; c < _a.length; c++)Ma(`rotate${_a[c]}`, s, u, this.animationValues), Ma(`skew${_a[c]}`, s, u, this.animationValues); s.render(); for (const c in u) s.setStaticValue(c, u[c]), this.animationValues && (this.animationValues[c] = u[c]); s.scheduleRender() } applyProjectionStyles(s, a) { if (!this.instance || this.isSVG) return; if (!this.isVisible) { s.visibility = "hidden"; return } const l = this.getTransformTemplate(); if (this.needsReset) { this.needsReset = !1, s.visibility = "", s.opacity = "", s.pointerEvents = Do(a == null ? void 0 : a.pointerEvents) || "", s.transform = l ? l(this.latestValues, "") : "none"; return } const u = this.getLead(); if (!this.projectionDelta || !this.layout || !u.target) { this.options.layoutId && (s.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, s.pointerEvents = Do(a == null ? void 0 : a.pointerEvents) || ""), this.hasProjected && !gn(this.latestValues) && (s.transform = l ? l({}, "") : "none", this.hasProjected = !1); return } s.visibility = ""; const c = u.animationValues || u.latestValues; this.applyTransformsToTarget(); let f = IC(this.projectionDeltaWithTransform, this.treeScale, c); l && (f = l(c, f)), s.transform = f; const { x: d, y: g } = this.projectionDelta; s.transformOrigin = `${d.origin * 100}% ${g.origin * 100}% 0`, u.animationValues ? s.opacity = u === this ? c.opacity ?? this.latestValues.opacity ?? 1 : this.preserveOpacity ? this.latestValues.opacity : c.opacityExit : s.opacity = u === this ? c.opacity !== void 0 ? c.opacity : "" : c.opacityExit !== void 0 ? c.opacityExit : 0; for (const y in Xl) { if (c[y] === void 0) continue; const { correct: v, applyTo: S, isCSSVariable: p } = Xl[y], h = f === "none" ? c[y] : v(c[y], u); if (S) { const m = S.length; for (let x = 0; x < m; x++)s[S[x]] = h } else p ? this.options.visualElement.renderState.vars[y] = h : s[y] = h } this.options.layoutId && (s.pointerEvents = u === this ? Do(a == null ? void 0 : a.pointerEvents) || "" : "none") } clearSnapshot() { this.resumeFrom = this.snapshot = void 0 } resetTree() { this.root.nodes.forEach(s => { var a; return (a = s.currentAnimation) == null ? void 0 : a.stop() }), this.root.nodes.forEach(wh), this.root.sharedNodes.clear() } } } function BC(e) { e.updateLayout() } function zC(e) { var n; const t = ((n = e.resumeFrom) == null ? void 0 : n.snapshot) || e.snapshot; if (e.isLead() && e.layout && t && e.hasListeners("didUpdate")) { const { layoutBox: r, measuredBox: i } = e.layout, { animationType: o } = e.options, s = t.source !== e.layout.source; o === "size" ? Xe(f => { const d = s ? t.measuredBox[f] : t.layoutBox[f], g = Re(d); d.min = r[f].min, d.max = d.min + g }) : r0(o, t.layoutBox, r) && Xe(f => { const d = s ? t.measuredBox[f] : t.layoutBox[f], g = Re(r[f]); d.max = d.min + g, e.relativeTarget && !e.currentAnimation && (e.isProjectionDirty = !0, e.relativeTarget[f].max = e.relativeTarget[f].min + g) }); const a = Zn(); ii(a, r, t.layoutBox); const l = Zn(); s ? ii(l, e.applyTransform(i, !0), t.measuredBox) : ii(l, r, t.layoutBox); const u = !Zg(a); let c = !1; if (!e.resumeFrom) { const f = e.getClosestProjectingParent(); if (f && !f.resumeFrom) { const { snapshot: d, layout: g } = f; if (d && g) { const y = ae(); hs(y, t.layoutBox, d.layoutBox); const v = ae(); hs(v, r, g.layoutBox), e0(y, v) || (c = !0), f.options.layoutRoot && (e.relativeTarget = v, e.relativeTargetOrigin = y, e.relativeParent = f) } } } e.notifyListeners("didUpdate", { layout: r, snapshot: t, delta: l, layoutDelta: a, hasLayoutChanged: u, hasRelativeLayoutChanged: c }) } else if (e.isLead()) { const { onExitComplete: r } = e.options; r && r() } e.options.transition = void 0 } function UC(e) { e.parent && (e.isProjecting() || (e.isProjectionDirty = e.parent.isProjectionDirty), e.isSharedProjectionDirty || (e.isSharedProjectionDirty = !!(e.isProjectionDirty || e.parent.isProjectionDirty || e.parent.isSharedProjectionDirty)), e.isTransformDirty || (e.isTransformDirty = e.parent.isTransformDirty)) } function $C(e) { e.isProjectionDirty = e.isSharedProjectionDirty = e.isTransformDirty = !1 } function bC(e) { e.clearSnapshot() } function wh(e) { e.clearMeasurements() } function Sh(e) { e.isLayoutDirty = !1 } function WC(e) { const { visualElement: t } = e.options; t && t.getProps().onBeforeLayoutMeasure && t.notify("BeforeLayoutMeasure"), e.resetTransform() } function xh(e) { e.finishAnimation(), e.targetDelta = e.relativeTarget = e.target = void 0, e.isProjectionDirty = !0 } function HC(e) { e.resolveTargetDelta() } function KC(e) { e.calcProjection() } function GC(e) { e.resetSkewAndRotation() } function XC(e) { e.removeLeadSnapshot() } function Eh(e, t, n) { e.translate = J(t.translate, 0, n), e.scale = J(t.scale, 1, n), e.origin = t.origin, e.originPoint = t.originPoint } function Th(e, t, n, r) { e.min = J(t.min, n.min, r), e.max = J(t.max, n.max, r) } function YC(e, t, n, r) { Th(e.x, t.x, n.x, r), Th(e.y, t.y, n.y, r) } function QC(e) { return e.animationValues && e.animationValues.opacityExit !== void 0 } const qC = { duration: .45, ease: [.4, 0, .1, 1] }, Ch = e => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(e), Ph = Ch("applewebkit/") && !Ch("chrome/") ? Math.round : et; function kh(e) { e.min = Ph(e.min), e.max = Ph(e.max) } function JC(e) { kh(e.x), kh(e.y) } function r0(e, t, n) { return e === "position" || e === "preserve-aspect" && !sC(gh(t), gh(n), .2) } function ZC(e) { var t; return e !== e.root && ((t = e.scroll) == null ? void 0 : t.wasRoot) } const eP = n0({ attachResizeListener: (e, t) => Ri(e, "resize", t), measureScroll: () => ({ x: document.documentElement.scrollLeft || document.body.scrollLeft, y: document.documentElement.scrollTop || document.body.scrollTop }), checkIsScrollRoot: () => !0 }), Oa = { current: void 0 }, i0 = n0({ measureScroll: e => ({ x: e.scrollLeft, y: e.scrollTop }), defaultParent: () => { if (!Oa.current) { const e = new eP({}); e.mount(window), e.setOptions({ layoutScroll: !0 }), Oa.current = e } return Oa.current }, resetTransform: (e, t) => { e.style.transform = t !== void 0 ? t : "none" }, checkIsScrollRoot: e => window.getComputedStyle(e).position === "fixed" }), tP = { pan: { Feature: xC }, drag: { Feature: SC, ProjectionNode: i0, MeasureLayout: Qg } }; function Rh(e, t, n) { const { props: r } = e; e.animationState && r.whileHover && e.animationState.setActive("whileHover", n === "Start"); const i = "onHover" + n, o = r[i]; o && H.postRender(() => o(t, Bi(t))) } class nP extends fn { mount() { const { current: t } = this.node; t && (this.unmount = PE(t, (n, r) => (Rh(this.node, r, "Start"), i => Rh(this.node, i, "End")))) } unmount() { } } class rP extends fn { constructor() { super(...arguments), this.isActive = !1 } onFocus() { let t = !1; try { t = this.node.current.matches(":focus-visible") } catch { t = !0 } !t || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0) } onBlur() { !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1) } mount() { this.unmount = Ii(Ri(this.node.current, "focus", () => this.onFocus()), Ri(this.node.current, "blur", () => this.onBlur())) } unmount() { } } function Ah(e, t, n) { const { props: r } = e; if (e.current instanceof HTMLButtonElement && e.current.disabled) return; e.animationState && r.whileTap && e.animationState.setActive("whileTap", n === "Start"); const i = "onTap" + (n === "End" ? "" : n), o = r[i]; o && H.postRender(() => o(t, Bi(t))) } class iP extends fn { mount() { const { current: t } = this.node; t && (this.unmount = AE(t, (n, r) => (Ah(this.node, r, "Start"), (i, { success: o }) => Ah(this.node, i, o ? "End" : "Cancel")), { useGlobalTarget: this.node.props.globalTapTarget })) } unmount() { } } const nu = new WeakMap, Na = new WeakMap, oP = e => { const t = nu.get(e.target); t && t(e) }, sP = e => { e.forEach(oP) }; function aP({ root: e, ...t }) { const n = e || document; Na.has(n) || Na.set(n, {}); const r = Na.get(n), i = JSON.stringify(t); return r[i] || (r[i] = new IntersectionObserver(sP, { root: e, ...t })), r[i] } function lP(e, t, n) { const r = aP(t); return nu.set(e, n), r.observe(e), () => { nu.delete(e), r.unobserve(e) } } const uP = { some: 0, all: 1 }; class cP extends fn { constructor() { super(...arguments), this.hasEnteredView = !1, this.isInView = !1 } startObserver() { this.unmount(); const { viewport: t = {} } = this.node.getProps(), { root: n, margin: r, amount: i = "some", once: o } = t, s = { root: n ? n.current : void 0, rootMargin: r, threshold: typeof i == "number" ? i : uP[i] }, a = l => { const { isIntersecting: u } = l; if (this.isInView === u || (this.isInView = u, o && !u && this.hasEnteredView)) return; u && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", u); const { onViewportEnter: c, onViewportLeave: f } = this.node.getProps(), d = u ? c : f; d && d(l) }; return lP(this.node.current, s, a) } mount() { this.startObserver() } update() { if (typeof IntersectionObserver > "u") return; const { props: t, prevProps: n } = this.node;["amount", "margin", "root"].some(fP(t, n)) && this.startObserver() } unmount() { } } function fP({ viewport: e = {} }, { viewport: t = {} } = {}) { return n => e[n] !== t[n] } const dP = { inView: { Feature: cP }, tap: { Feature: iP }, focus: { Feature: rP }, hover: { Feature: nP } }, hP = { layout: { ProjectionNode: i0, MeasureLayout: Qg } }, pP = { ...eC, ...dP, ...tP, ...hP }, Mo = yT(pP, LT);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const mP = e => e.replace(/([a-z0-9])([A-Z])/g, "$1-$2").toLowerCase(), yP = e => e.replace(/^([A-Z])|[\s-_]+(\w)/g, (t, n, r) => r ? r.toUpperCase() : n.toLowerCase()), Lh = e => { const t = yP(e); return t.charAt(0).toUpperCase() + t.slice(1) }, o0 = (...e) => e.filter((t, n, r) => !!t && t.trim() !== "" && r.indexOf(t) === n).join(" ").trim(), gP = e => { for (const t in e) if (t.startsWith("aria-") || t === "role" || t === "title") return !0 };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var vP = { xmlns: "http://www.w3.org/2000/svg", width: 24, height: 24, viewBox: "0 0 24 24", fill: "none", stroke: "currentColor", strokeWidth: 2, strokeLinecap: "round", strokeLinejoin: "round" };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const wP = w.forwardRef(({ color: e = "currentColor", size: t = 24, strokeWidth: n = 2, absoluteStrokeWidth: r, className: i = "", children: o, iconNode: s, ...a }, l) => w.createElement("svg", { ref: l, ...vP, width: t, height: t, stroke: e, strokeWidth: r ? Number(n) * 24 / Number(t) : n, className: o0("lucide", i), ...!o && !gP(a) && { "aria-hidden": "true" }, ...a }, [...s.map(([u, c]) => w.createElement(u, c)), ...Array.isArray(o) ? o : [o]]));/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kr = (e, t) => { const n = w.forwardRef(({ className: r, ...i }, o) => w.createElement(wP, { ref: o, iconNode: t, className: o0(`lucide-${mP(Lh(e))}`, `lucide-${e}`, r), ...i })); return n.displayName = Lh(e), n };/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const SP = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["line", { x1: "12", x2: "12", y1: "8", y2: "12", key: "1pkeuh" }], ["line", { x1: "12", x2: "12.01", y1: "16", y2: "16", key: "4dfq90" }]], xP = kr("circle-alert", SP);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const EP = [["path", { d: "M21.801 10A10 10 0 1 1 17 3.335", key: "yps3ct" }], ["path", { d: "m9 11 3 3L22 4", key: "1pflzl" }]], TP = kr("circle-check-big", EP);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const CP = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "m15 9-6 6", key: "1uzhvr" }], ["path", { d: "m9 9 6 6", key: "z0biqf" }]], PP = kr("circle-x", CP);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const kP = [["circle", { cx: "12", cy: "12", r: "10", key: "1mglay" }], ["path", { d: "M12 16v-4", key: "1dtifu" }], ["path", { d: "M12 8h.01", key: "e9boi3" }]], RP = kr("info", kP);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const AP = [["path", { d: "M21 12a9 9 0 1 1-6.219-8.56", key: "13zald" }]], LP = kr("loader-circle", AP);/**
 * @license lucide-react v0.562.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const DP = [["path", { d: "M18 6 6 18", key: "1bl5f8" }], ["path", { d: "m6 6 12 12", key: "d8bk6v" }]], _P = kr("x", DP), MP = ({ message: e = "Authenticating..." }) => R.jsx(Mo.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, style: { position: "fixed", top: 0, left: 0, width: "100vw", height: "100vh", zIndex: 1e4, display: "flex", flexDirection: "column", alignItems: "center", justifyContent: "center", background: "rgba(255, 255, 255, 0.6)", backdropFilter: "blur(12px)", WebkitBackdropFilter: "blur(12px)" }, children: R.jsxs(Mo.div, { initial: { scale: .8, opacity: 0 }, animate: { scale: 1, opacity: 1 }, transition: { type: "spring", damping: 25, stiffness: 200 }, style: { background: "white", padding: "3rem", borderRadius: "40px", boxShadow: "0 25px 50px -12px rgba(0, 0, 0, 0.15)", border: "1px solid rgba(255, 255, 255, 0.3)", display: "flex", flexDirection: "column", alignItems: "center", gap: "1.5rem", minWidth: "280px" }, children: [R.jsx(Mo.div, { animate: { rotate: 360 }, transition: { repeat: 1 / 0, duration: 1, ease: "linear" }, style: { color: "#10b981", display: "flex", alignItems: "center", justifyContent: "center", width: "64px", height: "64px" }, children: R.jsx(LP, { size: 56, strokeWidth: 2 }) }), R.jsxs("div", { style: { textAlign: "center" }, children: [R.jsx("h3", { style: { margin: 0, color: "rgb\(18 37 74\)", fontSize: "1.25rem", fontWeight: "800", letterSpacing: "-0.025em" }, children: e }), R.jsx("p", { style: { margin: "8px 0 0", color: "#778eaeff", fontSize: "0.9rem", fontWeight: "500" }, children: "Please wait a moment" })] })] }) }); function s0(e, t) { return function () { return e.apply(t, arguments) } } const { toString: OP } = Object.prototype, { getPrototypeOf: $c } = Object, { iterator: js, toStringTag: a0 } = Symbol, Bs = (e => t => { const n = OP.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), mt = e => (e = e.toLowerCase(), t => Bs(t) === e), zs = e => t => typeof t === e, { isArray: Rr } = Array, yr = zs("undefined"); function zi(e) { return e !== null && !yr(e) && e.constructor !== null && !yr(e.constructor) && Ie(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const l0 = mt("ArrayBuffer"); function NP(e) { let t; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && l0(e.buffer), t } const VP = zs("string"), Ie = zs("function"), u0 = zs("number"), Ui = e => e !== null && typeof e == "object", IP = e => e === !0 || e === !1, Oo = e => { if (Bs(e) !== "object") return !1; const t = $c(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(a0 in e) && !(js in e) }, FP = e => { if (!Ui(e) || zi(e)) return !1; try { return Object.keys(e).length === 0 && Object.getPrototypeOf(e) === Object.prototype } catch { return !1 } }, jP = mt("Date"), BP = mt("File"), zP = mt("Blob"), UP = mt("FileList"), $P = e => Ui(e) && Ie(e.pipe), bP = e => { let t; return e && (typeof FormData == "function" && e instanceof FormData || Ie(e.append) && ((t = Bs(e)) === "formdata" || t === "object" && Ie(e.toString) && e.toString() === "[object FormData]")) }, WP = mt("URLSearchParams"), [HP, KP, GP, XP] = ["ReadableStream", "Request", "Response", "Headers"].map(mt), YP = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function $i(e, t, { allOwnKeys: n = !1 } = {}) { if (e === null || typeof e > "u") return; let r, i; if (typeof e != "object" && (e = [e]), Rr(e)) for (r = 0, i = e.length; r < i; r++)t.call(null, e[r], r, e); else { if (zi(e)) return; const o = n ? Object.getOwnPropertyNames(e) : Object.keys(e), s = o.length; let a; for (r = 0; r < s; r++)a = o[r], t.call(null, e[a], a, e) } } function c0(e, t) { if (zi(e)) return null; t = t.toLowerCase(); const n = Object.keys(e); let r = n.length, i; for (; r-- > 0;)if (i = n[r], t === i.toLowerCase()) return i; return null } const Tn = (() => typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global)(), f0 = e => !yr(e) && e !== Tn; function ru() { const { caseless: e, skipUndefined: t } = f0(this) && this || {}, n = {}, r = (i, o) => { const s = e && c0(n, o) || o; Oo(n[s]) && Oo(i) ? n[s] = ru(n[s], i) : Oo(i) ? n[s] = ru({}, i) : Rr(i) ? n[s] = i.slice() : (!t || !yr(i)) && (n[s] = i) }; for (let i = 0, o = arguments.length; i < o; i++)arguments[i] && $i(arguments[i], r); return n } const QP = (e, t, n, { allOwnKeys: r } = {}) => ($i(t, (i, o) => { n && Ie(i) ? e[o] = s0(i, n) : e[o] = i }, { allOwnKeys: r }), e), qP = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), JP = (e, t, n, r) => { e.prototype = Object.create(t.prototype, r), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, ZP = (e, t, n, r) => { let i, o, s; const a = {}; if (t = t || {}, e == null) return t; do { for (i = Object.getOwnPropertyNames(e), o = i.length; o-- > 0;)s = i[o], (!r || r(s, e, t)) && !a[s] && (t[s] = e[s], a[s] = !0); e = n !== !1 && $c(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, ek = (e, t, n) => { e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length; const r = e.indexOf(t, n); return r !== -1 && r === n }, tk = e => { if (!e) return null; if (Rr(e)) return e; let t = e.length; if (!u0(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, nk = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && $c(Uint8Array)), rk = (e, t) => { const r = (e && e[js]).call(e); let i; for (; (i = r.next()) && !i.done;) { const o = i.value; t.call(e, o[0], o[1]) } }, ik = (e, t) => { let n; const r = []; for (; (n = e.exec(t)) !== null;)r.push(n); return r }, ok = mt("HTMLFormElement"), sk = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, r, i) { return r.toUpperCase() + i }), Dh = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), ak = mt("RegExp"), d0 = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), r = {}; $i(n, (i, o) => { let s; (s = t(i, o, e)) !== !1 && (r[o] = s || i) }), Object.defineProperties(e, r) }, lk = e => { d0(e, (t, n) => { if (Ie(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1; const r = e[n]; if (Ie(r)) { if (t.enumerable = !1, "writable" in t) { t.writable = !1; return } t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") }) } }) }, uk = (e, t) => { const n = {}, r = i => { i.forEach(o => { n[o] = !0 }) }; return Rr(e) ? r(e) : r(String(e).split(t)), n }, ck = () => { }, fk = (e, t) => e != null && Number.isFinite(e = +e) ? e : t; function dk(e) { return !!(e && Ie(e.append) && e[a0] === "FormData" && e[js]) } const hk = e => { const t = new Array(10), n = (r, i) => { if (Ui(r)) { if (t.indexOf(r) >= 0) return; if (zi(r)) return r; if (!("toJSON" in r)) { t[i] = r; const o = Rr(r) ? [] : {}; return $i(r, (s, a) => { const l = n(s, i + 1); !yr(l) && (o[a] = l) }), t[i] = void 0, o } } return r }; return n(e, 0) }, pk = mt("AsyncFunction"), mk = e => e && (Ui(e) || Ie(e)) && Ie(e.then) && Ie(e.catch), h0 = ((e, t) => e ? setImmediate : t ? ((n, r) => (Tn.addEventListener("message", ({ source: i, data: o }) => { i === Tn && o === n && r.length && r.shift()() }, !1), i => { r.push(i), Tn.postMessage(n, "*") }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", Ie(Tn.postMessage)), yk = typeof queueMicrotask < "u" ? queueMicrotask.bind(Tn) : typeof process < "u" && process.nextTick || h0, gk = e => e != null && Ie(e[js]), T = { isArray: Rr, isArrayBuffer: l0, isBuffer: zi, isFormData: bP, isArrayBufferView: NP, isString: VP, isNumber: u0, isBoolean: IP, isObject: Ui, isPlainObject: Oo, isEmptyObject: FP, isReadableStream: HP, isRequest: KP, isResponse: GP, isHeaders: XP, isUndefined: yr, isDate: jP, isFile: BP, isBlob: zP, isRegExp: ak, isFunction: Ie, isStream: $P, isURLSearchParams: WP, isTypedArray: nk, isFileList: UP, forEach: $i, merge: ru, extend: QP, trim: YP, stripBOM: qP, inherits: JP, toFlatObject: ZP, kindOf: Bs, kindOfTest: mt, endsWith: ek, toArray: tk, forEachEntry: rk, matchAll: ik, isHTMLForm: ok, hasOwnProperty: Dh, hasOwnProp: Dh, reduceDescriptors: d0, freezeMethods: lk, toObjectSet: uk, toCamelCase: sk, noop: ck, toFiniteNumber: fk, findKey: c0, global: Tn, isContextDefined: f0, isSpecCompliantForm: dk, toJSONObject: hk, isAsyncFn: pk, isThenable: mk, setImmediate: h0, asap: yk, isIterable: gk }; function I(e, t, n, r, i) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), r && (this.request = r), i && (this.response = i, this.status = i.status ? i.status : null) } T.inherits(I, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: T.toJSONObject(this.config), code: this.code, status: this.status } } }); const p0 = I.prototype, m0 = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { m0[e] = { value: e } }); Object.defineProperties(I, m0); Object.defineProperty(p0, "isAxiosError", { value: !0 }); I.from = (e, t, n, r, i, o) => { const s = Object.create(p0); T.toFlatObject(e, s, function (c) { return c !== Error.prototype }, u => u !== "isAxiosError"); const a = e && e.message ? e.message : "Error", l = t == null && e ? e.code : t; return I.call(s, a, l, n, r, i), e && s.cause == null && Object.defineProperty(s, "cause", { value: e, configurable: !0 }), s.name = e && e.name || "Error", o && Object.assign(s, o), s }; const vk = null; function iu(e) { return T.isPlainObject(e) || T.isArray(e) } function y0(e) { return T.endsWith(e, "[]") ? e.slice(0, -2) : e } function _h(e, t, n) { return e ? e.concat(t).map(function (i, o) { return i = y0(i), !n && o ? "[" + i + "]" : i }).join(n ? "." : "") : t } function wk(e) { return T.isArray(e) && !e.some(iu) } const Sk = T.toFlatObject(T, {}, null, function (t) { return /^is[A-Z]/.test(t) }); function Us(e, t, n) { if (!T.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData, n = T.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (v, S) { return !T.isUndefined(S[v]) }); const r = n.metaTokens, i = n.visitor || c, o = n.dots, s = n.indexes, l = (n.Blob || typeof Blob < "u" && Blob) && T.isSpecCompliantForm(t); if (!T.isFunction(i)) throw new TypeError("visitor must be a function"); function u(y) { if (y === null) return ""; if (T.isDate(y)) return y.toISOString(); if (T.isBoolean(y)) return y.toString(); if (!l && T.isBlob(y)) throw new I("Blob is not supported. Use a Buffer instead."); return T.isArrayBuffer(y) || T.isTypedArray(y) ? l && typeof Blob == "function" ? new Blob([y]) : Buffer.from(y) : y } function c(y, v, S) { let p = y; if (y && !S && typeof y == "object") { if (T.endsWith(v, "{}")) v = r ? v : v.slice(0, -2), y = JSON.stringify(y); else if (T.isArray(y) && wk(y) || (T.isFileList(y) || T.endsWith(v, "[]")) && (p = T.toArray(y))) return v = y0(v), p.forEach(function (m, x) { !(T.isUndefined(m) || m === null) && t.append(s === !0 ? _h([v], x, o) : s === null ? v : v + "[]", u(m)) }), !1 } return iu(y) ? !0 : (t.append(_h(S, v, o), u(y)), !1) } const f = [], d = Object.assign(Sk, { defaultVisitor: c, convertValue: u, isVisitable: iu }); function g(y, v) { if (!T.isUndefined(y)) { if (f.indexOf(y) !== -1) throw Error("Circular reference detected in " + v.join(".")); f.push(y), T.forEach(y, function (p, h) { (!(T.isUndefined(p) || p === null) && i.call(t, p, T.isString(h) ? h.trim() : h, v, d)) === !0 && g(p, v ? v.concat(h) : [h]) }), f.pop() } } if (!T.isObject(e)) throw new TypeError("data must be an object"); return g(e), t } function Mh(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (r) { return t[r] }) } function bc(e, t) { this._pairs = [], e && Us(e, this, t) } const g0 = bc.prototype; g0.append = function (t, n) { this._pairs.push([t, n]) }; g0.toString = function (t) { const n = t ? function (r) { return t.call(this, r, Mh) } : Mh; return this._pairs.map(function (i) { return n(i[0]) + "=" + n(i[1]) }, "").join("&") }; function xk(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+") } function v0(e, t, n) { if (!t) return e; const r = n && n.encode || xk; T.isFunction(n) && (n = { serialize: n }); const i = n && n.serialize; let o; if (i ? o = i(t, n) : o = T.isURLSearchParams(t) ? t.toString() : new bc(t, n).toString(r), o) { const s = e.indexOf("#"); s !== -1 && (e = e.slice(0, s)), e += (e.indexOf("?") === -1 ? "?" : "&") + o } return e } class Ek { constructor() { this.handlers = [] } use(t, n, r) { return this.handlers.push({ fulfilled: t, rejected: n, synchronous: r ? r.synchronous : !1, runWhen: r ? r.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { T.forEach(this.handlers, function (r) { r !== null && t(r) }) } } const Oh = Ek, w0 = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Tk = typeof URLSearchParams < "u" ? URLSearchParams : bc, Ck = typeof FormData < "u" ? FormData : null, Pk = typeof Blob < "u" ? Blob : null, kk = { isBrowser: !0, classes: { URLSearchParams: Tk, FormData: Ck, Blob: Pk }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Wc = typeof window < "u" && typeof document < "u", ou = typeof navigator == "object" && navigator || void 0, Rk = Wc && (!ou || ["ReactNative", "NativeScript", "NS"].indexOf(ou.product) < 0), Ak = (() => typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function")(), Lk = Wc && window.location.href || "http://localhost", Dk = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Wc, hasStandardBrowserEnv: Rk, hasStandardBrowserWebWorkerEnv: Ak, navigator: ou, origin: Lk }, Symbol.toStringTag, { value: "Module" })), Se = { ...Dk, ...kk }; function _k(e, t) { return Us(e, new Se.classes.URLSearchParams, { visitor: function (n, r, i, o) { return Se.isNode && T.isBuffer(n) ? (this.append(r, n.toString("base64")), !1) : o.defaultVisitor.apply(this, arguments) }, ...t }) } function Mk(e) { return T.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0]) } function Ok(e) { const t = {}, n = Object.keys(e); let r; const i = n.length; let o; for (r = 0; r < i; r++)o = n[r], t[o] = e[o]; return t } function S0(e) { function t(n, r, i, o) { let s = n[o++]; if (s === "__proto__") return !0; const a = Number.isFinite(+s), l = o >= n.length; return s = !s && T.isArray(i) ? i.length : s, l ? (T.hasOwnProp(i, s) ? i[s] = [i[s], r] : i[s] = r, !a) : ((!i[s] || !T.isObject(i[s])) && (i[s] = []), t(n, r, i[s], o) && T.isArray(i[s]) && (i[s] = Ok(i[s])), !a) } if (T.isFormData(e) && T.isFunction(e.entries)) { const n = {}; return T.forEachEntry(e, (r, i) => { t(Mk(r), i, n, 0) }), n } return null } function Nk(e, t, n) { if (T.isString(e)) try { return (t || JSON.parse)(e), T.trim(e) } catch (r) { if (r.name !== "SyntaxError") throw r } return (n || JSON.stringify)(e) } const Hc = { transitional: w0, adapter: ["xhr", "http", "fetch"], transformRequest: [function (t, n) { const r = n.getContentType() || "", i = r.indexOf("application/json") > -1, o = T.isObject(t); if (o && T.isHTMLForm(t) && (t = new FormData(t)), T.isFormData(t)) return i ? JSON.stringify(S0(t)) : t; if (T.isArrayBuffer(t) || T.isBuffer(t) || T.isStream(t) || T.isFile(t) || T.isBlob(t) || T.isReadableStream(t)) return t; if (T.isArrayBufferView(t)) return t.buffer; if (T.isURLSearchParams(t)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let a; if (o) { if (r.indexOf("application/x-www-form-urlencoded") > -1) return _k(t, this.formSerializer).toString(); if ((a = T.isFileList(t)) || r.indexOf("multipart/form-data") > -1) { const l = this.env && this.env.FormData; return Us(a ? { "files[]": t } : t, l && new l, this.formSerializer) } } return o || i ? (n.setContentType("application/json", !1), Nk(t)) : t }], transformResponse: [function (t) { const n = this.transitional || Hc.transitional, r = n && n.forcedJSONParsing, i = this.responseType === "json"; if (T.isResponse(t) || T.isReadableStream(t)) return t; if (t && T.isString(t) && (r && !this.responseType || i)) { const s = !(n && n.silentJSONParsing) && i; try { return JSON.parse(t, this.parseReviver) } catch (a) { if (s) throw a.name === "SyntaxError" ? I.from(a, I.ERR_BAD_RESPONSE, this, null, this.response) : a } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: Se.classes.FormData, Blob: Se.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; T.forEach(["delete", "get", "head", "post", "put", "patch"], e => { Hc.headers[e] = {} }); const Kc = Hc, Vk = T.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), Ik = e => {
  const t = {}; let n, r, i; return e && e.split(`
`).forEach(function (s) { i = s.indexOf(":"), n = s.substring(0, i).trim().toLowerCase(), r = s.substring(i + 1).trim(), !(!n || t[n] && Vk[n]) && (n === "set-cookie" ? t[n] ? t[n].push(r) : t[n] = [r] : t[n] = t[n] ? t[n] + ", " + r : r) }), t
}, Nh = Symbol("internals"); function Br(e) { return e && String(e).trim().toLowerCase() } function No(e) { return e === !1 || e == null ? e : T.isArray(e) ? e.map(No) : String(e) } function Fk(e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let r; for (; r = n.exec(e);)t[r[1]] = r[2]; return t } const jk = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()); function Va(e, t, n, r, i) { if (T.isFunction(r)) return r.call(this, t, n); if (i && (t = n), !!T.isString(t)) { if (T.isString(r)) return t.indexOf(r) !== -1; if (T.isRegExp(r)) return r.test(t) } } function Bk(e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, r) => n.toUpperCase() + r) } function zk(e, t) { const n = T.toCamelCase(" " + t);["get", "set", "has"].forEach(r => { Object.defineProperty(e, r + n, { value: function (i, o, s) { return this[r].call(this, t, i, o, s) }, configurable: !0 }) }) } class $s {
  constructor(t) { t && this.set(t) } set(t, n, r) { const i = this; function o(a, l, u) { const c = Br(l); if (!c) throw new Error("header name must be a non-empty string"); const f = T.findKey(i, c); (!f || i[f] === void 0 || u === !0 || u === void 0 && i[f] !== !1) && (i[f || l] = No(a)) } const s = (a, l) => T.forEach(a, (u, c) => o(u, c, l)); if (T.isPlainObject(t) || t instanceof this.constructor) s(t, n); else if (T.isString(t) && (t = t.trim()) && !jk(t)) s(Ik(t), n); else if (T.isObject(t) && T.isIterable(t)) { let a = {}, l, u; for (const c of t) { if (!T.isArray(c)) throw TypeError("Object iterator must return a key-value pair"); a[u = c[0]] = (l = a[u]) ? T.isArray(l) ? [...l, c[1]] : [l, c[1]] : c[1] } s(a, n) } else t != null && o(n, t, r); return this } get(t, n) { if (t = Br(t), t) { const r = T.findKey(this, t); if (r) { const i = this[r]; if (!n) return i; if (n === !0) return Fk(i); if (T.isFunction(n)) return n.call(this, i, r); if (T.isRegExp(n)) return n.exec(i); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, n) { if (t = Br(t), t) { const r = T.findKey(this, t); return !!(r && this[r] !== void 0 && (!n || Va(this, this[r], r, n))) } return !1 } delete(t, n) { const r = this; let i = !1; function o(s) { if (s = Br(s), s) { const a = T.findKey(r, s); a && (!n || Va(r, r[a], a, n)) && (delete r[a], i = !0) } } return T.isArray(t) ? t.forEach(o) : o(t), i } clear(t) { const n = Object.keys(this); let r = n.length, i = !1; for (; r--;) { const o = n[r]; (!t || Va(this, this[o], o, t, !0)) && (delete this[o], i = !0) } return i } normalize(t) { const n = this, r = {}; return T.forEach(this, (i, o) => { const s = T.findKey(r, o); if (s) { n[s] = No(i), delete n[o]; return } const a = t ? Bk(o) : String(o).trim(); a !== o && delete n[o], n[a] = No(i), r[a] = !0 }), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const n = Object.create(null); return T.forEach(this, (r, i) => { r != null && r !== !1 && (n[i] = t && T.isArray(r) ? r.join(", ") : r) }), n } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
    return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`)
  } getSetCookie() { return this.get("set-cookie") || [] } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...n) { const r = new this(t); return n.forEach(i => r.set(i)), r } static accessor(t) { const r = (this[Nh] = this[Nh] = { accessors: {} }).accessors, i = this.prototype; function o(s) { const a = Br(s); r[a] || (zk(i, s), r[a] = !0) } return T.isArray(t) ? t.forEach(o) : o(t), this }
} $s.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); T.reduceDescriptors($s.prototype, ({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(r) { this[n] = r } } }); T.freezeMethods($s); const dt = $s; function Ia(e, t) { const n = this || Kc, r = t || n, i = dt.from(r.headers); let o = r.data; return T.forEach(e, function (a) { o = a.call(n, o, i.normalize(), t ? t.status : void 0) }), i.normalize(), o } function x0(e) { return !!(e && e.__CANCEL__) } function Ar(e, t, n) { I.call(this, e ?? "canceled", I.ERR_CANCELED, t, n), this.name = "CanceledError" } T.inherits(Ar, I, { __CANCEL__: !0 }); function E0(e, t, n) { const r = n.config.validateStatus; !n.status || !r || r(n.status) ? e(n) : t(new I("Request failed with status code " + n.status, [I.ERR_BAD_REQUEST, I.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) } function Uk(e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" } function $k(e, t) { e = e || 10; const n = new Array(e), r = new Array(e); let i = 0, o = 0, s; return t = t !== void 0 ? t : 1e3, function (l) { const u = Date.now(), c = r[o]; s || (s = u), n[i] = l, r[i] = u; let f = o, d = 0; for (; f !== i;)d += n[f++], f = f % e; if (i = (i + 1) % e, i === o && (o = (o + 1) % e), u - s < t) return; const g = c && u - c; return g ? Math.round(d * 1e3 / g) : void 0 } } function bk(e, t) { let n = 0, r = 1e3 / t, i, o; const s = (u, c = Date.now()) => { n = c, i = null, o && (clearTimeout(o), o = null), e(...u) }; return [(...u) => { const c = Date.now(), f = c - n; f >= r ? s(u, c) : (i = u, o || (o = setTimeout(() => { o = null, s(i) }, r - f))) }, () => i && s(i)] } const ps = (e, t, n = 3) => { let r = 0; const i = $k(50, 250); return bk(o => { const s = o.loaded, a = o.lengthComputable ? o.total : void 0, l = s - r, u = i(l), c = s <= a; r = s; const f = { loaded: s, total: a, progress: a ? s / a : void 0, bytes: l, rate: u || void 0, estimated: u && a && c ? (a - s) / u : void 0, event: o, lengthComputable: a != null, [t ? "download" : "upload"]: !0 }; e(f) }, n) }, Vh = (e, t) => { const n = e != null; return [r => t[0]({ lengthComputable: n, total: e, loaded: r }), t[1]] }, Ih = e => (...t) => T.asap(() => e(...t)), Wk = Se.hasStandardBrowserEnv ? ((e, t) => n => (n = new URL(n, Se.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(Se.origin), Se.navigator && /(msie|trident)/i.test(Se.navigator.userAgent)) : () => !0, Hk = Se.hasStandardBrowserEnv ? { write(e, t, n, r, i, o, s) { if (typeof document > "u") return; const a = [`${e}=${encodeURIComponent(t)}`]; T.isNumber(n) && a.push(`expires=${new Date(n).toUTCString()}`), T.isString(r) && a.push(`path=${r}`), T.isString(i) && a.push(`domain=${i}`), o === !0 && a.push("secure"), T.isString(s) && a.push(`SameSite=${s}`), document.cookie = a.join("; ") }, read(e) { if (typeof document > "u") return null; const t = document.cookie.match(new RegExp("(?:^|; )" + e + "=([^;]*)")); return t ? decodeURIComponent(t[1]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5, "/") } } : { write() { }, read() { return null }, remove() { } }; function Kk(e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) } function Gk(e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e } function T0(e, t, n) { let r = !Kk(t); return e && (r || n == !1) ? Gk(e, t) : t } const Fh = e => e instanceof dt ? { ...e } : e; function On(e, t) { t = t || {}; const n = {}; function r(u, c, f, d) { return T.isPlainObject(u) && T.isPlainObject(c) ? T.merge.call({ caseless: d }, u, c) : T.isPlainObject(c) ? T.merge({}, c) : T.isArray(c) ? c.slice() : c } function i(u, c, f, d) { if (T.isUndefined(c)) { if (!T.isUndefined(u)) return r(void 0, u, f, d) } else return r(u, c, f, d) } function o(u, c) { if (!T.isUndefined(c)) return r(void 0, c) } function s(u, c) { if (T.isUndefined(c)) { if (!T.isUndefined(u)) return r(void 0, u) } else return r(void 0, c) } function a(u, c, f) { if (f in t) return r(u, c); if (f in e) return r(void 0, u) } const l = { url: o, method: o, data: o, baseURL: s, transformRequest: s, transformResponse: s, paramsSerializer: s, timeout: s, timeoutMessage: s, withCredentials: s, withXSRFToken: s, adapter: s, responseType: s, xsrfCookieName: s, xsrfHeaderName: s, onUploadProgress: s, onDownloadProgress: s, decompress: s, maxContentLength: s, maxBodyLength: s, beforeRedirect: s, transport: s, httpAgent: s, httpsAgent: s, cancelToken: s, socketPath: s, responseEncoding: s, validateStatus: a, headers: (u, c, f) => i(Fh(u), Fh(c), f, !0) }; return T.forEach(Object.keys({ ...e, ...t }), function (c) { const f = l[c] || i, d = f(e[c], t[c], c); T.isUndefined(d) && f !== a || (n[c] = d) }), n } const C0 = e => { const t = On({}, e); let { data: n, withXSRFToken: r, xsrfHeaderName: i, xsrfCookieName: o, headers: s, auth: a } = t; if (t.headers = s = dt.from(s), t.url = v0(T0(t.baseURL, t.url, t.allowAbsoluteUrls), e.params, e.paramsSerializer), a && s.set("Authorization", "Basic " + btoa((a.username || "") + ":" + (a.password ? unescape(encodeURIComponent(a.password)) : ""))), T.isFormData(n)) { if (Se.hasStandardBrowserEnv || Se.hasStandardBrowserWebWorkerEnv) s.setContentType(void 0); else if (T.isFunction(n.getHeaders)) { const l = n.getHeaders(), u = ["content-type", "content-length"]; Object.entries(l).forEach(([c, f]) => { u.includes(c.toLowerCase()) && s.set(c, f) }) } } if (Se.hasStandardBrowserEnv && (r && T.isFunction(r) && (r = r(t)), r || r !== !1 && Wk(t.url))) { const l = i && o && Hk.read(o); l && s.set(i, l) } return t }, Xk = typeof XMLHttpRequest < "u", Yk = Xk && function (e) { return new Promise(function (n, r) { const i = C0(e); let o = i.data; const s = dt.from(i.headers).normalize(); let { responseType: a, onUploadProgress: l, onDownloadProgress: u } = i, c, f, d, g, y; function v() { g && g(), y && y(), i.cancelToken && i.cancelToken.unsubscribe(c), i.signal && i.signal.removeEventListener("abort", c) } let S = new XMLHttpRequest; S.open(i.method.toUpperCase(), i.url, !0), S.timeout = i.timeout; function p() { if (!S) return; const m = dt.from("getAllResponseHeaders" in S && S.getAllResponseHeaders()), E = { data: !a || a === "text" || a === "json" ? S.responseText : S.response, status: S.status, statusText: S.statusText, headers: m, config: e, request: S }; E0(function (P) { n(P), v() }, function (P) { r(P), v() }, E), S = null } "onloadend" in S ? S.onloadend = p : S.onreadystatechange = function () { !S || S.readyState !== 4 || S.status === 0 && !(S.responseURL && S.responseURL.indexOf("file:") === 0) || setTimeout(p) }, S.onabort = function () { S && (r(new I("Request aborted", I.ECONNABORTED, e, S)), S = null) }, S.onerror = function (x) { const E = x && x.message ? x.message : "Network Error", k = new I(E, I.ERR_NETWORK, e, S); k.event = x || null, r(k), S = null }, S.ontimeout = function () { let x = i.timeout ? "timeout of " + i.timeout + "ms exceeded" : "timeout exceeded"; const E = i.transitional || w0; i.timeoutErrorMessage && (x = i.timeoutErrorMessage), r(new I(x, E.clarifyTimeoutError ? I.ETIMEDOUT : I.ECONNABORTED, e, S)), S = null }, o === void 0 && s.setContentType(null), "setRequestHeader" in S && T.forEach(s.toJSON(), function (x, E) { S.setRequestHeader(E, x) }), T.isUndefined(i.withCredentials) || (S.withCredentials = !!i.withCredentials), a && a !== "json" && (S.responseType = i.responseType), u && ([d, y] = ps(u, !0), S.addEventListener("progress", d)), l && S.upload && ([f, g] = ps(l), S.upload.addEventListener("progress", f), S.upload.addEventListener("loadend", g)), (i.cancelToken || i.signal) && (c = m => { S && (r(!m || m.type ? new Ar(null, e, S) : m), S.abort(), S = null) }, i.cancelToken && i.cancelToken.subscribe(c), i.signal && (i.signal.aborted ? c() : i.signal.addEventListener("abort", c))); const h = Uk(i.url); if (h && Se.protocols.indexOf(h) === -1) { r(new I("Unsupported protocol " + h + ":", I.ERR_BAD_REQUEST, e)); return } S.send(o || null) }) }, Qk = (e, t) => { const { length: n } = e = e ? e.filter(Boolean) : []; if (t || n) { let r = new AbortController, i; const o = function (u) { if (!i) { i = !0, a(); const c = u instanceof Error ? u : this.reason; r.abort(c instanceof I ? c : new Ar(c instanceof Error ? c.message : c)) } }; let s = t && setTimeout(() => { s = null, o(new I(`timeout ${t} of ms exceeded`, I.ETIMEDOUT)) }, t); const a = () => { e && (s && clearTimeout(s), s = null, e.forEach(u => { u.unsubscribe ? u.unsubscribe(o) : u.removeEventListener("abort", o) }), e = null) }; e.forEach(u => u.addEventListener("abort", o)); const { signal: l } = r; return l.unsubscribe = () => T.asap(a), l } }, qk = Qk, Jk = function* (e, t) { let n = e.byteLength; if (!t || n < t) { yield e; return } let r = 0, i; for (; r < n;)i = r + t, yield e.slice(r, i), r = i }, Zk = async function* (e, t) { for await (const n of eR(e)) yield* Jk(n, t) }, eR = async function* (e) { if (e[Symbol.asyncIterator]) { yield* e; return } const t = e.getReader(); try { for (; ;) { const { done: n, value: r } = await t.read(); if (n) break; yield r } } finally { await t.cancel() } }, jh = (e, t, n, r) => { const i = Zk(e, t); let o = 0, s, a = l => { s || (s = !0, r && r(l)) }; return new ReadableStream({ async pull(l) { try { const { done: u, value: c } = await i.next(); if (u) { a(), l.close(); return } let f = c.byteLength; if (n) { let d = o += f; n(d) } l.enqueue(new Uint8Array(c)) } catch (u) { throw a(u), u } }, cancel(l) { return a(l), i.return() } }, { highWaterMark: 2 }) }, Bh = 64 * 1024, { isFunction: ho } = T, tR = (({ Request: e, Response: t }) => ({ Request: e, Response: t }))(T.global), { ReadableStream: zh, TextEncoder: Uh } = T.global, $h = (e, ...t) => { try { return !!e(...t) } catch { return !1 } }, nR = e => { e = T.merge.call({ skipUndefined: !0 }, tR, e); const { fetch: t, Request: n, Response: r } = e, i = t ? ho(t) : typeof fetch == "function", o = ho(n), s = ho(r); if (!i) return !1; const a = i && ho(zh), l = i && (typeof Uh == "function" ? (y => v => y.encode(v))(new Uh) : async y => new Uint8Array(await new n(y).arrayBuffer())), u = o && a && $h(() => { let y = !1; const v = new n(Se.origin, { body: new zh, method: "POST", get duplex() { return y = !0, "half" } }).headers.has("Content-Type"); return y && !v }), c = s && a && $h(() => T.isReadableStream(new r("").body)), f = { stream: c && (y => y.body) }; i && ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(y => { !f[y] && (f[y] = (v, S) => { let p = v && v[y]; if (p) return p.call(v); throw new I(`Response type '${y}' is not supported`, I.ERR_NOT_SUPPORT, S) }) }); const d = async y => { if (y == null) return 0; if (T.isBlob(y)) return y.size; if (T.isSpecCompliantForm(y)) return (await new n(Se.origin, { method: "POST", body: y }).arrayBuffer()).byteLength; if (T.isArrayBufferView(y) || T.isArrayBuffer(y)) return y.byteLength; if (T.isURLSearchParams(y) && (y = y + ""), T.isString(y)) return (await l(y)).byteLength }, g = async (y, v) => { const S = T.toFiniteNumber(y.getContentLength()); return S ?? d(v) }; return async y => { let { url: v, method: S, data: p, signal: h, cancelToken: m, timeout: x, onDownloadProgress: E, onUploadProgress: k, responseType: P, headers: C, withCredentials: O = "same-origin", fetchOptions: M } = C0(y), K = t || fetch; P = P ? (P + "").toLowerCase() : "text"; let Te = qk([h, m && m.toAbortSignal()], x), Fe = null; const je = Te && Te.unsubscribe && (() => { Te.unsubscribe() }); let dn; try { if (k && u && S !== "get" && S !== "head" && (dn = await g(C, p)) !== 0) { let B = new n(v, { method: "POST", body: p, duplex: "half" }), $; if (T.isFormData(p) && ($ = B.headers.get("content-type")) && C.setContentType($), B.body) { const [Bt, Ge] = Vh(dn, ps(Ih(k))); p = jh(B.body, Bh, Bt, Ge) } } T.isString(O) || (O = O ? "include" : "omit"); const Ce = o && "credentials" in n.prototype, G = { ...M, signal: Te, method: S.toUpperCase(), headers: C.normalize().toJSON(), body: p, duplex: "half", credentials: Ce ? O : void 0 }; Fe = o && new n(v, G); let L = await (o ? K(Fe, M) : K(v, G)); const N = c && (P === "stream" || P === "response"); if (c && (E || N && je)) { const B = {};["status", "statusText", "headers"].forEach(In => { B[In] = L[In] }); const $ = T.toFiniteNumber(L.headers.get("content-length")), [Bt, Ge] = E && Vh($, ps(Ih(E), !0)) || []; L = new r(jh(L.body, Bh, Bt, () => { Ge && Ge(), je && je() }), B) } P = P || "text"; let V = await f[T.findKey(f, P) || "text"](L, y); return !N && je && je(), await new Promise((B, $) => { E0(B, $, { data: V, headers: dt.from(L.headers), status: L.status, statusText: L.statusText, config: y, request: Fe }) }) } catch (Ce) { throw je && je(), Ce && Ce.name === "TypeError" && /Load failed|fetch/i.test(Ce.message) ? Object.assign(new I("Network Error", I.ERR_NETWORK, y, Fe), { cause: Ce.cause || Ce }) : I.from(Ce, Ce && Ce.code, y, Fe) } } }, rR = new Map, P0 = e => { let t = e && e.env || {}; const { fetch: n, Request: r, Response: i } = t, o = [r, i, n]; let s = o.length, a = s, l, u, c = rR; for (; a--;)l = o[a], u = c.get(l), u === void 0 && c.set(l, u = a ? new Map : nR(t)), c = u; return u }; P0(); const Gc = { http: vk, xhr: Yk, fetch: { get: P0 } }; T.forEach(Gc, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch { } Object.defineProperty(e, "adapterName", { value: t }) } }); const bh = e => `- ${e}`, iR = e => T.isFunction(e) || e === null || e === !1; function oR(e, t) {
  e = T.isArray(e) ? e : [e]; const { length: n } = e; let r, i; const o = {}; for (let s = 0; s < n; s++) { r = e[s]; let a; if (i = r, !iR(r) && (i = Gc[(a = String(r)).toLowerCase()], i === void 0)) throw new I(`Unknown adapter '${a}'`); if (i && (T.isFunction(i) || (i = i.get(t)))) break; o[a || "#" + s] = i } if (!i) {
    const s = Object.entries(o).map(([l, u]) => `adapter ${l} ` + (u === !1 ? "is not supported by the environment" : "is not available in the build")); let a = n ? s.length > 1 ? `since :
`+ s.map(bh).join(`
`) : " " + bh(s[0]) : "as no adapter specified"; throw new I("There is no suitable adapter to dispatch the request " + a, "ERR_NOT_SUPPORT")
  } return i
} const k0 = { getAdapter: oR, adapters: Gc }; function Fa(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new Ar(null, e) } function Wh(e) { return Fa(e), e.headers = dt.from(e.headers), e.data = Ia.call(e, e.transformRequest), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), k0.getAdapter(e.adapter || Kc.adapter, e)(e).then(function (r) { return Fa(e), r.data = Ia.call(e, e.transformResponse, r), r.headers = dt.from(r.headers), r }, function (r) { return x0(r) || (Fa(e), r && r.response && (r.response.data = Ia.call(e, e.transformResponse, r.response), r.response.headers = dt.from(r.response.headers))), Promise.reject(r) }) } const R0 = "1.13.2", bs = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { bs[e] = function (r) { return typeof r === e || "a" + (t < 1 ? "n " : " ") + e } }); const Hh = {}; bs.transitional = function (t, n, r) { function i(o, s) { return "[Axios v" + R0 + "] Transitional option '" + o + "'" + s + (r ? ". " + r : "") } return (o, s, a) => { if (t === !1) throw new I(i(s, " has been removed" + (n ? " in " + n : "")), I.ERR_DEPRECATED); return n && !Hh[s] && (Hh[s] = !0, console.warn(i(s, " has been deprecated since v" + n + " and will be removed in the near future"))), t ? t(o, s, a) : !0 } }; bs.spelling = function (t) { return (n, r) => (console.warn(`${r} is likely a misspelling of ${t}`), !0) }; function sR(e, t, n) { if (typeof e != "object") throw new I("options must be an object", I.ERR_BAD_OPTION_VALUE); const r = Object.keys(e); let i = r.length; for (; i-- > 0;) { const o = r[i], s = t[o]; if (s) { const a = e[o], l = a === void 0 || s(a, o, e); if (l !== !0) throw new I("option " + o + " must be " + l, I.ERR_BAD_OPTION_VALUE); continue } if (n !== !0) throw new I("Unknown option " + o, I.ERR_BAD_OPTION) } } const Vo = { assertOptions: sR, validators: bs }, gt = Vo.validators; class ms {
  constructor(t) { this.defaults = t || {}, this.interceptors = { request: new Oh, response: new Oh } } async request(t, n) {
    try { return await this._request(t, n) } catch (r) {
      if (r instanceof Error) {
        let i = {}; Error.captureStackTrace ? Error.captureStackTrace(i) : i = new Error; const o = i.stack ? i.stack.replace(/^.+\n/, "") : ""; try {
          r.stack ? o && !String(r.stack).endsWith(o.replace(/^.+\n.+\n/, "")) && (r.stack += `
`+ o) : r.stack = o
        } catch { }
      } throw r
    }
  } _request(t, n) { typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = On(this.defaults, n); const { transitional: r, paramsSerializer: i, headers: o } = n; r !== void 0 && Vo.assertOptions(r, { silentJSONParsing: gt.transitional(gt.boolean), forcedJSONParsing: gt.transitional(gt.boolean), clarifyTimeoutError: gt.transitional(gt.boolean) }, !1), i != null && (T.isFunction(i) ? n.paramsSerializer = { serialize: i } : Vo.assertOptions(i, { encode: gt.function, serialize: gt.function }, !0)), n.allowAbsoluteUrls !== void 0 || (this.defaults.allowAbsoluteUrls !== void 0 ? n.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls : n.allowAbsoluteUrls = !0), Vo.assertOptions(n, { baseUrl: gt.spelling("baseURL"), withXsrfToken: gt.spelling("withXSRFToken") }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase(); let s = o && T.merge(o.common, o[n.method]); o && T.forEach(["delete", "get", "head", "post", "put", "patch", "common"], y => { delete o[y] }), n.headers = dt.concat(s, o); const a = []; let l = !0; this.interceptors.request.forEach(function (v) { typeof v.runWhen == "function" && v.runWhen(n) === !1 || (l = l && v.synchronous, a.unshift(v.fulfilled, v.rejected)) }); const u = []; this.interceptors.response.forEach(function (v) { u.push(v.fulfilled, v.rejected) }); let c, f = 0, d; if (!l) { const y = [Wh.bind(this), void 0]; for (y.unshift(...a), y.push(...u), d = y.length, c = Promise.resolve(n); f < d;)c = c.then(y[f++], y[f++]); return c } d = a.length; let g = n; for (; f < d;) { const y = a[f++], v = a[f++]; try { g = y(g) } catch (S) { v.call(this, S); break } } try { c = Wh.call(this, g) } catch (y) { return Promise.reject(y) } for (f = 0, d = u.length; f < d;)c = c.then(u[f++], u[f++]); return c } getUri(t) { t = On(this.defaults, t); const n = T0(t.baseURL, t.url, t.allowAbsoluteUrls); return v0(n, t.params, t.paramsSerializer) }
} T.forEach(["delete", "get", "head", "options"], function (t) { ms.prototype[t] = function (n, r) { return this.request(On(r || {}, { method: t, url: n, data: (r || {}).data })) } }); T.forEach(["post", "put", "patch"], function (t) { function n(r) { return function (o, s, a) { return this.request(On(a || {}, { method: t, headers: r ? { "Content-Type": "multipart/form-data" } : {}, url: o, data: s })) } } ms.prototype[t] = n(), ms.prototype[t + "Form"] = n(!0) }); const Io = ms; class Xc { constructor(t) { if (typeof t != "function") throw new TypeError("executor must be a function."); let n; this.promise = new Promise(function (o) { n = o }); const r = this; this.promise.then(i => { if (!r._listeners) return; let o = r._listeners.length; for (; o-- > 0;)r._listeners[o](i); r._listeners = null }), this.promise.then = i => { let o; const s = new Promise(a => { r.subscribe(a), o = a }).then(i); return s.cancel = function () { r.unsubscribe(o) }, s }, t(function (o, s, a) { r.reason || (r.reason = new Ar(o, s, a), n(r.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { if (this.reason) { t(this.reason); return } this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const n = this._listeners.indexOf(t); n !== -1 && this._listeners.splice(n, 1) } toAbortSignal() { const t = new AbortController, n = r => { t.abort(r) }; return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal } static source() { let t; return { token: new Xc(function (i) { t = i }), cancel: t } } } const aR = Xc; function lR(e) { return function (n) { return e.apply(null, n) } } function uR(e) { return T.isObject(e) && e.isAxiosError === !0 } const su = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511, WebServerIsDown: 521, ConnectionTimedOut: 522, OriginIsUnreachable: 523, TimeoutOccurred: 524, SslHandshakeFailed: 525, InvalidSslCertificate: 526 }; Object.entries(su).forEach(([e, t]) => { su[t] = e }); const cR = su; function A0(e) { const t = new Io(e), n = s0(Io.prototype.request, t); return T.extend(n, Io.prototype, t, { allOwnKeys: !0 }), T.extend(n, t, null, { allOwnKeys: !0 }), n.create = function (i) { return A0(On(e, i)) }, n } const oe = A0(Kc); oe.Axios = Io; oe.CanceledError = Ar; oe.CancelToken = aR; oe.isCancel = x0; oe.VERSION = R0; oe.toFormData = Us; oe.AxiosError = I; oe.Cancel = oe.CanceledError; oe.all = function (t) { return Promise.all(t) }; oe.spread = lR; oe.isAxiosError = uR; oe.mergeConfig = On; oe.AxiosHeaders = dt; oe.formToJSON = e => S0(T.isHTMLForm(e) ? new FormData(e) : e); oe.getAdapter = k0.getAdapter; oe.HttpStatusCode = cR; oe.default = oe; const fR = oe, dR = "/api", au = fR.create({ baseURL: dR }); au.interceptors.request.use(e => { const t = e.url.includes("/staff/"), n = window.location.pathname.includes("/staff/"), r = t || n, i = r ? localStorage.getItem("staffToken") : localStorage.getItem("token"); return i && (e.headers.Authorization = `Bearer ${i}`), console.log(`[API REQUEST] ${e.method.toUpperCase()} ${e.baseURL}${e.url} (Using ${r ? "Staff" : "Public"} Token)`), e }, e => Promise.reject(e)); const hR = w.lazy(() => de(() => import("./Home-0a6b12e0.js"), ["assets/Home-0a6b12e0.js", "assets/menu-52d4f898.js", "assets/gavel-50392d16.js", "assets/shield-1033dda0.js"])), pR = w.lazy(() => de(() => import("./Login-f289e772.js"), ["assets/Login-f289e772.js", "assets/lock-2d4848cc.js", "assets/eye-off-2962c434.js", "assets/eye-7d150dac.js"])), mR = w.lazy(() => de(() => import("./Register-23778e95.js"), ["assets/Register-23778e95.js", "assets/eye-off-2962c434.js", "assets/eye-7d150dac.js"])), yR = w.lazy(() => de(() => import("./ForgotPassword-7b85e832.js"), ["assets/ForgotPassword-7b85e832.js", "assets/arrow-left-87f00f60.js", "assets/mail-7147b856.js"])), gR = w.lazy(() => de(() => import("./ResetPassword-7b198da4.js"), ["assets/ResetPassword-7b198da4.js", "assets/lock-2d4848cc.js"])), vR = w.lazy(() => de(() => import("./ConfirmEmail-c748eccd.js"), [])), wR = w.lazy(() => de(() => import("./ModuleSelection-4605b88b.js"), ["assets/ModuleSelection-4605b88b.js", "assets/gavel-50392d16.js", "assets/file-text-05ff1bfe.js"])), SR = w.lazy(() => de(() => import("./OADRDashboard-0228ad27.js"), ["assets/OADRDashboard-0228ad27.js", "assets/dateUtils-0cf2816c.js", "assets/html2canvas.esm-7584f2e8.js", "assets/RichTextEditor-afbee9ff.js", "assets/list-1b284b06.js", "assets/image-fb628d93.js", "assets/ImageCapture-db49fbfc.js", "assets/credit-card-7df9ba98.js", "assets/SupportTickets-1bec5e21.js", "assets/menu-52d4f898.js", "assets/mail-7147b856.js", "assets/refresh-cw-24e393f6.js", "assets/file-text-05ff1bfe.js", "assets/download-8bb8051d.js", "assets/api-e39129c6.js", "assets/video-c62c1d23.js", "assets/phone-a42f05a3.js", "assets/PublicAnalytics-f4f515fa.js", "assets/activity-566acbed.js", "assets/PublicProfile-eb207c97.js", "assets/shield-1033dda0.js", "assets/lock-2d4848cc.js", "assets/history-5f7ad8ed.js"])), xR = w.lazy(() => de(() => import("./ProbateDashboard-b630eacb.js"), ["assets/ProbateDashboard-b630eacb.js", "assets/ProbateApplicationDetails-2d4ae9c5.js", "assets/dateUtils-0cf2816c.js", "assets/SupportTickets-1bec5e21.js", "assets/menu-52d4f898.js", "assets/mail-7147b856.js", "assets/ImageCapture-db49fbfc.js", "assets/html2canvas.esm-7584f2e8.js", "assets/credit-card-7df9ba98.js", "assets/refresh-cw-24e393f6.js", "assets/file-text-05ff1bfe.js", "assets/arrow-left-87f00f60.js", "assets/briefcase-8ab53315.js", "assets/trash-2-9ff1ad5f.js", "assets/shield-1033dda0.js", "assets/download-8bb8051d.js", "assets/PublicAnalytics-f4f515fa.js", "assets/activity-566acbed.js", "assets/PublicProfile-eb207c97.js", "assets/phone-a42f05a3.js", "assets/lock-2d4848cc.js"])), ER = w.lazy(() => de(() => import("./Verification-dbc4b4ca.js"), ["assets/Verification-dbc4b4ca.js", "assets/dateUtils-0cf2816c.js", "assets/arrow-left-87f00f60.js", "assets/shield-1033dda0.js", "assets/file-text-05ff1bfe.js"])), TR = w.lazy(() => de(() => import("./StaffLogin-281b0a32.js"), [])), CR = w.lazy(() => de(() => import("./AdminDashboard-7bab8008.js"), ["assets/AdminDashboard-7bab8008.js", "assets/SupportTickets-1bec5e21.js", "assets/dateUtils-0cf2816c.js", "assets/menu-52d4f898.js", "assets/mail-7147b856.js", "assets/user-plus-bcd5904a.js", "assets/eye-off-2962c434.js", "assets/eye-7d150dac.js", "assets/trash-2-9ff1ad5f.js", "assets/shield-1033dda0.js", "assets/download-8bb8051d.js", "assets/RichTextEditor-afbee9ff.js", "assets/list-1b284b06.js", "assets/image-fb628d93.js", "assets/save-96d3a65b.js", "assets/file-text-05ff1bfe.js", "assets/StaffProfile-a6896eb8.js", "assets/lock-2d4848cc.js", "assets/activity-566acbed.js", "assets/refresh-cw-24e393f6.js", "assets/credit-card-7df9ba98.js"])), PR = w.lazy(() => de(() => import("./CFODashboard-661c3aea.js"), ["assets/CFODashboard-661c3aea.js", "assets/SupportTickets-1bec5e21.js", "assets/dateUtils-0cf2816c.js", "assets/menu-52d4f898.js", "assets/mail-7147b856.js", "assets/StaffProfile-a6896eb8.js", "assets/shield-1033dda0.js", "assets/lock-2d4848cc.js", "assets/file-text-05ff1bfe.js", "assets/video-c62c1d23.js", "assets/html2canvas.esm-7584f2e8.js", "assets/api-e39129c6.js", "assets/phone-a42f05a3.js", "assets/eye-7d150dac.js", "assets/download-8bb8051d.js", "assets/landmark-c0bed167.js"])), kR = w.lazy(() => de(() => import("./CRDashboard-20d84b11.js"), ["assets/CRDashboard-20d84b11.js", "assets/dateUtils-0cf2816c.js", "assets/SupportTickets-1bec5e21.js", "assets/menu-52d4f898.js", "assets/mail-7147b856.js", "assets/arrow-left-87f00f60.js", "assets/briefcase-8ab53315.js", "assets/shield-1033dda0.js", "assets/file-text-05ff1bfe.js", "assets/RegistryAnalytics-787f1da5.js", "assets/list-1b284b06.js", "assets/video-c62c1d23.js", "assets/refresh-cw-24e393f6.js", "assets/eye-7d150dac.js", "assets/StaffProfile-a6896eb8.js", "assets/lock-2d4848cc.js"])), RR = w.lazy(() => de(() => import("./PRDashboard-914766c0.js"), ["assets/PRDashboard-914766c0.js", "assets/SupportTickets-1bec5e21.js", "assets/dateUtils-0cf2816c.js", "assets/menu-52d4f898.js", "assets/mail-7147b856.js", "assets/StaffProfile-a6896eb8.js", "assets/shield-1033dda0.js", "assets/lock-2d4848cc.js", "assets/RegistryAnalytics-787f1da5.js", "assets/list-1b284b06.js", "assets/file-text-05ff1bfe.js", "assets/video-c62c1d23.js", "assets/refresh-cw-24e393f6.js", "assets/arrow-left-87f00f60.js", "assets/briefcase-8ab53315.js", "assets/eye-7d150dac.js"])), AR = w.lazy(() => de(() => import("./JuratDashboard-7709f2b3.js"), ["assets/JuratDashboard-7709f2b3.js", "assets/ApplicantManager-e6297b3e.js", "assets/dateUtils-0cf2816c.js", "assets/SupportTickets-1bec5e21.js", "assets/menu-52d4f898.js", "assets/mail-7147b856.js", "assets/ImageCapture-db49fbfc.js", "assets/html2canvas.esm-7584f2e8.js", "assets/credit-card-7df9ba98.js", "assets/refresh-cw-24e393f6.js", "assets/user-plus-bcd5904a.js", "assets/file-text-05ff1bfe.js", "assets/trash-2-9ff1ad5f.js", "assets/image-fb628d93.js", "assets/download-8bb8051d.js", "assets/StaffProfile-a6896eb8.js", "assets/shield-1033dda0.js", "assets/lock-2d4848cc.js", "assets/RichTextEditor-afbee9ff.js", "assets/list-1b284b06.js", "assets/save-96d3a65b.js", "assets/landmark-c0bed167.js", "assets/arrow-left-87f00f60.js"])), LR = w.lazy(() => de(() => import("./PDDashboard-07f07843.js"), ["assets/PDDashboard-07f07843.js", "assets/ApplicantManager-e6297b3e.js", "assets/dateUtils-0cf2816c.js", "assets/SupportTickets-1bec5e21.js", "assets/menu-52d4f898.js", "assets/mail-7147b856.js", "assets/ImageCapture-db49fbfc.js", "assets/html2canvas.esm-7584f2e8.js", "assets/credit-card-7df9ba98.js", "assets/refresh-cw-24e393f6.js", "assets/user-plus-bcd5904a.js", "assets/file-text-05ff1bfe.js", "assets/trash-2-9ff1ad5f.js", "assets/image-fb628d93.js", "assets/PublicAnalytics-f4f515fa.js", "assets/download-8bb8051d.js", "assets/activity-566acbed.js", "assets/ProbateApplicationDetails-2d4ae9c5.js", "assets/arrow-left-87f00f60.js", "assets/briefcase-8ab53315.js", "assets/shield-1033dda0.js", "assets/StaffProfile-a6896eb8.js", "assets/lock-2d4848cc.js", "assets/history-5f7ad8ed.js"])), DR = ({ user: e, setUser: t, staff: n, setStaff: r }) => { const i = Pt(); return R.jsx(vg, { mode: "wait", children: R.jsx(w.Suspense, { fallback: R.jsx(MP, { message: "Loading Page..." }), children: R.jsxs(tS, { location: i, children: [R.jsx(se, { path: "/", element: R.jsx(hR, {}) }), R.jsx(se, { path: "/verify/:type", element: R.jsx(ER, {}) }), R.jsx(se, { path: "/login", element: R.jsx(pR, { setUser: o => { localStorage.setItem("user", JSON.stringify(o)), t(o) } }) }), R.jsx(se, { path: "/register", element: R.jsx(mR, {}) }), R.jsx(se, { path: "/forgot-password", element: R.jsx(yR, {}) }), R.jsx(se, { path: "/reset-password", element: R.jsx(gR, {}) }), R.jsx(se, { path: "/confirm-email", element: R.jsx(vR, {}) }), R.jsx(se, { path: "/modules", element: e ? R.jsx(wR, { user: e }) : R.jsx(it, { to: "/login" }) }), R.jsx(se, { path: "/oadr/*", element: e ? R.jsx(SR, { user: e }) : R.jsx(it, { to: "/login" }) }), R.jsx(se, { path: "/probate/*", element: e ? R.jsx(xR, { user: e }) : R.jsx(it, { to: "/login" }) }), R.jsx(se, { path: "/staff/login", element: R.jsx(TR, { setStaff: o => { localStorage.setItem("staff", JSON.stringify(o)), r(o) } }) }), R.jsx(se, { path: "/staff/admin", element: n && n.role === "admin" ? R.jsx(CR, { staff: n }) : R.jsx(it, { to: "/staff/login" }) }), R.jsx(se, { path: "/staff/cfo", element: n && n.role === "cfo" ? R.jsx(PR, { staff: n }) : R.jsx(it, { to: "/staff/login" }) }), R.jsx(se, { path: "/staff/cr", element: n && n.role === "cr" ? R.jsx(kR, { staff: n }) : R.jsx(it, { to: "/staff/login" }) }), R.jsx(se, { path: "/staff/pr", element: n && (n.role === "registrar" || n.role === "pr") ? R.jsx(RR, { staff: n }) : R.jsx(it, { to: "/staff/login" }) }), R.jsx(se, { path: "/staff/jurat", element: n && n.role === "jurat" ? R.jsx(AR, { staff: n }) : R.jsx(it, { to: "/staff/login" }) }), R.jsx(se, { path: "/staff/pd", element: n && n.role === "pd" ? R.jsx(LR, { staff: n }) : R.jsx(it, { to: "/staff/login" }) }), R.jsx(se, { path: "/staff", element: !n || !n.role ? R.jsx(it, { to: "/staff/login" }) : R.jsx(it, { to: `/staff/${n.role === "registrar" || n.role === "pr" ? "pr" : n.role}` }) })] }, i.pathname) }) }) }, _R = () => { const [e, t] = w.useState(() => { const o = localStorage.getItem("user"); return o ? JSON.parse(o) : null }), [n, r] = w.useState(() => { const o = localStorage.getItem("staff"); return o ? JSON.parse(o) : null }), i = o => { const s = window.location.pathname.startsWith("/staff"); s ? (localStorage.removeItem("staffToken"), localStorage.removeItem("staff"), r(null)) : (localStorage.removeItem("token"), localStorage.removeItem("user"), t(null)); const a = s ? "/staff/login" : "/login"; window.location.href = typeof o == "string" ? `${a}?reason=${o}` : a }; return w.useEffect(() => { let o; const a = () => { o && clearTimeout(o), (e || n) && (o = setTimeout(() => { console.log("Session expired due to inactivity"), i("timeout") }, 36e5)) }, l = ["mousedown", "mousemove", "keypress", "scroll", "touchstart"]; return l.forEach(u => document.addEventListener(u, a)), a(), () => { o && clearTimeout(o), l.forEach(u => document.removeEventListener(u, a)) } }, [e, n]), w.useEffect(() => { (async () => { var l, u; const s = localStorage.getItem("token"), a = localStorage.getItem("staffToken"); if (s && localStorage.getItem("user")) try { const f = (await au.get("/public/profile")).data; f.firstName = f.first_name, f.middleName = f.middle_name, localStorage.setItem("user", JSON.stringify(f)), t(f) } catch (c) { console.error("Failed to refresh public profile:", c), ((l = c.response) == null ? void 0 : l.status) === 401 && (localStorage.removeItem("token"), localStorage.removeItem("user"), t(null)) } if (a && localStorage.getItem("staff")) try { const f = (await au.get("/staff/profile")).data; localStorage.setItem("staff", JSON.stringify(f)), r(f) } catch (c) { console.error("Failed to refresh staff profile:", c), ((u = c.response) == null ? void 0 : u.status) === 401 && (localStorage.removeItem("staffToken"), localStorage.removeItem("staff"), r(null)) } })() }, []), R.jsx(RS, { children: R.jsx(DR, { user: e, setUser: t, staff: n, setStaff: r }) }) }; const MR = ({ isOpen: e, onClose: t, type: n = "info", title: r, message: i, onConfirm: o, confirmText: s = "OK", cancelText: a = "Cancel", showCancel: l = !1, showInput: u = !1, inputPlaceholder: c = "Type here...", inputType: f = "text" }) => { const [d, g] = ja.useState(""); if (ja.useEffect(() => { e && g("") }, [e]), !e) return null; const y = () => { o && o(d), t() }, v = () => { switch (n) { case "success": return R.jsx(TP, { size: 48, color: "#10b981" }); case "error": return R.jsx(PP, { size: 48, color: "#f43f5e" }); case "warning": return R.jsx(xP, { size: 48, color: "#f59e0b" }); default: return R.jsx(RP, { size: 48, color: "#3b82f6" }) } }, S = p => { const h = { padding: "10px 24px", borderRadius: "8px", border: "none", fontSize: "14px", fontWeight: "600", cursor: "pointer", transition: "transform 0.1s" }; if (!p) return { ...h, background: "white", border: "1px solid #e2e8f0", color: "#778eaeff" }; let m = "#3b82f6"; return n === "success" && (m = "#10b981"), n === "error" && (m = "#f43f5e"), n === "warning" && (m = "#f59e0b"), { ...h, background: m, color: "white", boxShadow: "0 4px 6px -1px rgba(0, 0, 0, 0.1)" } }; return R.jsx(vg, { children: e && R.jsx("div", { style: { position: "fixed", top: 0, left: 0, right: 0, bottom: 0, zIndex: 9999, background: "rgba(0, 0, 0, 0.5)", display: "flex", alignItems: "center", justifyContent: "center", backdropFilter: "blur(4px)", padding: "1rem" }, children: R.jsxs(Mo.div, { initial: { opacity: 0, scale: .95, y: 10 }, animate: { opacity: 1, scale: 1, y: 0 }, exit: { opacity: 0, scale: .95, y: 10 }, transition: { duration: .2 }, style: { background: "white", borderRadius: "16px", boxShadow: "0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)", width: "100%", maxWidth: "450px", position: "relative", overflow: "hidden" }, children: [R.jsx("button", { onClick: t, style: { position: "absolute", top: "16px", right: "16px", background: "transparent", border: "none", cursor: "pointer", padding: "4px", borderRadius: "50%", display: "flex", alignItems: "center", justifyContent: "center", color: "#94a3b8" }, children: R.jsx(_P, { size: 20 }) }), R.jsxs("div", { style: { padding: "2.5rem 2rem 2rem", textAlign: "center" }, children: [R.jsx("div", { style: { display: "flex", justifyContent: "center", marginBottom: "1.5rem" }, children: R.jsx("div", { style: { padding: "1rem", borderRadius: "50%", background: n === "success" ? "#ecfdf5" : n === "error" ? "#fff1f2" : n === "warning" ? "#fffbeb" : "#eff6ff" }, children: v() }) }), R.jsx("h3", { style: { margin: "0 0 0.75rem", fontSize: "1.5rem", fontWeight: "700", color: "rgb\(18 37 74\)" }, children: r }), R.jsx("p", { style: { color: "#778eaeff", marginBottom: u ? "1rem" : "2rem", lineHeight: "1.6", fontSize: "15px" }, children: i }), u && R.jsx("div", { style: { marginBottom: "2rem" }, children: f === "textarea" ? R.jsx("textarea", { value: d, onChange: p => g(p.target.value), placeholder: c, autoFocus: !0, style: { width: "100%", padding: "12px", borderRadius: "8px", border: "1px solid #e2e8f0", fontSize: "14px", fontFamily: "inherit", minHeight: "100px", resize: "vertical", outline: "none", boxSizing: "border-box" } }) : R.jsx("input", { type: f, value: d, onChange: p => g(p.target.value), placeholder: c, autoFocus: !0, style: { width: "100%", padding: "12px", borderRadius: "8px", border: "1px solid #e2e8f0", fontSize: "14px", outline: "none", boxSizing: "border-box" } }) }), R.jsxs("div", { style: { display: "flex", gap: "1rem", justifyContent: "center" }, children: [l && R.jsx("button", { onClick: () => { t && t() }, style: S(!1), children: a }), R.jsx("button", { onClick: y, style: S(!0), children: s })] })] })] }) }) }) }, L0 = w.createContext(), OR = ({ children: e }) => { const [t, n] = w.useState(!1), [r, i] = w.useState({ type: "info", title: "", message: "", onConfirm: null, confirmText: "OK", cancelText: "Cancel", showCancel: !1, showInput: !1, inputPlaceholder: "", inputType: "text" }), o = w.useCallback(({ type: a = "info", title: l, message: u, onConfirm: c, confirmText: f = "OK", cancelText: d = "Cancel", showCancel: g = !1, showInput: y = !1, inputPlaceholder: v = "", inputType: S = "text" }) => { i({ type: a, title: l, message: u, onConfirm: c, confirmText: f, cancelText: d, showCancel: g, showInput: y, inputPlaceholder: v, inputType: S }), n(!0) }, []), s = w.useCallback(() => { n(!1) }, []); return R.jsxs(L0.Provider, { value: { showModal: o, hideModal: s }, children: [e, R.jsx(MR, { isOpen: t, onClose: s, ...r })] }) }, BR = () => { const e = w.useContext(L0); if (!e) throw new Error("useModal must be used within a ModalProvider"); return e }; Ba.createRoot(document.getElementById("root")).render(R.jsx(ja.StrictMode, { children: R.jsx(OR, { children: R.jsx(_R, {}) }) })); export { vg as A, TP as C, MP as G, Ey as L, ja as R, _P as X, de as _, au as a, Pt as b, kr as c, BR as d, LP as e, IR as f, D0 as g, xP as h, PP as i, R as j, VR as k, NR as l, Mo as m, w as r, oc as u };
